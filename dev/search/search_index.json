{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Overview","text":"<p>This package loads a library in Python. It is basically just a thin wrapper around ctypes (for libraries that use the <code>__cdecl</code> or <code>__stdcall</code> calling convention), Python.NET (for libraries that use .NET, <code>CLR</code>), Py4J (for Java <code>.jar</code> or <code>.class</code> files) and comtypes (for libraries that use the Component Object Model or ActiveX).</p> <p>However, the primary advantage is that it is possible to communicate with a 32-bit library from 64-bit Python. For various reasons, mainly to do with the differences in pointer sizes, it is not possible to load a 32-bit library (e.g., <code>.dll</code>, <code>.so</code>, <code>.dylib</code> files) in a 64-bit process, and vice versa. This package contains a Server32 class that hosts a 32-bit library and a Client64 class that sends requests to the server to communicate with the 32-bit library as a form of inter-process communication.</p>"},{"location":"install/","title":"Install","text":"<p><code>msl-loadlib</code> is available for installation via the Python Package Index</p> <pre><code>pip install msl-loadlib\n</code></pre>"},{"location":"install/#optional-dependencies","title":"Optional dependencies","text":"<ul> <li>Python.NET</li> <li>Py4J</li> <li>comtypes</li> </ul> <p>You can install <code>msl-loadlib</code> and Python.NET using,</p> <pre><code>pip install msl-loadlib[clr]\n</code></pre> <p><code>msl-loadlib</code> and Py4J,</p> <pre><code>pip install msl-loadlib[java]\n</code></pre> <p><code>msl-loadlib</code> and comtypes,</p> <pre><code>pip install msl-loadlib[com]\n</code></pre> <p>or <code>msl-loadlib</code> and all optional dependencies</p> <pre><code>pip install msl-loadlib[all]\n</code></pre>"},{"location":"install/#compatibility","title":"Compatibility","text":"<ul> <li>The 32-bit server is built into a frozen executable for Windows and Linux (glibc).</li> <li>You may also create a custom 32-bit server.</li> </ul>"},{"location":"install/#prerequisites","title":"Prerequisites","text":""},{"location":"install/#windows","title":"Windows","text":"<p>64-bit Windows already comes with WoW64 to run 32-bit software and therefore no prerequisites are required to load 32-bit libraries. However, the library might have its own dependencies, such as a particular Visual C++ Redistributable, that may need to be installed.</p> <p>If you need to load a .NET library, you must install Python.NET</p> <pre><code>pip install pythonnet\n</code></pre> <p>If you need to load a Java library (i.e., a <code>.jar</code> or <code>.class</code> file), you must install Py4J,</p> <pre><code>pip install py4j\n</code></pre> <p>a Java Runtime Environment, and ensure that the <code>java</code> executable is available on the PATH environment variable. For example, the following should return the version of Java that is installed</p> <pre><code>&gt; java -version\njava version \"23.0.2\" 2025-01-21\nJava(TM) SE Runtime Environment (build 23.0.2+7-58)\nJava HotSpot(TM) 64-Bit Server VM (build 23.0.2+7-58, mixed mode, sharing)\n</code></pre> <p>If you need to load a Component Object Model or an ActiveX library you must install comtypes</p> <pre><code>pip install comtypes\n</code></pre> <p>Managing library dependencies</p> <p>When loading a library it is vital that all dependencies of the library are also on the computer and that the directory that the dependencies are located in is available on the PATH variable (and possibly you may need to add a directory with os.add_dll_directory). A helpful utility to determine the dependencies of a library on Windows is Dependencies (which is a modern Dependency Walker). Microsoft also provides the DUMPBIN tool. For finding the dependencies of a .NET library the Dependency Walker for .NET may also be helpful.</p>"},{"location":"install/#linux","title":"Linux","text":"<p>Before using <code>msl-loadlib</code> on Debian-based Linux distributions, the following packages are required. For other distributions, use the appropriate system package manager (e.g., yum) and the equivalent command.</p> <p>Install the packages that are required to load 32-bit and 64-bit C/C++ and FORTRAN libraries</p> <p>Attention</p> <p>The following packages are required to run the examples that are included with <code>msl-loadlib</code>. The dependencies for the C/C++ or FORTRAN library that you want to load may be different.</p> <pre><code>sudo dpkg --add-architecture i386\nsudo apt update\nsudo apt install g++ gfortran libgfortran5 zlib1g:i386 libstdc++6:i386 libgfortran5:i386\n</code></pre> <p>The following ensures that the ss command is available</p> <pre><code>sudo apt install iproute2\n</code></pre> <p>If you need to load a .NET library then you must install Mono and Python.NET</p> <pre><code>pip3 install pythonnet\n</code></pre> <p>Important</p> <p>As of version 0.10.0 of <code>msl-loadlib</code>, <code>pythonnet</code> is no longer installed on the 32-bit server for Linux. Mono can load both 32-bit and 64-bit libraries on 64-bit Linux and therefore a 32-bit .NET library can be loaded directly via LoadLibrary on 64-bit Linux.</p> <p>If you need to load a Java library (i.e., a <code>.jar</code> or <code>.class</code> file), you must install Py4J,</p> <pre><code>pip3 install py4j\n</code></pre> <p>and a Java Runtime Environment</p> <pre><code>sudo apt install default-jre\n</code></pre> <p>Tip</p> <p>When loading a library it is vital that all dependencies of the library are also on the computer and that the directory that the dependency is located in is available on the PATH variable. A helpful utility to determine the dependencies of a library on Unix is ldd.</p>"},{"location":"install/#macos","title":"macOS","text":"<p>The 32-bit server has not been created for macOS; however, the LoadLibrary class can be used to load a library that uses the <code>__cdecl</code> calling convention that is the same bitness as the Python interpreter, a .NET library or a Java library.</p> <p>The following assumes that you are using Homebrew as your package manager.</p> <p>Tip</p> <p>It is recommended to update Homebrew before installing packages with <code>brew update</code></p> <p>To load a C/C++ or FORTRAN library install gcc (which includes gfortran)</p> <pre><code>brew install gcc\n</code></pre> <p>If you need to load a .NET library, you must install Mono,</p> <pre><code>brew install mono\n</code></pre> <p>and Python.NET</p> <pre><code>pip3 install pythonnet\n</code></pre> <p>If you need to load a Java library (i.e., a <code>.jar</code> or <code>.class</code> file), you must install Py4J,</p> <pre><code>pip3 install py4j\n</code></pre> <p>and a Java Runtime Environment</p> <pre><code>brew cask install java\n</code></pre>"},{"location":"license/","title":"License","text":"<pre><code>MIT License\n\nCopyright (c) 2017 - 2025, Measurement Standards Laboratory of New Zealand\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n</code></pre>"},{"location":"release-notes/","title":"Release Notes","text":""},{"location":"release-notes/#unreleased","title":"unreleased","text":"<p>Added:</p> <ul> <li><code>Client64</code> now accepts <code>host=None</code> which will mock the connection to the server</li> <li><code>freeze32</code> console script to create a new 32-bit server</li> <li>support for Python 3.12 and 3.13</li> <li>type annotations</li> </ul> <p>Changed:</p> <ul> <li>convert to an implicit namespace package (PEP-420)</li> <li>the <code>requires_pythonnet</code> and <code>requires_comtypes</code> arguments to <code>freeze_server32.main()</code> were removed and the <code>imports</code>, <code>data</code> <code>skip_32bit_check</code>, <code>keep_spec</code> and <code>keep_tk</code> arguments were added</li> <li>all constants (e.g., <code>IS_WINDOWS</code>) were moved to a <code>constants.py</code> file</li> <li>data type of <code>EXAMPLES_DIR</code> and the return type from <code>Server32.examples_dir()</code> changed from str to Path</li> </ul> <p>Removed:</p> <ul> <li>support for Python 2.7, 3.5, 3.6 and 3.7</li> <li>the deprecated <code>quiet</code> parameter</li> </ul>"},{"location":"release-notes/#0100-2023-06-16","title":"0.10.0 (2023-06-16)","text":"<p>This release will be the last to support Python 2.7, 3.5, 3.6 and 3.7</p> <p>The 32-bit server is frozen with the following versions</p> <ul> <li><code>server32-windows.exe</code> \u2013 Python 3.11.4, pythonnet 3.0.1, comtypes 1.2.0</li> <li><code>server32-linux</code> \u2013 Python 3.11.4 (built with GLIBC 2.27)</li> </ul> <p>Added:</p> <ul> <li>can now specify the destination directory when freezing the 32-bit server</li> <li>the <code>server32_dir</code> keyword argument to <code>Client64</code> (fixes issue #35)</li> <li>support for Python 3.10 and 3.11</li> <li><code>LoadLibrary</code> and <code>Client64</code> can now be used as a context manager (with statement)</li> <li><code>LoadLibrary.cleanup()</code> method</li> <li><code>~/.local/share/py4j</code> to the search paths when looking for the <code>py4j&lt;version&gt;.jar</code> file</li> </ul> <p>Changed:</p> <ul> <li><code>utils.is_port_in_use()</code> only checks TCP ports and it uses the <code>ss</code> command instead of <code>netstat</code> on linux</li> <li>the example libraries for FORTRAN now depend on <code>libgfortran5</code> on linux</li> </ul> <p>Fixed:</p> <ul> <li>issue #31 \u2013 suppress console popups when using <code>pythonw.exe</code></li> <li>issue #24 \u2013 starting the 32-bit server could block forever by not honouring the timeout</li> </ul>"},{"location":"release-notes/#090-2021-05-13","title":"0.9.0 (2021-05-13)","text":"<p>The 32-bit server is frozen with the following versions</p> <ul> <li><code>server32-windows.exe</code> \u2013 Python 3.7.10, pythonnet 2.5.2, comtypes 1.1.10</li> <li><code>server32-linux</code> \u2013 Python 3.7.10, pythonnet 2.4.0</li> </ul> <p>Added:</p> <ul> <li>support for loading an ActiveX library</li> <li>the following static methods to <code>Server32</code> \u2013 <code>remove_site_packages_64bit</code>, <code>is_interpreter</code>, <code>examples_dir</code></li> <li>the <code>utils.generate_com_wrapper</code> function</li> </ul> <p>Changed:</p> <ul> <li>the <code>sys.coinit_flags</code> attribute is now set to <code>COINIT_MULTITHREADED</code> (only if this attribute was not already defined prior to importing <code>msl.loadlib</code>)</li> </ul> <p>Fixed:</p> <ul> <li><code>Client64.__del__</code> could have written a warning to stderr indicating that no <code>self._conn</code> attribute existed</li> <li><code>sys:1: ResourceWarning: unclosed file &lt;_io.BufferedReader name=...&gt;</code> warnings could be written to stderr when a <code>Client64</code> object is destroyed</li> <li>issue #23 \u2013 the <code>useLegacyV2RuntimeActivationPolicy</code> property was no longer created</li> </ul>"},{"location":"release-notes/#080-2021-02-20","title":"0.8.0 (2021-02-20)","text":"<p>The 32-bit server is frozen with the following versions</p> <ul> <li><code>server32-windows.exe</code> \u2013 Python 3.7.10, pythonnet 2.5.2 and comtypes 1.1.8</li> <li><code>server32-linux</code> \u2013 Python 3.7.10 and pythonnet 2.4.0</li> </ul> <p>Added:</p> <ul> <li>support for Python 3.9</li> <li>the <code>protocol</code> keyword argument to <code>Client64</code></li> <li>the ability to request non-callable attributes from the 32-bit server class (e.g., methods that use the <code>@property</code> decorator and class/instance variables)</li> </ul> <p>Changed:</p> <ul> <li>call <code>clr.AddReference</code> before <code>clr.System.Reflection.Assembly.LoadFile</code> when loading a .NET library</li> <li>use PIPE's for <code>stdout</code> and <code>stderr</code> for the 32-bit server subprocess and for the py4j <code>GatewayServer</code></li> <li><code>Client64.shutdown_server32</code> now returns the <code>(stdout, stderr)</code> streams from the 32-bit server subprocess</li> <li>the <code>quiet</code> keyword argument for <code>Client64</code> is now deprecated</li> </ul> <p>Fixed:</p> <ul> <li>issue #21 \u2013 an <code>UnsupportedOperation: fileno</code> exception was raised when running within the Spyder IDE</li> </ul> <p>Removed:</p> <ul> <li><code>cygwin</code> from the <code>IS_WINDOWS</code> check</li> </ul>"},{"location":"release-notes/#070-2020-03-17","title":"0.7.0 (2020-03-17)","text":"<p>The 32-bit server is frozen with the following versions</p> <ul> <li><code>server32-windows.exe</code> \u2013 Python 3.7.7, pythonnet 2.4.0 and comtypes 1.1.7</li> <li><code>server32-linux</code> \u2013 Python 3.7.7 and pythonnet 2.4.0</li> </ul> <p>Added:</p> <ul> <li>support for Python 3.8</li> <li>compiled the C++ and FORTRAN examples for 64-bit macOS</li> </ul> <p>Changed:</p> <ul> <li>use <code>__package__</code> as the logger name</li> <li>renamed <code>utils.port_in_use()</code> to <code>utils.is_port_in_use()</code> and added support for checking the status of a port in macOS</li> <li>changes to how a .NET library is loaded: include the System namespace by default, do not automatically create a class instance</li> </ul> <p>Removed:</p> <ul> <li>support for Python 3.4</li> </ul>"},{"location":"release-notes/#060-2019-05-07","title":"0.6.0 (2019-05-07)","text":"<p>The 32-bit server is frozen with the following versions</p> <ul> <li><code>server32-windows.exe</code> \u2013 Python 3.7.3, pythonnet 2.4.0 and comtypes 1.1.7</li> <li><code>server32-linux</code> \u2013 Python 3.7.3 and pythonnet 2.4.0</li> </ul> <p>Added:</p> <ul> <li>a <code>shutdown_handler()</code> method to <code>Server32</code> (PR #19)</li> <li>a section to the docs that explains how to re-freeze the 32-bit server</li> <li>a <code>kill_timeout</code> keyword argument to <code>Client64.shutdown_server32()</code></li> <li>the <code>rpc_timeout</code> keyword argument to <code>Client64</code> (thanks to @fake-name)</li> <li>search <code>HKEY_CLASSES_ROOT\\\\Wow6432Node\\\\CLSID</code> in the Windows Registry for additional COM <code>ProgID</code>'s</li> <li><code>extras_require</code> parameter to <code>setup.py</code> with keys: <code>clr</code>, <code>java</code>, <code>com</code>, <code>all</code></li> </ul> <p>Changed:</p> <ul> <li>rename the optional <code>-asp</code> and <code>-aep</code> command line arguments to be <code>-s</code> and <code>-e</code> respectively</li> <li>the current working directory where the 64-bit Python interpreter was executed from is now automatically appended to <code>os.environ['PATH']</code> on the 32-bit server</li> <li><code>freeze_server32.py</code> uses an <code>ArgumentParser</code> instead of directly reading from <code>sys.argv</code></li> </ul> <p>Fixed:</p> <ul> <li>use <code>sys.executable -m PyInstaller</code> to create the 32-bit server (cherry picked from PR #18)</li> <li>the 32-bit server prints error messages to <code>sys.stderr</code> instead of <code>sys.stdout</code></li> <li>issue #15 \u2013 wait for the subprocess that starts the 32-bit server to terminate and set a value for the <code>returncode</code></li> <li>issue #14 \u2013 use <code>os.kill</code> to stop the 32-bit server if it won't stop after <code>kill_timeout</code> seconds</li> </ul>"},{"location":"release-notes/#050-2019-01-06","title":"0.5.0 (2019-01-06)","text":"<p>The 32-bit server is frozen with the following versions</p> <ul> <li><code>server32-windows.exe</code> \u2013 Python 3.6.8, pythonnet 2.3.0 and comtypes 1.1.7</li> <li><code>server32-linux</code> \u2013 Python 3.6.8 and pythonnet 2.3.0</li> </ul> <p>Added:</p> <ul> <li>support for loading a Component Object Model (COM) library on Windows</li> <li>the <code>requires_pythonnet</code> and <code>requires_comtypes</code> kwargs to <code>freeze_server32.main()</code></li> <li><code>\"clr\"</code> as an alias for <code>\"net\"</code> for the <code>libtype</code> parameter in <code>LoadLibrary</code></li> <li>the <code>utils.get_com_info()</code> function</li> <li>support for unicode paths in Python 2</li> <li>examples for working with numpy arrays and C++ structs</li> </ul> <p>Changed:</p> <ul> <li>if loading a .NET assembly succeeds but calling <code>GetTypes()</code> fails then a detailed error message is logged rather than raising the exception - the value of <code>lib</code> will be <code>None</code></li> <li>the default timeout value when waiting for the 32-bit server to start is now 10 seconds</li> <li>the <code>Client64</code> class now raises <code>Server32Error</code> if the 32-bit server raises an exception</li> <li>the <code>Client64</code> class now inherits from <code>object</code> and the reference to <code>HTTPConnection</code> is now a property value</li> <li>the <code>__repr__</code> methods no longer include the id as a hex number</li> </ul> <p>Fixed:</p> <ul> <li>set <code>sys.stdout = io.StringIO()</code> if <code>quiet=True</code> on the server</li> </ul>"},{"location":"release-notes/#041-2018-08-24","title":"0.4.1 (2018-08-24)","text":"<p>The 32-bit server is frozen with the following versions</p> <ul> <li><code>server32-windows.exe</code> \u2013 Python 3.6.6 and pythonnet 2.3.0</li> <li><code>server32-linux</code> \u2013 Python 3.6.6 and pythonnet 2.3.0</li> </ul> <p>Added:</p> <ul> <li>the <code>version_info</code> namedtuple now includes a releaselevel</li> <li>support for Python 3.7</li> </ul> <p>Fixed:</p> <ul> <li>issue #11</li> <li><code>utils.wait_for_server()</code> raised <code>NameError: name 'TimeoutError' is not defined</code> for Python 2.7</li> <li><code>utils.port_in_use()</code> raised <code>UnicodeDecodeError</code> (PR #9)</li> <li><code>setup.py</code> is now also compatible with Sphinx 1.7+</li> </ul> <p>Changed:</p> <ul> <li>pythonnet is now an optional dependency on Windows and py4j is now optional for all OS</li> <li>rename <code>Dummy</code> example to <code>Echo</code></li> </ul> <p>Removed:</p> <ul> <li>support for Python 3.3</li> </ul>"},{"location":"release-notes/#040-2018-02-28","title":"0.4.0 (2018-02-28)","text":"<p>The 32-bit server is frozen with the following versions</p> <ul> <li><code>server32-windows.exe</code> \u2013 Python 3.6.4 and pythonnet 2.3.0</li> <li><code>server32-linux</code> \u2013 Python 3.6.4 and pythonnet 2.3.0</li> </ul> <p>Added:</p> <ul> <li>Py4J wrapper for loading <code>.jar</code> and <code>.class</code> Java files</li> <li>example on how to load a library that was built with LabVIEW</li> </ul> <p>Fixed:</p> <ul> <li>issue #8</li> <li>issue #7</li> <li><code>AttributeError(\"'LoadLibrary' object has no attribute '_lib'\")</code> could be raised in <code>__repr__</code></li> </ul> <p>Changed:</p> <ul> <li>rename <code>DotNetContainer</code> to <code>DotNet</code></li> <li>use <code>socket.socket.bind</code> to select an available port instead of checking of calling <code>utils.port_in_use</code></li> <li>moved the static methods to the <code>utils</code> module:<ul> <li>Client64.port_in_use \u2192 utils.port_in_use</li> <li>Client64.get_available_port \u2192 utils.get_available_port</li> <li>Client64.wait_for_server \u2192 utils.wait_for_server</li> <li>LoadLibrary.check_dot_net_config \u2192 utils.check_dot_net_config</li> <li>LoadLibrary.is_pythonnet_installed \u2192 utils.is_pythonnet_installed</li> </ul> </li> </ul>"},{"location":"release-notes/#032-2017-10-18","title":"0.3.2 (2017-10-18)","text":"<p>The 32-bit server is frozen with the following versions</p> <ul> <li><code>server32-windows.exe</code> \u2013 Python 3.6.3 and pythonnet 2.3.0</li> <li><code>server32-linux</code> \u2013 Python 3.6.3 and pythonnet 2.3.0</li> </ul> <p>Added:</p> <ul> <li>include <code>os.environ['PATH']</code> as a search path when loading a library</li> <li>support that the package can now be installed by <code>pip install msl-loadlib</code></li> </ul> <p>Fixed:</p> <ul> <li>remove <code>sys.getsitepackages()</code> error for virtualenv (issue #5)</li> <li><code>RecursionError</code> when freezing freeze_server32.py with PyInstaller 3.3</li> <li>replaced <code>FileNotFoundError</code> with <code>IOError</code> (for Python 2.7 support)</li> <li>recompile <code>cpp_lib*.dll</code> and <code>fortran_lib*.dll</code> to not depend on external dependencies</li> </ul>"},{"location":"release-notes/#031-2017-05-15","title":"0.3.1 (2017-05-15)","text":"<ul> <li>fix ReadTheDocs build error \u2013 AttributeError: module 'site' has no attribute 'getsitepackages'</li> <li>strip whitespace from append_sys_path and append_environ_path</li> <li>make pythonnet a required dependency only for Windows</li> </ul>"},{"location":"release-notes/#030-2017-05-09","title":"0.3.0 (2017-05-09)","text":"<p>NOTE: This release breaks backward compatibility</p> <ul> <li>can now pass <code>**kwargs</code> from the <code>Client64</code> constructor to the <code>Server32</code>-subclass constructor</li> <li>new command line arguments for starting the 32-bit server: <code>--kwargs</code>, <code>--append_environ_path</code></li> <li>renamed the <code>--append_path</code> command line argument to <code>--append_sys_path</code></li> <li><code>Server32.interactive_console()</code> works on Windows and Linux</li> <li>edit documentation (thanks to @karna48 for the pull request)</li> </ul>"},{"location":"release-notes/#023-2017-04-11","title":"0.2.3 (2017-04-11)","text":"<ul> <li>the frozen server32 executable (for Windows/Linux) now uses Python v3.6.1 and Python.NET v2.3.0</li> <li>include <code>ctypes.util.find_library</code> and <code>sys.path</code> when searching for a library</li> </ul>"},{"location":"release-notes/#022-2017-03-03","title":"0.2.2 (2017-03-03)","text":"<ul> <li>refreeze server32 executables</li> </ul>"},{"location":"release-notes/#021-2017-03-02","title":"0.2.1 (2017-03-02)","text":"<ul> <li>fix <code>releaselevel</code> bug</li> </ul>"},{"location":"release-notes/#020-2017-03-02","title":"0.2.0 (2017-03-02)","text":"<ul> <li>examples now working in Linux</li> <li>fix MSL namespace</li> <li>include all C# modules, classes and System.Type objects in the .NET loaded-library object</li> <li>create a custom C# library for the examples</li> <li>edit docstrings and documentation</li> <li>many bug fixes</li> </ul>"},{"location":"release-notes/#010-2017-02-15","title":"0.1.0 (2017-02-15)","text":"<ul> <li>Initial release</li> </ul>"},{"location":"api/activex/","title":"activex","text":"<p>Load ActiveX controls in an application window.</p> <p>The following classes are available to interact with ActiveX controls</p> <ul> <li>Application</li> <li>Icon</li> <li>Menu</li> <li>MenuGroup</li> <li>MenuItem</li> </ul> <p>and the following enumerations</p> <ul> <li>Colour</li> <li>ExtendedWindowStyle</li> <li>MenuFlag</li> <li>MessageBoxOption</li> <li>ShowWindow</li> <li>WindowClassStyle</li> <li>WindowPosition</li> <li>WindowStyle</li> </ul>"},{"location":"api/activex/#msl.loadlib.activex.Application","title":"Application","text":"<pre><code>Application(\n    *,\n    background=Colour.WHITE,\n    class_style=WindowClassStyle.NONE,\n    icon=None,\n    style=WindowStyle.OVERLAPPEDWINDOW,\n    title=\"ActiveX\",\n)\n</code></pre> <p>Create the main application window to display ActiveX controls.</p> <p>Parameters:</p> Name Type Description Default <code>background</code> <code>Colour</code> <p>The background colour of the main window.</p> <code>WHITE</code> <code>class_style</code> <code>WindowClassStyle</code> <p>The class style(s). Can be any combination (bitwise OR) of WindowClassStyle values.</p> <code>NONE</code> <code>icon</code> <code>Icon | None</code> <p>The application icon.</p> <code>None</code> <code>style</code> <code>WindowStyle</code> <p>The window style(s). Can be any combination (bitwise OR) of WindowStyle values.</p> <code>OVERLAPPEDWINDOW</code> <code>title</code> <code>str</code> <p>The text to display in the titlebar (if one is visible).</p> <code>'ActiveX'</code> Source code in <code>src/msl/loadlib/activex.py</code> <pre><code>def __init__(\n    self,\n    *,\n    background: Colour = Colour.WHITE,\n    class_style: WindowClassStyle = WindowClassStyle.NONE,\n    icon: Icon | None = None,\n    style: WindowStyle = WindowStyle.OVERLAPPEDWINDOW,\n    title: str = \"ActiveX\",\n) -&gt; None:\n    \"\"\"Create the main application window to display ActiveX controls.\n\n    Args:\n        background: The background colour of the main window.\n        class_style: The class style(s). Can be any combination (bitwise OR)\n            of [WindowClassStyle][msl.loadlib.activex.WindowClassStyle] values.\n        icon: The application icon.\n        style: The window style(s). Can be any combination (bitwise OR)\n            of [WindowStyle][msl.loadlib.activex.WindowStyle] values.\n        title: The text to display in the titlebar (if one is visible).\n    \"\"\"\n    super().__init__()\n    self._atom = None\n    self._icon = icon  # prevent an icon from being garbage collected\n    self._event_connections = []\n    self._msg_handlers: list[Callable[[int, int, int, int], None]] = []\n\n    if WNDCLASSEXW is None:\n        msg = \"An ActiveX application is not supported on this platform\"\n        raise OSError(msg)\n\n    if isinstance(icon, Icon):\n        h_icon = icon.hicon\n    else:\n        h_icon = user32.LoadIconW(None, wt.LPCWSTR(32512))  # IDI_APPLICATION\n\n    self._window = WNDCLASSEXW()\n    self._window.cbSize = ctypes.sizeof(WNDCLASSEXW)\n    self._window.style = class_style\n    self._window.lpfnWndProc = WNDPROC(self._window_procedure)\n    self._window.cbClsExtra = 0\n    self._window.cbWndExtra = 0\n    self._window.hInstance = kernel32.GetModuleHandleW(None)\n    self._window.hIcon = h_icon\n    self._window.hCursor = user32.LoadCursorW(None, wt.LPCWSTR(32512))  # IDC_ARROW\n    self._window.hbrBackground = gdi32.GetStockObject(background)\n    self._window.lpszMenuName = f\"ActiveXMenu{id(self._window)}\"  # make the name unique\n    self._window.lpszClassName = f\"ActiveXClass{id(self._window)}\"\n    self._window.hIconSm = h_icon\n\n    self._atom = user32.RegisterClassExW(self._window)\n\n    self._menu = Menu()\n\n    self._hwnd = _create_window(\n        class_name=self._window.lpszClassName,\n        window_name=title,\n        style=style,\n        instance=self._window.hInstance,\n    )\n\n    self._thread_id = user32.GetWindowThreadProcessId(self._hwnd, None)\n\n    # calling AtlAxWinInit initializes ATL's control hosting code\n    # by registering the \"AtlAxWin\" window class so that this window\n    # class is available to the CreateWindowExW function\n    if not atl.AtlAxWinInit():\n        msg = \"Cannot register the 'AtlAxWin' window class\"\n        raise OSError(msg)\n</code></pre>"},{"location":"api/activex/#msl.loadlib.activex.Application.hwnd","title":"hwnd  <code>property</code>","text":"<pre><code>hwnd\n</code></pre> <p>int \u2014 The handle to the main application window.</p>"},{"location":"api/activex/#msl.loadlib.activex.Application.menu","title":"menu  <code>property</code>","text":"<pre><code>menu\n</code></pre> <p>Menu \u2014 The menu instance.</p>"},{"location":"api/activex/#msl.loadlib.activex.Application.thread_id","title":"thread_id  <code>property</code>","text":"<pre><code>thread_id\n</code></pre> <p>int \u2014 The identifier of the thread that created the main application window.</p>"},{"location":"api/activex/#msl.loadlib.activex.Application.add_message_handler","title":"add_message_handler","text":"<pre><code>add_message_handler(handler)\n</code></pre> <p>Add a custom handler for processing window messages.</p> <p>Messages correspond to events from the user and from the operating system.</p> <p>Parameters:</p> Name Type Description Default <code>handler</code> <code>Callable[[int, int, int, int], None]</code> <p>A function that processes messages sent to the main window. The function must accept four positional arguments (all integer values) and the returned object is ignored. See WindowProc for more details about the input arguments to the <code>handler</code>.</p> required Source code in <code>src/msl/loadlib/activex.py</code> <pre><code>def add_message_handler(self, handler: Callable[[int, int, int, int], None]) -&gt; None:\n    \"\"\"Add a custom handler for processing window messages.\n\n    Messages correspond to events from the user and from the operating system.\n\n    Args:\n        handler: A function that processes messages sent to the main window.\n            The function must accept four positional arguments (all integer values)\n            and the returned object is ignored. See\n            [WindowProc](https://learn.microsoft.com/en-us/windows/win32/learnwin32/writing-the-window-procedure){:target=\"_blank\"}\n            for more details about the input arguments to the `handler`.\n    \"\"\"\n    self._msg_handlers.append(handler)\n</code></pre>"},{"location":"api/activex/#msl.loadlib.activex.Application.close","title":"close","text":"<pre><code>close()\n</code></pre> <p>Close the application.</p> Source code in <code>src/msl/loadlib/activex.py</code> <pre><code>def close(self) -&gt; None:\n    \"\"\"Close the application.\"\"\"\n    user32.PostMessageW(self._hwnd, WM_DESTROY, 0, 0)\n</code></pre>"},{"location":"api/activex/#msl.loadlib.activex.Application.handle_events","title":"handle_events","text":"<pre><code>handle_events(source, sink=None, *, interface=None)\n</code></pre> <p>Handle events from an ActiveX object (see GetEvents).</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>Any</code> <p>An ActiveX object that emits events.</p> required <code>sink</code> <code>Callable[..., Any] | None</code> <p>The object that handles the events. The <code>sink</code> must define methods with the same names as the ActiveX event names. If not specified, the Application instance is used as the <code>sink</code>.</p> <code>None</code> <code>interface</code> <code>Any</code> <p>The COM interface to use.</p> <code>None</code> <p>Returns:</p> Type Description <code>Any</code> <p>An <code>_AdviseConnection</code> object from <code>comtypes</code>.</p> Source code in <code>src/msl/loadlib/activex.py</code> <pre><code>def handle_events(self, source: Any, sink: Callable[..., Any] | None = None, *, interface: Any = None) -&gt; Any:\n    \"\"\"Handle events from an ActiveX object (see [GetEvents][]{:target=\"_blank\"}).\n\n    Args:\n        source: An ActiveX object that emits events.\n        sink: The object that handles the events. The `sink` must\n            define methods with the same names as the ActiveX event names. If not\n            specified, the [Application][msl.loadlib.activex.Application] instance\n            is used as the `sink`.\n        interface: The COM interface to use.\n\n    Returns:\n        An `_AdviseConnection` object from `comtypes`.\n    \"\"\"\n    cxn = client.GetEvents(source, sink or self, interface=interface)\n    self._event_connections.append(cxn)\n    return cxn\n</code></pre>"},{"location":"api/activex/#msl.loadlib.activex.Application.load","title":"load","text":"<pre><code>load(\n    activex_id,\n    *,\n    parent=None,\n    x=0,\n    y=0,\n    width=0,\n    height=0,\n    style=WindowStyle.VISIBLE | WindowStyle.CHILD,\n    ex_style=ExtendedWindowStyle.LEFT,\n)\n</code></pre> <p>Load an ActiveX library.</p> <p>Parameters:</p> Name Type Description Default <code>activex_id</code> <code>str</code> <p>ProgID or CLSID of the ActiveX object.</p> required <code>parent</code> <code>int | None</code> <p>The handle to the parent window that the ActiveX object will belong to. Default is the main application window.</p> <code>None</code> <code>x</code> <code>int</code> <p>Horizontal position of the ActiveX object in the parent window.</p> <code>0</code> <code>y</code> <code>int</code> <p>Vertical position of the ActiveX object in the parent window.</p> <code>0</code> <code>width</code> <code>int</code> <p>Width (in pixels) of the ActiveX object.</p> <code>0</code> <code>height</code> <code>int</code> <p>Height (in pixels) of the ActiveX object.</p> <code>0</code> <code>style</code> <code>WindowStyle</code> <p>Style of the window that is created to contain the ActiveX object. Can be any combination (bitwise OR) of WindowStyle values.</p> <code>VISIBLE | CHILD</code> <code>ex_style</code> <code>ExtendedWindowStyle</code> <p>Extended style of the window that is created to contain the ActiveX object. Can be any combination (bitwise OR) of ExtendedWindowStyle values.</p> <code>LEFT</code> <p>Returns:</p> Type Description <code>Any</code> <p>The interface pointer to the ActiveX library.</p> Source code in <code>src/msl/loadlib/activex.py</code> <pre><code>def load(\n    self,\n    activex_id: str,\n    *,\n    parent: int | None = None,\n    x: int = 0,\n    y: int = 0,\n    width: int = 0,\n    height: int = 0,\n    style: WindowStyle = WindowStyle.VISIBLE | WindowStyle.CHILD,\n    ex_style: ExtendedWindowStyle = ExtendedWindowStyle.LEFT,\n) -&gt; Any:\n    \"\"\"Load an ActiveX library.\n\n    Args:\n        activex_id: ProgID or CLSID of the ActiveX object.\n        parent: The handle to the parent window that the ActiveX object\n            will belong to. Default is the main application window.\n        x: Horizontal position of the ActiveX object in the parent window.\n        y: Vertical position of the ActiveX object in the parent window.\n        width: Width (in pixels) of the ActiveX object.\n        height: Height (in pixels) of the ActiveX object.\n        style: Style of the window that is created to contain the ActiveX\n            object. Can be any combination (bitwise OR) of\n            [WindowStyle][msl.loadlib.activex.WindowStyle] values.\n        ex_style: Extended style of the window that is created to contain\n            the ActiveX object. Can be any combination (bitwise OR) of\n            [ExtendedWindowStyle][msl.loadlib.activex.ExtendedWindowStyle] values.\n\n    Returns:\n        The interface pointer to the ActiveX library.\n    \"\"\"\n    if comtypes is None:\n        msg = \"comtypes must be installed to load an ActiveX library\"\n        raise OSError(msg)\n\n    try:\n        window_name = str(comtypes.GUID.from_progid(activex_id))\n    except (TypeError, OSError):\n        window_name = None\n\n    if not window_name:\n        msg = f\"Cannot find an ActiveX library with ID {activex_id!r}\"\n        raise OSError(msg)\n\n    if parent is None:\n        parent = self._hwnd\n\n    hwnd = _create_window(\n        class_name=\"AtlAxWin\",\n        window_name=window_name,\n        style=style,\n        ex_style=ex_style,\n        x=x,\n        y=y,\n        width=width,\n        height=height,\n        parent=parent,\n        instance=kernel32.GetModuleHandleW(None),\n    )\n\n    unknown = ctypes.POINTER(comtypes.IUnknown)()\n    ret = atl.AtlAxGetControl(hwnd, ctypes.byref(unknown))\n    if ret != 0:\n        msg = f\"AtlAxGetControl {ctypes.WinError()}\"\n        raise OSError(msg)\n    return client.GetBestInterface(unknown)\n</code></pre>"},{"location":"api/activex/#msl.loadlib.activex.Application.message_box","title":"message_box  <code>staticmethod</code>","text":"<pre><code>message_box(\n    *,\n    hwnd=None,\n    language_id=0,\n    options=MessageBoxOption.OK,\n    text=\"\",\n    title=\"\",\n)\n</code></pre> <p>Display a modal dialog box (see MessageBoxExW).</p> <p>Parameters:</p> Name Type Description Default <code>hwnd</code> <code>int | None</code> <p>A handle to the owner window of the message box to be created.</p> <code>None</code> <code>language_id</code> <code>int</code> <p>The language for the text displayed in the message box button(s).</p> <code>0</code> <code>options</code> <code>MessageBoxOption</code> <p>The contents and behaviour of the dialog box. Can be any combination (bitwise OR) of MessageBoxOption values.</p> <code>OK</code> <code>text</code> <code>str</code> <p>The message to be displayed.</p> <code>''</code> <code>title</code> <code>str</code> <p>The dialog box title.</p> <code>''</code> <p>Returns:</p> Type Description <code>int</code> <p>An indication of how the message box was closed.</p> Source code in <code>src/msl/loadlib/activex.py</code> <pre><code>@staticmethod\ndef message_box(\n    *,\n    hwnd: int | None = None,\n    language_id: int = 0,\n    options: MessageBoxOption = MessageBoxOption.OK,\n    text: str = \"\",\n    title: str = \"\",\n) -&gt; int:\n    \"\"\"Display a modal dialog box (see [MessageBoxExW]{:target=\"_blank\"}).\n\n    [MessageBoxExW]: https://learn.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-messageboxexw\n\n    Args:\n        hwnd: A handle to the owner window of the message box to be created.\n        language_id: The language for the text displayed in the message box button(s).\n        options: The contents and behaviour of the dialog box. Can be any combination\n            (bitwise OR) of [MessageBoxOption][msl.loadlib.activex.MessageBoxOption] values.\n        text: The message to be displayed.\n        title: The dialog box title.\n\n    Returns:\n        An indication of how the message box was closed.\n    \"\"\"\n    return user32.MessageBoxExW(hwnd, text, title, options, language_id)\n</code></pre>"},{"location":"api/activex/#msl.loadlib.activex.Application.run","title":"run  <code>staticmethod</code>","text":"<pre><code>run()\n</code></pre> <p>Run the application.</p> <p>This is a blocking call. Create and run the application in a separate thread if you want to execute other code while the application is running.</p> Source code in <code>src/msl/loadlib/activex.py</code> <pre><code>@staticmethod\ndef run() -&gt; None:\n    \"\"\"Run the application.\n\n    This is a blocking call. Create and run the application in a separate\n    thread if you want to execute other code while the application is running.\n    \"\"\"\n    msg = wt.MSG()\n    try:\n        while user32.GetMessageW(msg, None, 0, 0) != 0:\n            user32.TranslateMessage(msg)\n            user32.DispatchMessageW(msg)\n    except KeyboardInterrupt:\n        pass\n</code></pre>"},{"location":"api/activex/#msl.loadlib.activex.Application.set_window_position","title":"set_window_position","text":"<pre><code>set_window_position(\n    x, y, width, height, *, flags=WindowPosition.NONE\n)\n</code></pre> <p>Set the position of the main window.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>int</code> <p>The new position of the left side of the window.</p> required <code>y</code> <code>int</code> <p>The new position of the top of the window.</p> required <code>width</code> <code>int</code> <p>The new width (in pixels) of the window.</p> required <code>height</code> <code>int</code> <p>The new height (in pixels) of the window.</p> required <code>flags</code> <code>WindowPosition</code> <p>The window sizing and positioning flags. Can be any combination (bitwise OR) of WindowPosition values.</p> <code>NONE</code> Source code in <code>src/msl/loadlib/activex.py</code> <pre><code>def set_window_position(\n    self, x: int, y: int, width: int, height: int, *, flags: WindowPosition = WindowPosition.NONE\n) -&gt; None:\n    \"\"\"Set the position of the main window.\n\n    Args:\n        x: The new position of the left side of the window.\n        y: The new position of the top of the window.\n        width: The new width (in pixels) of the window.\n        height: The new height (in pixels) of the window.\n        flags: The window sizing and positioning flags. Can be any combination\n            (bitwise OR) of [WindowPosition][msl.loadlib.activex.WindowPosition] values.\n    \"\"\"\n    user32.SetWindowPos(self._hwnd, None, x, y, width, height, flags)\n</code></pre>"},{"location":"api/activex/#msl.loadlib.activex.Application.set_window_size","title":"set_window_size","text":"<pre><code>set_window_size(width, height)\n</code></pre> <p>Set the size of the main window.</p> <p>Parameters:</p> Name Type Description Default <code>width</code> <code>int</code> <p>The new width (in pixels) of the window.</p> required <code>height</code> <code>int</code> <p>The new height (in pixels) of the window.</p> required Source code in <code>src/msl/loadlib/activex.py</code> <pre><code>def set_window_size(self, width: int, height: int) -&gt; None:\n    \"\"\"Set the size of the main window.\n\n    Args:\n        width: The new width (in pixels) of the window.\n        height: The new height (in pixels) of the window.\n    \"\"\"\n    # SWP_NOMOVE = 0x0002  Retains the current position (ignores X and Y parameters)\n    self.set_window_position(0, 0, width, height, flags=0x0002)\n</code></pre>"},{"location":"api/activex/#msl.loadlib.activex.Application.set_window_title","title":"set_window_title","text":"<pre><code>set_window_title(title)\n</code></pre> <p>Set the text to display in the window's title bar.</p> <p>Parameters:</p> Name Type Description Default <code>title</code> <code>str</code> <p>The title bar text.</p> required Source code in <code>src/msl/loadlib/activex.py</code> <pre><code>def set_window_title(self, title: str) -&gt; None:\n    \"\"\"Set the text to display in the window's title bar.\n\n    Args:\n        title: The title bar text.\n    \"\"\"\n    user32.SetWindowTextW(self._hwnd, title)\n</code></pre>"},{"location":"api/activex/#msl.loadlib.activex.Application.show","title":"show","text":"<pre><code>show(command=ShowWindow.NORMAL)\n</code></pre> <p>Show the main application window.</p> <p>Parameters:</p> Name Type Description Default <code>command</code> <code>ShowWindow</code> <p>Controls how the window is shown.</p> <code>NORMAL</code> Source code in <code>src/msl/loadlib/activex.py</code> <pre><code>def show(self, command: ShowWindow = ShowWindow.NORMAL) -&gt; None:\n    \"\"\"Show the main application window.\n\n    Args:\n        command: Controls how the window is shown.\n    \"\"\"\n    user32.SetMenu(self._hwnd, self._menu.hmenu)\n    user32.ShowWindow(self._hwnd, command)\n    user32.UpdateWindow(self._hwnd)\n</code></pre>"},{"location":"api/activex/#msl.loadlib.activex.Colour","title":"Colour","text":"<p>               Bases: <code>IntEnum</code></p> <p>Background colour.</p> <p>Attributes:</p> Name Type Description <code>WHITE</code> <code>int</code> <p>0</p> <code>LIGHT_GREY</code> <code>int</code> <p>1</p> <code>GREY</code> <code>int</code> <p>2</p> <code>DARK_GREY</code> <code>int</code> <p>3</p> <code>BLACK</code> <code>int</code> <p>4</p>"},{"location":"api/activex/#msl.loadlib.activex.ExtendedWindowStyle","title":"ExtendedWindowStyle","text":"<p>               Bases: <code>IntFlag</code></p> <p>Extended window style flags.</p> <p>Attributes:</p> Name Type Description <code>DLGMODALFRAME</code> <code>int</code> <p>0x00000001</p> <code>NOPARENTNOTIFY</code> <code>int</code> <p>0x00000004</p> <code>TOPMOST</code> <code>int</code> <p>0x00000008</p> <code>ACCEPTFILES</code> <code>int</code> <p>0x00000010</p> <code>TRANSPARENT</code> <code>int</code> <p>0x00000020</p> <code>MDICHILD</code> <code>int</code> <p>0x00000040</p> <code>TOOLWINDOW</code> <code>int</code> <p>0x00000080</p> <code>WINDOWEDGE</code> <code>int</code> <p>0x00000100</p> <code>CLIENTEDGE</code> <code>int</code> <p>0x00000200</p> <code>CONTEXTHELP</code> <code>int</code> <p>0x00000400</p> <code>RIGHT</code> <code>int</code> <p>0x00001000</p> <code>LEFT</code> <code>int</code> <p>0x00000000</p> <code>RTLREADING</code> <code>int</code> <p>0x00002000</p> <code>LTRREADING</code> <code>int</code> <p>0x00000000</p> <code>LEFTSCROLLBAR</code> <code>int</code> <p>0x00004000</p> <code>RIGHTSCROLLBAR</code> <code>int</code> <p>0x00000000</p> <code>CONTROLPARENT</code> <code>int</code> <p>0x00010000</p> <code>STATICEDGE</code> <code>int</code> <p>0x00020000</p> <code>APPWINDOW</code> <code>int</code> <p>0x00040000</p> <code>LAYERED</code> <code>int</code> <p>0x00080000</p> <code>NOINHERITLAYOUT</code> <code>int</code> <p>0x00100000</p> <code>NOREDIRECTIONBITMAP</code> <code>int</code> <p>0x00200000</p> <code>LAYOUTRTL</code> <code>int</code> <p>0x00400000</p> <code>COMPOSITED</code> <code>int</code> <p>0x02000000</p> <code>NOACTIVATE</code> <code>int</code> <p>0x08000000</p> <code>OVERLAPPEDWINDOW</code> <code>int</code> <p>WINDOWEDGE | CLIENTEDGE</p> <code>PALETTEWINDOW</code> <code>int</code> <p>WINDOWEDGE | TOOLWINDOW | TOPMOST</p>"},{"location":"api/activex/#msl.loadlib.activex.Icon","title":"Icon","text":"<pre><code>Icon(file, *, index=0, hinstance=None)\n</code></pre> <p>Extract an icon from an executable file, DLL or icon file.</p> <p>Parameters:</p> Name Type Description Default <code>file</code> <code>str</code> <p>The path to an executable file, DLL or icon file.</p> required <code>index</code> <code>int</code> <p>The zero-based index of the icon to extract.</p> <code>0</code> <code>hinstance</code> <code>int | None</code> <p>Handle to the instance of the calling application.</p> <code>None</code> Source code in <code>src/msl/loadlib/activex.py</code> <pre><code>def __init__(self, file: str, *, index: int = 0, hinstance: int | None = None) -&gt; None:\n    \"\"\"Extract an icon from an executable file, DLL or icon file.\n\n    Args:\n        file: The path to an executable file, DLL or icon file.\n        index: The zero-based index of the icon to extract.\n        hinstance: Handle to the instance of the calling application.\n    \"\"\"\n    self._hicon: int | None = None\n\n    if shell32 is None:\n        msg = \"Loading an icon is not supported on this platform\"\n        raise OSError(msg)\n\n    if index &lt; 0:\n        msg = \"A negative index is not supported\"\n        raise ValueError(msg)\n\n    if hinstance is None:\n        hinstance = kernel32.GetModuleHandleW(None)\n\n    self._file = file\n    self._index = index\n    self._hicon = shell32.ExtractIconW(hinstance, file, index)\n</code></pre>"},{"location":"api/activex/#msl.loadlib.activex.Icon.hicon","title":"hicon  <code>property</code>","text":"<pre><code>hicon\n</code></pre> <p>int | <code>None</code> \u2014 The handle to the icon or <code>None</code> if an icon was not found in the <code>file</code>.</p>"},{"location":"api/activex/#msl.loadlib.activex.Icon.destroy","title":"destroy","text":"<pre><code>destroy()\n</code></pre> <p>Destroys the icon and frees any memory the icon occupied.</p> Source code in <code>src/msl/loadlib/activex.py</code> <pre><code>def destroy(self) -&gt; None:\n    \"\"\"Destroys the icon and frees any memory the icon occupied.\"\"\"\n    if self._hicon is not None and self._hicon &gt; 0:\n        user32.DestroyIcon(self._hicon)\n        self._hicon = None\n</code></pre>"},{"location":"api/activex/#msl.loadlib.activex.Menu","title":"Menu","text":"<pre><code>Menu()\n</code></pre> <p>A menu associated with the main application window.</p> <p>Warning</p> <p>Do not instantiate directly. Use the Application.menu property to access the menu instance.</p> Source code in <code>src/msl/loadlib/activex.py</code> <pre><code>def __init__(self) -&gt; None:\n    \"\"\"A menu associated with the main application window.\n\n    !!! warning\n        Do not instantiate directly. Use the\n        [Application.menu][msl.loadlib.activex.Application.menu]\n        property to access the menu instance.\n    \"\"\"\n    self._id = 0\n    self._items: dict[int, MenuItem] = {}\n    self._hmenu: int = user32.CreateMenu()\n</code></pre>"},{"location":"api/activex/#msl.loadlib.activex.Menu.hmenu","title":"hmenu  <code>property</code>","text":"<pre><code>hmenu\n</code></pre> <p>int \u2014 The handle to the main menu.</p>"},{"location":"api/activex/#msl.loadlib.activex.Menu.append","title":"append","text":"<pre><code>append(\n    hmenu,\n    text,\n    *,\n    callback=None,\n    data=None,\n    flags=MenuFlag.STRING,\n)\n</code></pre> <p>Create a new MenuItem and append it to a popup menu.</p> <p>Parameters:</p> Name Type Description Default <code>hmenu</code> <code>int</code> <p>The handle of a popup menu to append the new menu item to.</p> required <code>text</code> <code>str</code> <p>The content of the new menu item.</p> required <code>callback</code> <code>Callable[[MenuItem], None] | None</code> <p>A callable object that will be called when this menu item is selected. The callable object will receive the MenuItem instance as an argument and the returned object is ignored.</p> <code>None</code> <code>data</code> <code>Any</code> <p>User data associated with the menu item.</p> <code>None</code> <code>flags</code> <code>MenuFlag</code> <p>Controls the appearance and behaviour of the new menu item. Can be any combination (bitwise OR) of MenuFlag values.</p> <code>STRING</code> <p>Returns:</p> Type Description <code>MenuItem</code> <p>The menu item that was appended.</p> Source code in <code>src/msl/loadlib/activex.py</code> <pre><code>def append(\n    self,\n    hmenu: int,\n    text: str,\n    *,\n    callback: Callable[[MenuItem], None] | None = None,\n    data: Any = None,\n    flags: MenuFlag = MenuFlag.STRING,\n) -&gt; MenuItem:\n    \"\"\"Create a new [MenuItem][msl.loadlib.activex.MenuItem] and append it to a popup menu.\n\n    Args:\n        hmenu: The handle of a popup menu to append the new menu item to.\n        text: The content of the new menu item.\n        callback: A callable object that will be called when this menu item is selected.\n            The callable object will receive the [MenuItem][msl.loadlib.activex.MenuItem]\n            instance as an argument and the returned object is ignored.\n        data: User data associated with the menu item.\n        flags: Controls the appearance and behaviour of the new menu item. Can be any\n            combination (bitwise OR) of [MenuFlag][msl.loadlib.activex.MenuFlag] values.\n\n    Returns:\n        The menu item that was appended.\n    \"\"\"\n    self._id += 1\n    user32.AppendMenuW(hmenu, flags, self._id, text)\n    item = MenuItem(hmenu=hmenu, text=text, callback=callback, id=self._id, flags=flags, data=data)\n    self._items[self._id] = item\n    return item\n</code></pre>"},{"location":"api/activex/#msl.loadlib.activex.Menu.append_group","title":"append_group","text":"<pre><code>append_group(hmenu, menu_group)\n</code></pre> <p>Append a group of menu items to a popup menu.</p> <p>Parameters:</p> Name Type Description Default <code>hmenu</code> <code>int</code> <p>The handle of a popup menu to append the group to.</p> required <code>menu_group</code> <code>MenuGroup</code> <p>A group of menu items.</p> required Source code in <code>src/msl/loadlib/activex.py</code> <pre><code>def append_group(self, hmenu: int, menu_group: MenuGroup) -&gt; None:\n    \"\"\"Append a group of menu items to a popup menu.\n\n    Args:\n        hmenu: The handle of a popup menu to append the group to.\n        menu_group: A group of menu items.\n    \"\"\"\n    for item in menu_group:\n        self._id += 1\n        item._hmenu = hmenu\n        item._id = self._id\n        user32.AppendMenuW(hmenu, item.flags, self._id, item.text)\n        self._items[self._id] = item\n</code></pre>"},{"location":"api/activex/#msl.loadlib.activex.Menu.append_separator","title":"append_separator","text":"<pre><code>append_separator(hmenu)\n</code></pre> <p>Append a horizontal dividing line to a popup menu.</p> <p>Parameters:</p> Name Type Description Default <code>hmenu</code> <code>int</code> <p>The handle to a popup menu.</p> required Source code in <code>src/msl/loadlib/activex.py</code> <pre><code>def append_separator(self, hmenu: int) -&gt; None:\n    \"\"\"Append a horizontal dividing line to a popup menu.\n\n    Args:\n        hmenu: The handle to a popup menu.\n    \"\"\"\n    self._id += 1\n    user32.AppendMenuW(hmenu, MenuFlag.SEPARATOR, self._id, None)\n</code></pre>"},{"location":"api/activex/#msl.loadlib.activex.Menu.create","title":"create","text":"<pre><code>create(text)\n</code></pre> <p>Create a new popup menu and append it to the main menu.</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str</code> <p>The text to display for the popup menu.</p> required <p>Returns:</p> Type Description <code>int</code> <p>The handle to the popup menu that was created.</p> Source code in <code>src/msl/loadlib/activex.py</code> <pre><code>def create(self, text: str) -&gt; int:\n    \"\"\"Create a new popup menu and append it to the main menu.\n\n    Args:\n        text: The text to display for the popup menu.\n\n    Returns:\n        The handle to the popup menu that was created.\n    \"\"\"\n    flags = MenuFlag.STRING | MenuFlag.POPUP\n    h: int = user32.CreatePopupMenu()\n    user32.AppendMenuW(self._hmenu, flags, h, text)\n    return h\n</code></pre>"},{"location":"api/activex/#msl.loadlib.activex.MenuFlag","title":"MenuFlag","text":"<p>               Bases: <code>IntFlag</code></p> <p>Menu item flags.</p> <p>Attributes:</p> Name Type Description <code>BITMAP</code> <code>int</code> <p>0x00000004</p> <code>CHECKED</code> <code>int</code> <p>0x00000008</p> <code>DISABLED</code> <code>int</code> <p>0x00000002</p> <code>ENABLED</code> <code>int</code> <p>0x00000000</p> <code>GRAYED</code> <code>int</code> <p>0x00000001</p> <code>MENUBARBREAK</code> <code>int</code> <p>0x00000020</p> <code>MENUBREAK</code> <code>int</code> <p>0x00000040</p> <code>OWNERDRAW</code> <code>int</code> <p>0x00000100</p> <code>POPUP</code> <code>int</code> <p>0x00000010</p> <code>SEPARATOR</code> <code>int</code> <p>0x00000800</p> <code>STRING</code> <code>int</code> <p>0x00000000</p> <code>UNCHECKED</code> <code>int</code> <p>0x00000000</p>"},{"location":"api/activex/#msl.loadlib.activex.MenuGroup","title":"MenuGroup","text":"<pre><code>MenuGroup(name='')\n</code></pre> <p>A group of MenuItems.</p> <p>Only one item in the group may have a check mark to indicate that a particular item is selected.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>A name to associate with the group.</p> <code>''</code> Source code in <code>src/msl/loadlib/activex.py</code> <pre><code>def __init__(self, name: str = \"\") -&gt; None:\n    \"\"\"A group of [MenuItem][msl.loadlib.activex.MenuItem]s.\n\n    Only one item in the group may have a check mark to indicate\n    that a particular item is selected.\n\n    Args:\n        name: A name to associate with the group.\n    \"\"\"\n    self._name = name\n    self._items: list[MenuItem] = []\n</code></pre>"},{"location":"api/activex/#msl.loadlib.activex.MenuGroup.checked","title":"checked  <code>property</code> <code>writable</code>","text":"<pre><code>checked\n</code></pre> <p>MenuItem | <code>None</code> \u2014 The menu item that is currently checked in the group.</p>"},{"location":"api/activex/#msl.loadlib.activex.MenuGroup.name","title":"name  <code>property</code>","text":"<pre><code>name\n</code></pre> <p>str \u2014 The name of the menu group.</p>"},{"location":"api/activex/#msl.loadlib.activex.MenuGroup.append","title":"append","text":"<pre><code>append(\n    text, *, callback=None, data=None, flags=MenuFlag.STRING\n)\n</code></pre> <p>Create a new MenuItem and append it to the group.</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str</code> <p>The content of the new menu item.</p> required <code>callback</code> <code>Callable[[MenuItem], None] | None</code> <p>A callable object that will be called when this menu item is selected. The callable object will receive the MenuItem instance as an argument and the returned object is ignored.</p> <code>None</code> <code>data</code> <code>Any</code> <p>User data associated with the menu item.</p> <code>None</code> <code>flags</code> <code>MenuFlag</code> <p>Controls the appearance and behaviour of the new menu item. Can be any combination (bitwise OR) of MenuFlag values.</p> <code>STRING</code> <p>Returns:</p> Type Description <code>MenuItem</code> <p>The menu item that was appended to the group.</p> Source code in <code>src/msl/loadlib/activex.py</code> <pre><code>def append(\n    self, text: str, *, callback: Callable[[MenuItem], None] | None = None, data: Any = None, flags: MenuFlag = MenuFlag.STRING\n) -&gt; MenuItem:\n    \"\"\"Create a new [MenuItem][msl.loadlib.activex.MenuItem] and append it to the group.\n\n    Args:\n        text: The content of the new menu item.\n        callback: A callable object that will be called when this menu item is selected.\n            The callable object will receive the [MenuItem][msl.loadlib.activex.MenuItem]\n            instance as an argument and the returned object is ignored.\n        data: User data associated with the menu item.\n        flags: Controls the appearance and behaviour of the new menu item. Can be any\n            combination (bitwise OR) of [MenuFlag][msl.loadlib.activex.MenuFlag] values.\n\n    Returns:\n        The menu item that was appended to the group.\n    \"\"\"\n    item = MenuItem(hmenu=-1, text=text, callback=callback, id=-1, flags=flags, data=data)\n    self._items.append(item)\n    return item\n</code></pre>"},{"location":"api/activex/#msl.loadlib.activex.MenuGroup.append_separator","title":"append_separator","text":"<pre><code>append_separator()\n</code></pre> <p>Append a horizontal dividing line to the group.</p> Source code in <code>src/msl/loadlib/activex.py</code> <pre><code>def append_separator(self) -&gt; None:\n    \"\"\"Append a horizontal dividing line to the group.\"\"\"\n    self._items.append(MenuItem(hmenu=-1, text=None, callback=None, id=-1, flags=MenuFlag.SEPARATOR, data=None))\n</code></pre>"},{"location":"api/activex/#msl.loadlib.activex.MenuItem","title":"MenuItem","text":"<pre><code>MenuItem(**kwargs)\n</code></pre> <p>A menu item that belongs to a popup menu.</p> <p>Warning</p> <p>Do not instantiate this class directly. Use MenuGroup.append or Menu.append to create a new menu item.</p> Source code in <code>src/msl/loadlib/activex.py</code> <pre><code>def __init__(self, **kwargs) -&gt; None:\n    \"\"\"A menu item that belongs to a popup menu.\n\n    !!! warning\n        Do not instantiate this class directly. Use\n        [MenuGroup.append][msl.loadlib.activex.MenuGroup.append]\n        or [Menu.append][msl.loadlib.activex.Menu.append]\n        to create a new menu item.\n    \"\"\"\n    self._hmenu: int = kwargs[\"hmenu\"]\n    self._id: int = kwargs[\"id\"]\n    self._text: str = kwargs[\"text\"]\n    self._callback: Callable[[MenuItem], None] | None = kwargs[\"callback\"]\n    self._flags: int = kwargs[\"flags\"]\n    self._checked: bool = False\n    self._data: Any = kwargs[\"data\"]\n</code></pre>"},{"location":"api/activex/#msl.loadlib.activex.MenuItem.callback","title":"callback  <code>property</code>","text":"<pre><code>callback\n</code></pre> <p>Callable | <code>None</code> \u2014 The function to call when the menu item is clicked.</p> <p>The function receives an instance of the MenuItem that was selected as an argument and the return type is <code>None</code>.</p>"},{"location":"api/activex/#msl.loadlib.activex.MenuItem.checked","title":"checked  <code>property</code> <code>writable</code>","text":"<pre><code>checked\n</code></pre> <p>bool \u2014 Whether the menu item's check mark is shown.</p>"},{"location":"api/activex/#msl.loadlib.activex.MenuItem.data","title":"data  <code>property</code> <code>writable</code>","text":"<pre><code>data\n</code></pre> <p>Any \u2014 User-defined data associated with the menu item.</p>"},{"location":"api/activex/#msl.loadlib.activex.MenuItem.flags","title":"flags  <code>property</code>","text":"<pre><code>flags\n</code></pre> <p>int \u2014 The flags that were used to create the menu item.</p>"},{"location":"api/activex/#msl.loadlib.activex.MenuItem.hmenu","title":"hmenu  <code>property</code>","text":"<pre><code>hmenu\n</code></pre> <p>int \u2014 The handle to the popup menu that the menu item belongs to.</p>"},{"location":"api/activex/#msl.loadlib.activex.MenuItem.id","title":"id  <code>property</code>","text":"<pre><code>id\n</code></pre> <p>int \u2014 The identifier of the menu item.</p>"},{"location":"api/activex/#msl.loadlib.activex.MenuItem.text","title":"text  <code>property</code>","text":"<pre><code>text\n</code></pre> <p>str \u2014 The content of the menu item.</p>"},{"location":"api/activex/#msl.loadlib.activex.MessageBoxOption","title":"MessageBoxOption","text":"<p>               Bases: <code>IntFlag</code></p> <p>Message box flags.</p> <p>Attributes:</p> Name Type Description <code>ABORTRETRYIGNORE</code> <code>int</code> <p>0x00000002</p> <code>CANCELTRYCONTINUE</code> <code>int</code> <p>0x00000006</p> <code>HELP</code> <code>int</code> <p>0x00004000</p> <code>OK</code> <code>int</code> <p>0x00000000</p> <code>OKCANCEL</code> <code>int</code> <p>0x00000001</p> <code>RETRYCANCEL</code> <code>int</code> <p>0x00000005</p> <code>YESNO</code> <code>int</code> <p>0x00000004</p> <code>YESNOCANCEL</code> <code>int</code> <p>0x00000003</p> <code>ICONEXCLAMATION</code> <code>int</code> <p>0x00000030</p> <code>ICONWARNING</code> <code>int</code> <p>0x00000030</p> <code>ICONINFORMATION</code> <code>int</code> <p>0x00000040</p> <code>ICONASTERISK</code> <code>int</code> <p>0x00000040</p> <code>ICONQUESTION</code> <code>int</code> <p>0x00000020</p> <code>ICONSTOP</code> <code>int</code> <p>0x00000010</p> <code>ICONERROR</code> <code>int</code> <p>0x00000010</p> <code>ICONHAND</code> <code>int</code> <p>0x00000010</p> <code>DEFBUTTON1</code> <code>int</code> <p>0x00000000</p> <code>DEFBUTTON2</code> <code>int</code> <p>0x00000100</p> <code>DEFBUTTON3</code> <code>int</code> <p>0x00000200</p> <code>DEFBUTTON4</code> <code>int</code> <p>0x00000300</p> <code>APPLMODAL</code> <code>int</code> <p>0x00000000</p> <code>SYSTEMMODAL</code> <code>int</code> <p>0x00001000</p> <code>TASKMODAL</code> <code>int</code> <p>0x00002000</p> <code>DEFAULT_DESKTOP_ONLY</code> <code>int</code> <p>0x00020000</p> <code>RIGHT</code> <code>int</code> <p>0x00080000</p> <code>RTLREADING</code> <code>int</code> <p>0x00100000</p> <code>SETFOREGROUND</code> <code>int</code> <p>0x00010000</p> <code>TOPMOST</code> <code>int</code> <p>0x00040000</p> <code>SERVICE_NOTIFICATION</code> <code>int</code> <p>0x00200000</p>"},{"location":"api/activex/#msl.loadlib.activex.ShowWindow","title":"ShowWindow","text":"<p>               Bases: <code>IntEnum</code></p> <p>Show window options.</p> <p>Attributes:</p> Name Type Description <code>HIDE</code> <code>int</code> <p>0</p> <code>SHOWNORMAL</code> <code>int</code> <p>1</p> <code>NORMAL</code> <code>int</code> <p>1</p> <code>SHOWMINIMIZED</code> <code>int</code> <p>2</p> <code>SHOWMAXIMIZED</code> <code>int</code> <p>3</p> <code>MAXIMIZE</code> <code>int</code> <p>3</p> <code>SHOWNOACTIVATE</code> <code>int</code> <p>4</p> <code>SHOW</code> <code>int</code> <p>5</p> <code>MINIMIZE</code> <code>int</code> <p>6</p> <code>SHOWMINNOACTIVE</code> <code>int</code> <p>7</p> <code>SHOWNA</code> <code>int</code> <p>8</p> <code>RESTORE</code> <code>int</code> <p>9</p> <code>SHOWDEFAULT</code> <code>int</code> <p>10</p> <code>FORCEMINIMIZE</code> <code>int</code> <p>11</p>"},{"location":"api/activex/#msl.loadlib.activex.WindowClassStyle","title":"WindowClassStyle","text":"<p>               Bases: <code>IntFlag</code></p> <p>Window class style flags.</p> <p>Attributes:</p> Name Type Description <code>NONE</code> <code>int</code> <p>0x0000</p> <code>BYTEALIGNCLIENT</code> <code>int</code> <p>0x1000</p> <code>BYTEALIGNWINDOW</code> <code>int</code> <p>0x2000</p> <code>CLASSDC</code> <code>int</code> <p>0x0040</p> <code>DBLCLKS</code> <code>int</code> <p>0x0008</p> <code>DROPSHADOW</code> <code>int</code> <p>0x00020000</p> <code>GLOBALCLASS</code> <code>int</code> <p>0x4000</p> <code>HREDRAW</code> <code>int</code> <p>0x0002</p> <code>NOCLOSE</code> <code>int</code> <p>0x0200</p> <code>OWNDC</code> <code>int</code> <p>0x0020</p> <code>PARENTDC</code> <code>int</code> <p>0x0080</p> <code>SAVEBITS</code> <code>int</code> <p>0x0800</p> <code>VREDRAW</code> <code>int</code> <p>0x0001</p>"},{"location":"api/activex/#msl.loadlib.activex.WindowPosition","title":"WindowPosition","text":"<p>               Bases: <code>IntFlag</code></p> <p>Window position flags.</p> <p>Attributes:</p> Name Type Description <code>NONE</code> <code>int</code> <p>0x0000</p> <code>ASYNCWINDOWPOS</code> <code>int</code> <p>0x4000</p> <code>DEFERERASE</code> <code>int</code> <p>0x2000</p> <code>DRAWFRAME</code> <code>int</code> <p>0x0020</p> <code>FRAMECHANGED</code> <code>int</code> <p>0x0020</p> <code>HIDEWINDOW</code> <code>int</code> <p>0x0080</p> <code>NOACTIVATE</code> <code>int</code> <p>0x0010</p> <code>NOCOPYBITS</code> <code>int</code> <p>0x0100</p> <code>NOMOVE</code> <code>int</code> <p>0x0002</p> <code>NOOWNERZORDER</code> <code>int</code> <p>0x0200</p> <code>NOREDRAW</code> <code>int</code> <p>0x0008</p> <code>NOREPOSITION</code> <code>int</code> <p>0x0200</p> <code>NOSENDCHANGING</code> <code>int</code> <p>0x0400</p> <code>NOSIZE</code> <code>int</code> <p>0x0001</p> <code>NOZORDER</code> <code>int</code> <p>0x0004</p> <code>SHOWWINDOW</code> <code>int</code> <p>0x0040</p>"},{"location":"api/activex/#msl.loadlib.activex.WindowStyle","title":"WindowStyle","text":"<p>               Bases: <code>IntFlag</code></p> <p>Window style flags.</p> <p>Attributes:</p> Name Type Description <code>OVERLAPPED</code> <code>int</code> <p>0x00000000</p> <code>POPUP</code> <code>int</code> <p>0x80000000</p> <code>CHILD</code> <code>int</code> <p>0x40000000</p> <code>MINIMIZE</code> <code>int</code> <p>0x20000000</p> <code>VISIBLE</code> <code>int</code> <p>0x10000000</p> <code>DISABLED</code> <code>int</code> <p>0x08000000</p> <code>CLIPSIBLINGS</code> <code>int</code> <p>0x04000000</p> <code>CLIPCHILDREN</code> <code>int</code> <p>0x02000000</p> <code>MAXIMIZE</code> <code>int</code> <p>0x01000000</p> <code>CAPTION</code> <code>int</code> <p>0x00C00000</p> <code>BORDER</code> <code>int</code> <p>0x00800000</p> <code>DLGFRAME</code> <code>int</code> <p>0x00400000</p> <code>VSCROLL</code> <code>int</code> <p>0x00200000</p> <code>HSCROLL</code> <code>int</code> <p>0x00100000</p> <code>SYSMENU</code> <code>int</code> <p>0x00080000</p> <code>THICKFRAME</code> <code>int</code> <p>0x00040000</p> <code>GROUP</code> <code>int</code> <p>0x00020000</p> <code>TABSTOP</code> <code>int</code> <p>0x00010000</p> <code>MINIMIZEBOX</code> <code>int</code> <p>0x00020000</p> <code>MAXIMIZEBOX</code> <code>int</code> <p>0x00010000</p> <code>TILED</code> <code>int</code> <p>OVERLAPPED</p> <code>ICONIC</code> <code>int</code> <p>MINIMIZE</p> <code>SIZEBOX</code> <code>int</code> <p>THICKFRAME</p> <code>OVERLAPPEDWINDOW</code> <code>int</code> <p>OVERLAPPED | CAPTION | SYSMENU | THICKFRAME | MINIMIZEBOX | MAXIMIZEBOX</p> <code>POPUPWINDOW</code> <code>int</code> <p>POPUP | BORDER | SYSMENU</p> <code>CHILDWINDOW</code> <code>int</code> <p>CHILD</p> <code>TILEDWINDOW</code> <code>int</code> <p>OVERLAPPEDWINDOW</p>"},{"location":"api/client64/","title":"Client64","text":"<p>Base class for communicating with a 32-bit library from 64-bit Python.</p> <p>Server32 is used in combination with Client64 to communicate with a 32-bit library from 64-bit Python.</p>"},{"location":"api/client64/#msl.loadlib.client64.Client64","title":"Client64","text":"<pre><code>Client64(\n    module32,\n    *,\n    add_dll_directory=None,\n    append_environ_path=None,\n    append_sys_path=None,\n    host=\"127.0.0.1\",\n    port=0,\n    protocol=5,\n    rpc_timeout=None,\n    server32_dir=None,\n    timeout=10,\n    **kwargs,\n)\n</code></pre> <p>Base class for communicating with a 32-bit library from 64-bit Python.</p> <p>Starts a 32-bit server, Server32, to host a Python class that is a wrapper around a 32-bit library. Client64 runs within a 64-bit Python interpreter and it sends requests to the server which calls the 32-bit library to execute the request. The server then sends the response back to the client.</p> <p>Parameters:</p> Name Type Description Default <code>module32</code> <code>PathLike</code> <p>The name of, or the path to, a Python module that will be imported by the 32-bit server. The module must contain a class that inherits from Server32.</p> required <code>add_dll_directory</code> <code>PathLike | Iterable[PathLike] | None</code> <p>Add path(s) to the 32-bit server's DLL search path. See os.add_dll_directory for more details. Supported on Windows only.</p> <p>Added in version 1.0</p> <code>None</code> <code>append_environ_path</code> <code>PathLike | Iterable[PathLike] | None</code> <p>Append path(s) to the 32-bit server's os.environ[\"PATH\"] variable. This may be useful if the library that is being loaded requires additional libraries that must be available on <code>PATH</code>.</p> <code>None</code> <code>append_sys_path</code> <code>PathLike | Iterable[PathLike] | None</code> <p>Append path(s) to the 32-bit server's sys.path variable. The value of sys.path from the 64-bit process is automatically included, i.e.,</p> <p><code>path<sub>32</sub> = path<sub>64</sub> + append_sys_path</code></p> <code>None</code> <code>host</code> <code>str | None</code> <p>The hostname (IP address) of the 32-bit server. If <code>None</code> then the connection to the server is mocked.</p> <p>Changed in version 1.0</p> <p>A value of <code>None</code> is allowed.</p> <code>'127.0.0.1'</code> <code>port</code> <code>int</code> <p>The port to open on the 32-bit server. If <code>0</code>, any available port will be used.</p> <code>0</code> <code>protocol</code> <code>int</code> <p>The pickle protocol to use.</p> <p>Added in version 0.8</p> <code>5</code> <code>rpc_timeout</code> <code>float | None</code> <p>The maximum number of seconds to wait for a response from the 32-bit server. The RPC timeout value is used for all requests from the server. If you want different requests to have different timeout values, you will need to implement custom timeout handling for each method on the server. Default is <code>None</code>, which will call socket.getdefaulttimeout to get the timeout value.</p> <p>Added in version 0.6</p> <code>None</code> <code>server32_dir</code> <code>PathLike | None</code> <p>The directory where the 32-bit server is located. Specifying this value may be useful if you created a custom server.</p> <p>Added in version 0.10</p> <code>None</code> <code>timeout</code> <code>float</code> <p>The maximum number of seconds to wait to establish a connection with the 32-bit server.</p> <code>10</code> <code>kwargs</code> <code>Any</code> <p>All additional keyword arguments are passed to the Server32 subclass. The data type of each value is not preserved. It will be of type str at the constructor of the Server32 subclass.</p> <code>{}</code> <p>Raises:</p> Type Description <code>OSError</code> <p>If the 32-bit server cannot be found.</p> <code>ConnectionTimeoutError</code> <p>If the connection to the 32-bit server cannot be established.</p> <p>Note</p> <p>If <code>module32</code> is not located in the current working directory then you must either specify the full path to <code>module32</code> or you can specify the folder where <code>module32</code> is located by passing a value to the <code>append_sys_path</code> parameter. Using the <code>append_sys_path</code> option also allows for any other modules that <code>module32</code> may depend on to also be included in sys.path so that those modules can be imported when <code>module32</code> is imported.</p> Source code in <code>src/msl/loadlib/client64.py</code> <pre><code>def __init__(\n    self,\n    module32: PathLike,\n    *,\n    add_dll_directory: PathLike | Iterable[PathLike] | None = None,\n    append_environ_path: PathLike | Iterable[PathLike] | None = None,\n    append_sys_path: PathLike | Iterable[PathLike] | None = None,\n    host: str | None = \"127.0.0.1\",\n    port: int = 0,\n    protocol: int = 5,\n    rpc_timeout: float | None = None,\n    server32_dir: PathLike | None = None,\n    timeout: float = 10,\n    **kwargs: Any,\n) -&gt; None:\n    \"\"\"Base class for communicating with a 32-bit library from 64-bit Python.\n\n    Starts a 32-bit server, [Server32][], to host a Python class that is a wrapper\n    around a 32-bit library. [Client64][] runs within a 64-bit Python interpreter\n    and it sends requests to the server which calls the 32-bit library to execute\n    the request. The server then sends the response back to the client.\n\n    Args:\n        module32: The name of, or the path to, a Python module that will be imported by the\n            32-bit server. The module must contain a class that inherits from [Server32][].\n\n        add_dll_directory: Add path(s) to the 32-bit server's DLL search path.\n            See [os.add_dll_directory][]{:target=\"_blank\"} for more details.\n            Supported on Windows only.\n\n            !!! note \"Added in version 1.0\"\n\n        append_environ_path: Append path(s) to the 32-bit server's\n            [os.environ[\"PATH\"]][os.environ]{:target=\"_blank\"} variable. This may be useful if\n            the library that is being loaded requires additional libraries that\n            must be available on `PATH`.\n\n        append_sys_path: Append path(s) to the 32-bit server's [sys.path][]{:target=\"_blank\"}\n            variable. The value of [sys.path][]{:target=\"_blank\"} from the 64-bit process is\n            automatically included, i.e.,\n\n            &lt;code&gt;path&lt;sub&gt;32&lt;/sub&gt; = path&lt;sub&gt;64&lt;/sub&gt; + append_sys_path&lt;/code&gt;\n\n        host: The hostname (IP address) of the 32-bit server. If `None` then the\n            connection to the server is [mocked][faq-mock].\n\n            !!! note \"Changed in version 1.0\"\n                A value of `None` is allowed.\n\n        port: The port to open on the 32-bit server. If `0`, any available port will be used.\n\n        protocol: The [pickle protocol][pickle-protocols]{:target=\"_blank\"} to use.\n            !!! note \"Added in version 0.8\"\n\n        rpc_timeout: The maximum number of seconds to wait for a response from the 32-bit server.\n            The [RPC](https://en.wikipedia.org/wiki/Remote_procedure_call){:target=\"_blank\"}\n            timeout value is used for *all* requests from the server. If you want different\n            requests to have different timeout values, you will need to implement custom\n            timeout handling for each method on the server. Default is `None`, which will\n            call [socket.getdefaulttimeout][]{:target=\"_blank\"} to get the timeout value.\n\n            !!! note \"Added in version 0.6\"\n\n        server32_dir: The directory where the 32-bit server is located.\n            Specifying this value may be useful if you created a [custom server][refreeze].\n\n            !!! note \"Added in version 0.10\"\n\n        timeout: The maximum number of seconds to wait to establish a connection\n            with the 32-bit server.\n\n        kwargs: All additional keyword arguments are passed to the [Server32][] subclass.\n            The data type of each value is not preserved. It will be of type [str][]\n            at the constructor of the [Server32][] subclass.\n\n    Raises:\n        OSError: If the 32-bit server cannot be found.\n        ConnectionTimeoutError: If the connection to the 32-bit server cannot be established.\n\n    !!! note\n        If `module32` is not located in the current working directory then you\n        must either specify the full path to `module32` **or** you can\n        specify the folder where `module32` is located by passing a value to the\n        `append_sys_path` parameter. Using the `append_sys_path` option also allows\n        for any other modules that `module32` may depend on to also be included\n        in [sys.path][]{:target=\"_blank\"} so that those modules can be imported when `module32`\n        is imported.\n    \"\"\"\n    self._client: _MockClient | _HTTPClient | None = None\n    if host is None:\n        self._client = _MockClient(\n            os.fsdecode(module32),\n            add_dll_directory=add_dll_directory,\n            append_environ_path=append_environ_path,\n            append_sys_path=append_sys_path,\n            **kwargs,\n        )\n    else:\n        self._client = _HTTPClient(\n            os.fsdecode(module32),\n            add_dll_directory=add_dll_directory,\n            append_environ_path=append_environ_path,\n            append_sys_path=append_sys_path,\n            host=host,\n            port=port,\n            protocol=protocol,\n            rpc_timeout=rpc_timeout,\n            server32_dir=server32_dir,\n            timeout=timeout,\n            **kwargs,\n        )\n</code></pre>"},{"location":"api/client64/#msl.loadlib.client64.Client64.connection","title":"connection  <code>property</code>","text":"<pre><code>connection\n</code></pre> <p>HTTPConnection | <code>None</code> \u2014 The connection to the 32-bit server.</p> <p>The value is <code>None</code> for a mocked connection.</p>"},{"location":"api/client64/#msl.loadlib.client64.Client64.host","title":"host  <code>property</code>","text":"<pre><code>host\n</code></pre> <p>str | <code>None</code> \u2014 The host address of the 32-bit server.</p> <p>The value is <code>None</code> for a mocked connection.</p>"},{"location":"api/client64/#msl.loadlib.client64.Client64.lib32_path","title":"lib32_path  <code>property</code>","text":"<pre><code>lib32_path\n</code></pre> <p>str \u2014 The path to the 32-bit library file.</p>"},{"location":"api/client64/#msl.loadlib.client64.Client64.port","title":"port  <code>property</code>","text":"<pre><code>port\n</code></pre> <p>int \u2014 The port number of the 32-bit server.</p>"},{"location":"api/client64/#msl.loadlib.client64.Client64.request32","title":"request32","text":"<pre><code>request32(name, *args, **kwargs)\n</code></pre> <p>Send a request to the 32-bit server.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of a method, property or attribute of the Server32 subclass.</p> required <code>args</code> <code>Any</code> <p>The arguments that the method of the Server32 subclass requires.</p> <code>()</code> <code>kwargs</code> <code>Any</code> <p>The keyword arguments that the method of the Server32 subclass requires.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Any</code> <p>Whatever is returned by calling <code>name</code>.</p> <p>Raises:</p> Type Description <code>Server32Error</code> <p>If there was an error processing the request on the 32-bit server.</p> <code>ResponseTimeoutError</code> <p>If a timeout occurs while waiting for the response from the 32-bit server.</p> Source code in <code>src/msl/loadlib/client64.py</code> <pre><code>def request32(self, name: str, *args: Any, **kwargs: Any) -&gt; Any:\n    \"\"\"Send a request to the 32-bit server.\n\n    Args:\n        name: The name of a method, property or attribute of the [Server32][] subclass.\n        args: The arguments that the method of the [Server32][] subclass requires.\n        kwargs: The keyword arguments that the method of the [Server32][] subclass requires.\n\n    Returns:\n        Whatever is returned by calling `name`.\n\n    Raises:\n        Server32Error: If there was an error processing the request on the 32-bit server.\n        ResponseTimeoutError: If a timeout occurs while waiting for the response from the 32-bit server.\n    \"\"\"\n    return self._client.request32(name, *args, **kwargs)\n</code></pre>"},{"location":"api/client64/#msl.loadlib.client64.Client64.shutdown_server32","title":"shutdown_server32","text":"<pre><code>shutdown_server32(kill_timeout=10)\n</code></pre> <p>Shut down the 32-bit server.</p> <p>This method shuts down the 32-bit server, closes the client connection, and deletes the temporary file that was used to store the serialized pickled data.</p> <p>Parameters:</p> Name Type Description Default <code>kill_timeout</code> <code>float</code> <p>If the 32-bit server is still running after <code>kill_timeout</code> seconds, the server will be killed using brute force. A warning will be issued if the server is killed in this manner.</p> <p>Added in version 0.6</p> <code>10</code> <p>Returns:</p> Type Description <code>tuple[BinaryIO, BinaryIO]</code> <p>The <code>(stdout, stderr)</code> streams from the 32-bit server.</p> <p>Limit the total number of characters that are written to either <code>stdout</code> or <code>stderr</code> on the 32-bit server to be &lt; 4096. This will avoid potential blocking when reading the <code>stdout</code> and <code>stderr</code> PIPE buffers.</p> <p>Changed in version 0.8</p> <p>Prior to version 0.8 this method returned <code>None</code></p> <p>Tip</p> <p>This method gets called automatically when the reference count to the Client64 instance reaches zero (see <code>object.__del__</code>).</p> Source code in <code>src/msl/loadlib/client64.py</code> <pre><code>def shutdown_server32(self, kill_timeout: float = 10) -&gt; tuple[BinaryIO, BinaryIO]:\n    \"\"\"Shut down the 32-bit server.\n\n    This method shuts down the 32-bit server, closes the client connection, and deletes\n    the temporary file that was used to store the serialized [pickle][]{:target=\"_blank\"}d data.\n\n    Args:\n        kill_timeout: If the 32-bit server is still running after `kill_timeout`\n            seconds, the server will be killed using brute force. A warning will be\n            issued if the server is killed in this manner.\n\n            !!! note \"Added in version 0.6\"\n\n    Returns:\n        The `(stdout, stderr)` streams from the 32-bit server.\n\n            Limit the total number of characters that are written to either `stdout`\n            or `stderr` on the 32-bit server to be &amp;lt; 4096. This will avoid potential\n            blocking when reading the `stdout` and `stderr` PIPE buffers.\n\n            !!! note \"Changed in version 0.8\"\n                Prior to version 0.8 this method returned `None`\n\n    !!! tip\n        This method gets called automatically when the reference count to the\n        [Client64][] instance reaches zero (see [`object.__del__`][]{:target=\"_blank\"}).\n    \"\"\"\n    return self._client.shutdown_server32(kill_timeout=kill_timeout)\n</code></pre>"},{"location":"api/exceptions/","title":"exceptions","text":"<p>Exception classes.</p>"},{"location":"api/exceptions/#msl.loadlib.exceptions.ConnectionTimeoutError","title":"ConnectionTimeoutError","text":"<pre><code>ConnectionTimeoutError(message)\n</code></pre> <p>               Bases: <code>OSError</code></p> <p>Raised when the connection to the 32-bit server cannot be established.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>str</code> <p>The error message.</p> required Source code in <code>src/msl/loadlib/exceptions.py</code> <pre><code>def __init__(self, message: str) -&gt; None:\n    \"\"\"Raised when the connection to the 32-bit server cannot be established.\n\n    Args:\n        message: The error message.\n    \"\"\"\n    super().__init__(message)\n    self.timeout_message: str = message\n    self.reason: str = \"\"\n</code></pre>"},{"location":"api/exceptions/#msl.loadlib.exceptions.ResponseTimeoutError","title":"ResponseTimeoutError","text":"<p>               Bases: <code>OSError</code></p> <p>Raised when a timeout occurs while waiting for a response from the 32-bit server.</p> <p>Added in version 0.6</p>"},{"location":"api/exceptions/#msl.loadlib.exceptions.Server32Error","title":"Server32Error","text":"<pre><code>Server32Error(value, *, name='', traceback='')\n</code></pre> <p>               Bases: <code>HTTPException</code></p> <p>Raised when an exception occurs on the 32-bit server.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>str</code> <p>The error message.</p> required <code>name</code> <code>str</code> <p>The name of the exception type.</p> <code>''</code> <code>traceback</code> <code>str</code> <p>The exception traceback from the server.</p> <code>''</code> <p>Added in version 0.5</p> Source code in <code>src/msl/loadlib/exceptions.py</code> <pre><code>def __init__(self, value: str, *, name: str = \"\", traceback: str = \"\") -&gt; None:\n    \"\"\"Raised when an exception occurs on the 32-bit server.\n\n    Args:\n        value: The error message.\n        name: The name of the exception type.\n        traceback: The exception traceback from the server.\n\n    !!! note \"Added in version 0.5\"\n    \"\"\"\n    super().__init__(f\"\\n{traceback}\\n{name}: {value}\" if name else value)\n    self._value: str = value\n    self._name: str = name\n    self._traceback: str = traceback\n</code></pre>"},{"location":"api/exceptions/#msl.loadlib.exceptions.Server32Error.name","title":"name  <code>property</code>","text":"<pre><code>name\n</code></pre> <p>str \u2014 The name of the exception type.</p>"},{"location":"api/exceptions/#msl.loadlib.exceptions.Server32Error.traceback","title":"traceback  <code>property</code>","text":"<pre><code>traceback\n</code></pre> <p>str \u2014 The exception traceback from the server.</p>"},{"location":"api/exceptions/#msl.loadlib.exceptions.Server32Error.value","title":"value  <code>property</code>","text":"<pre><code>value\n</code></pre> <p>str \u2014 The error message.</p>"},{"location":"api/freeze_server32/","title":"freeze_server32","text":"<p>Create a 32-bit server for inter-process communication.</p> <p>Example: <pre><code>from msl.loadlib import freeze_server32\nfreeze_server32.main(imports=\"numpy\")\n</code></pre></p> <p>Note</p> <p>There is also a command-line utility to create a new server.</p>"},{"location":"api/freeze_server32/#msl.loadlib.freeze_server32.main","title":"main","text":"<pre><code>main(\n    *,\n    data=None,\n    dest=None,\n    imports=None,\n    keep_spec=False,\n    keep_tk=False,\n    skip_32bit_check=False,\n    spec=None,\n)\n</code></pre> <p>Create a frozen server.</p> <p>This function should be run using a 32-bit Python interpreter with PyInstaller installed.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>str | Iterable[str] | None</code> <p>The path(s) to additional data files, or directories containing data files, to be added to the frozen server. Each value should be in the form <code>source:dest_dir</code>, where <code>:dest_dir</code> is optional. <code>source</code> is the path to a file (or a directory of files) to add. <code>dest_dir</code> is an optional destination directory, relative to the top-level directory of the frozen server, to add the file(s) to. If <code>dest_dir</code> is not specified, the file(s) will be added to the top-level directory of the server.</p> <code>None</code> <code>dest</code> <code>str | None</code> <p>The destination directory to save the server to. Default is the current working directory.</p> <code>None</code> <code>imports</code> <code>str | Iterable[str] | None</code> <p>The names of additional modules and packages that must be importable on the server.</p> <code>None</code> <code>keep_spec</code> <code>bool</code> <p>By default, the <code>.spec</code> file that is created (during the freezing process) is deleted. Setting this value to <code>True</code> will keep the <code>.spec</code> file, so that it may be modified and then passed as the value to the <code>spec</code> parameter.</p> <code>False</code> <code>keep_tk</code> <code>bool</code> <p>By default, the tkinter package is excluded from the server. Setting this value to <code>True</code> will bundle <code>tkinter</code> with the server.</p> <code>False</code> <code>skip_32bit_check</code> <code>bool</code> <p>In the rare situation that you want to create a frozen 64-bit server, you can set this value to <code>True</code> which skips the requirement that a 32-bit version of Python must be used to create the server. Before you create a 64-bit server, decide if mocking the connection is a better solution for your application.</p> <code>False</code> <code>spec</code> <code>str | None</code> <p>The path to a spec file to use to create the frozen server.</p> <p>Attention</p> <p>If a value for <code>spec</code> is specified, then <code>imports</code> and <code>data</code> are ignored.</p> <code>None</code> Source code in <code>src/msl/loadlib/freeze_server32.py</code> <pre><code>def main(\n    *,\n    data: str | Iterable[str] | None = None,\n    dest: str | None = None,\n    imports: str | Iterable[str] | None = None,\n    keep_spec: bool = False,\n    keep_tk: bool = False,\n    skip_32bit_check: bool = False,\n    spec: str | None = None,\n) -&gt; None:\n    \"\"\"Create a frozen server.\n\n    This function should be run using a 32-bit Python interpreter with\n    [PyInstaller](https://www.pyinstaller.org/){:target=\"_blank\"} installed.\n\n    Args:\n        data: The path(s) to additional data files, or directories containing\n            data files, to be added to the frozen server. Each value should be in\n            the form `source:dest_dir`, where `:dest_dir` is optional. `source` is\n            the path to a file (or a directory of files) to add. `dest_dir` is an\n            optional destination directory, relative to the top-level directory of\n            the frozen server, to add the file(s) to. If `dest_dir` is not specified,\n            the file(s) will be added to the top-level directory of the server.\n        dest: The destination directory to save the server to. Default is\n            the current working directory.\n        imports: The names of additional modules and packages that must be\n            importable on the server.\n        keep_spec: By default, the `.spec` file that is created (during the freezing\n            process) is deleted. Setting this value to `True` will keep the `.spec` file,\n            so that it may be modified and then passed as the value to the `spec` parameter.\n        keep_tk: By default, the [tkinter][]{:target=\"_blank\"} package is excluded from the\n            server. Setting this value to `True` will bundle `tkinter` with the server.\n        skip_32bit_check: In the rare situation that you want to create a\n            frozen 64-bit server, you can set this value to `True` which skips\n            the requirement that a 32-bit version of Python must be used to create\n            the server. Before you create a 64-bit server, decide if\n            [mocking][faq-mock] the connection is a better solution for your\n            application.\n        spec: The path to a [spec]{:target=\"_blank\"} file to use to create the frozen server.\n            [spec]: https://pyinstaller.org/en/stable/spec-files.html#using-spec-files\n\n            !!! attention\n                If a value for `spec` is specified, then `imports` and `data` are ignored.\n    \"\"\"\n    if not skip_32bit_check and constants.IS_PYTHON_64BIT:\n        msg = \"\"\n        if sys.argv:\n            if sys.argv[0].endswith(\"freeze32\"):\n                msg = (\n                    \"\\nIf you want to create a 64-bit server, you may \"\n                    \"include the\\n--skip-32bit-check flag \"\n                    \"to ignore this requirement.\"\n                )\n            else:\n                msg = (\n                    \"\\nIf you want to create a 64-bit server, you may \"\n                    \"set the argument\\nskip_32bit_check=True \"\n                    \"to ignore this requirement.\"\n                )\n        print(f\"Must freeze the server using a 32-bit version of Python.{msg}\", file=sys.stderr)\n        return\n\n    try:\n        from PyInstaller import __version__ as pyinstaller_version  # noqa: PyInstaller is not a dependency\n    except ImportError:\n        print(\"PyInstaller must be installed to create the server, run:\\npip install pyinstaller\", file=sys.stderr)\n        return\n\n    if spec and (imports or data):\n        print(\"Cannot specify a spec file and imports/data\", file=sys.stderr)\n        return\n\n    here = os.path.abspath(os.path.dirname(__file__))\n\n    if dest is not None:\n        dist_path = os.path.abspath(dest)\n    else:\n        dist_path = os.getcwd()\n\n    tmp_kw = {\"ignore_cleanup_errors\": True} if sys.version_info[:2] &gt;= (3, 10) else {}\n    tmp_dir = TemporaryDirectory(**tmp_kw)\n    work_path = tmp_dir.name\n    server_path = os.path.join(dist_path, constants.SERVER_FILENAME)\n\n    # Specifically invoke pyinstaller in the context of the current python interpreter.\n    # This fixes the issue where the blind `pyinstaller` invocation points to a 64-bit version.\n    cmd = [\n        sys.executable,\n        \"-m\",\n        \"PyInstaller\",\n        \"--distpath\",\n        dist_path,\n        \"--workpath\",\n        work_path,\n        \"--noconfirm\",\n        \"--clean\",\n    ]\n\n    if spec is None:\n        cmd.extend([\"--specpath\", work_path, \"--python-option\", \"u\"])\n\n        if constants.IS_WINDOWS:\n            cmd.extend([\"--version-file\", _create_version_info_file(work_path)])\n\n        cmd.extend(\n            [\n                \"--name\",\n                constants.SERVER_FILENAME,\n                \"--onefile\",\n            ]\n        )\n\n        if imports:\n            if isinstance(imports, str):\n                imports = [imports]\n\n            sys.path.append(os.getcwd())\n\n            missing = []\n            for module in imports:\n                try:\n                    import_module(module)\n                except ImportError:\n                    missing.append(module)\n                else:\n                    cmd.extend([\"--hidden-import\", module])\n\n            if missing:\n                print(\n                    f\"The following modules cannot be imported: {' '.join(missing)}\\nCannot freeze the server\",\n                    file=sys.stderr,\n                )\n                return\n\n        cmd.extend(_get_standard_modules(keep_tk))\n\n        if data:\n            major, *rest = pyinstaller_version.split(\".\")\n            sep = os.pathsep if int(major) &lt; 6 else \":\"\n\n            if isinstance(data, str):\n                data = [data]\n\n            for item in data:\n                s = item.split(\":\")\n                if len(s) == 1:\n                    src = s[0]\n                    dst = \"\"\n                elif len(s) == 2:\n                    src = s[0]\n                    dst = s[1] or \".\"\n                else:\n                    print(f\"Invalid data format {item!r}\", file=sys.stderr)\n                    return\n\n                src = os.path.abspath(src)\n                if not os.path.exists(src):\n                    print(f\"Cannot find {src!r}\", file=sys.stderr)\n                    return\n\n                cmd.extend([\"--add-data\", f\"{src}{sep}{dst}\"])\n\n        cmd.append(os.path.join(here, \"start_server32.py\"))\n    else:\n        cmd.append(spec)\n\n    check_call(cmd)\n\n    # maybe create the .NET Framework config file\n    if imports and (\"pythonnet\" in imports):\n        loadlib.utils.check_dot_net_config(server_path)\n\n    if keep_spec:\n        print(f\"The following files were saved to {dist_path}\\n  {constants.SERVER_FILENAME}\")\n\n        if os.path.isfile(f\"{server_path}.config\"):\n            print(f\"  {os.path.basename(server_path)}.config\")\n\n        spec_file = \"server32.spec\"\n        copy(os.path.join(work_path, f\"{constants.SERVER_FILENAME}.spec\"), os.path.join(dist_path, spec_file))\n        print(f\"  {spec_file}\")\n\n        if constants.IS_WINDOWS:\n            file_version_info = \"file_version_info.txt\"\n            copy(os.path.join(work_path, file_version_info), dist_path)\n            print(f\"  {file_version_info}  (required by the {spec_file} file)\")\n    else:\n        print(f\"Server saved to {server_path}\")\n</code></pre>"},{"location":"api/load_library/","title":"LoadLibrary","text":"<p>Load a library.</p>"},{"location":"api/load_library/#msl.loadlib.load_library.LoadLibrary","title":"LoadLibrary","text":"<pre><code>LoadLibrary(path, libtype=None, **kwargs)\n</code></pre> <p>Load a library.</p> <p>For example, a C/C++, FORTRAN, .NET, Java, Delphi, LabVIEW, ActiveX, ... library.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>PathLike</code> <p>The path to the library. The search order to find the library is:</p> <ol> <li>assume that a full or a relative (to the current working directory) path is specified</li> <li>use ctypes.util.find_library</li> <li>search sys.path</li> <li>search os.environ[\"PATH\"].</li> </ol> <p>If loading a COM library, <code>path</code> may either be the</p> <ul> <li>ProgID (e.g, <code>\"InternetExplorer.Application\"</code>), or the</li> <li>CLSID (e.g., <code>\"{2F7860A2-1473-4D75-827D-6C4E27600CAC}\"</code>).</li> </ul> required <code>libtype</code> <code>LibType | None</code> <p>The library type. The following values are supported:</p> <ul> <li><code>cdll</code>: a library that uses the <code>__cdecl</code> calling convention     (default value if not specified and not a Java library)</li> <li><code>windll</code> or <code>oledll</code>: a library that uses the <code>__stdcall</code> calling convention</li> <li><code>net</code> or <code>clr</code>: a .NET library (Common Language Runtime)</li> <li><code>java</code>: a Java archive (<code>.jar</code> or <code>.class</code> files)</li> <li><code>com</code>: a COM library</li> <li><code>activex</code>: an ActiveX library</li> </ul> <p>Tip</p> <p>Since the <code>.jar</code> or <code>.class</code> extension uniquely defines a Java library, <code>libtype</code> will automatically be set to <code>java</code> if <code>path</code> ends with <code>.jar</code> or <code>.class</code>.</p> <p>Support for library types were added in the following <code>msl-loadlib</code> versions</p> <ul> <li>0.1: __cdecl, __stdcall, .NET</li> <li>0.4: Java</li> <li>0.5: COM</li> <li>0.9: ActiveX</li> </ul> <code>None</code> <code>kwargs</code> <code>Any</code> <p>All additional keyword arguments are passed to the object that loads the library. If <code>libtype</code> is</p> <ul> <li><code>cdll</code> \u2192 ctypes.CDLL</li> <li><code>windll</code> \u2192 ctypes.WinDLL</li> <li><code>oledll</code> \u2192 ctypes.OleDLL</li> <li><code>net</code> or <code>clr</code> \u2192 all keyword arguments are ignored</li> <li><code>java</code> \u2192 JavaGateway</li> <li><code>com</code> \u2192 comtypes.CreateObject</li> <li><code>activex</code> \u2192 Application.load</li> </ul> <code>{}</code> <p>Raises:</p> Type Description <code>OSError</code> <p>If the library cannot be loaded.</p> <code>ValueError</code> <p>If the value of <code>libtype</code> is not supported.</p> Source code in <code>src/msl/loadlib/load_library.py</code> <pre><code>def __init__(self, path: PathLike, libtype: LibType | None = None, **kwargs: Any) -&gt; None:\n    \"\"\"Load a library.\n\n    For example, a C/C++, FORTRAN, .NET, Java, Delphi, LabVIEW, ActiveX, ... library.\n\n    Args:\n        path: The path to the library.\n            The search order to find the library is:\n\n            1. assume that a full or a relative (to the current working directory) path is specified\n            2. use [ctypes.util.find_library][]{:target=\"_blank\"}\n            3. search [sys.path][]{:target=\"_blank\"}\n            4. search [os.environ[\"PATH\"]][os.environ]{:target=\"_blank\"}.\n\n            If loading a [COM](https://learn.microsoft.com/en-us/windows/win32/com/component-object-model--com--portal){:target=\"_blank\"} library,\n            `path` may either be the\n\n            * ProgID (e.g, `\"InternetExplorer.Application\"`), or the\n            * CLSID (e.g., `\"{2F7860A2-1473-4D75-827D-6C4E27600CAC}\"`).\n\n        libtype: The library type.\n            The following values are supported:\n\n            * `cdll`: a library that uses the `__cdecl` calling convention\n                (default value if not specified and not a Java library)\n            * `windll` or `oledll`: a library that uses the `__stdcall` calling convention\n            * `net` or `clr`: a .NET library (Common Language Runtime)\n            * `java`: a Java archive (`.jar` or `.class` files)\n            * `com`: a [COM]{:target=\"_blank\"} library\n            * `activex`: an [ActiveX]{:target=\"_blank\"} library\n\n            [COM]: https://learn.microsoft.com/en-us/windows/win32/com/component-object-model--com--portal\n            [ActiveX]: https://learn.microsoft.com/en-us/windows/win32/com/activex-controls\n\n            !!! tip\n                Since the `.jar` or `.class` extension uniquely defines a Java library,\n                `libtype` will automatically be set to `java` if `path` ends with\n                `.jar` or `.class`.\n\n            !!! note \"Support for library types were added in the following `msl-loadlib` versions\"\n                * 0.1: __cdecl, __stdcall, .NET\n                * 0.4: Java\n                * 0.5: COM\n                * 0.9: ActiveX\n\n        kwargs: All additional keyword arguments are passed to the object that loads the library.\n            If `libtype` is\n\n            * `cdll` &amp;#8594; [ctypes.CDLL][]{:target=\"_blank\"}\n            * `windll` &amp;#8594; [ctypes.WinDLL][]{:target=\"_blank\"}\n            * `oledll` &amp;#8594; [ctypes.OleDLL][]{:target=\"_blank\"}\n            * `net` or `clr` &amp;#8594; all keyword arguments are ignored\n            * `java` &amp;#8594; [JavaGateway][py4j.java_gateway.JavaGateway]{:target=\"_blank\"}\n            * `com` &amp;#8594; [comtypes.CreateObject][CreateObject]{:target=\"_blank\"}\n            * `activex` &amp;#8594; [Application.load][msl.loadlib.activex.Application.load]\n\n    Raises:\n        OSError: If the library cannot be loaded.\n        ValueError: If the value of `libtype` is not supported.\n    \"\"\"\n    # a reference to the ActiveX application\n    self._app = None\n\n    # a reference to the library\n    self._lib = None\n\n    # a reference to the .NET Runtime Assembly\n    self._assembly = None\n\n    # a reference to the Py4J JavaGateway\n    self._gateway = None\n\n    if not path:\n        msg = f\"Must specify a non-empty path, got {path!r}\"\n        raise ValueError(msg)\n\n    # fixes Issue #8, if `path` is a &lt;class 'pathlib.Path'&gt; object\n    path = os.fsdecode(path)\n\n    if libtype is None:\n        # automatically determine the libtype\n        if path.endswith(\".jar\") or path.endswith(\".class\"):\n            libtype = \"java\"\n        else:\n            libtype = \"cdll\"\n    else:\n        libtype = libtype.lower()\n\n    if libtype not in _LIBTYPES:\n        msg = f\"Invalid libtype {libtype!r}\\nMust be one of: {', '.join(_LIBTYPES)}\"\n        raise ValueError(msg)\n\n    # create a new reference to `path` just in case the\n    # DEFAULT_EXTENSION is appended below so that the\n    # ctypes.util.find_library function call will use the\n    # unmodified value of `path`\n    _path = path\n\n    # assume a default extension if no extension was provided\n    ext = os.path.splitext(path)[1]\n    if not ext and libtype not in [\"java\", \"com\", \"activex\"]:\n        _path += DEFAULT_EXTENSION\n\n    if libtype not in [\"com\", \"activex\"]:\n        self._path = os.path.abspath(_path)\n        if not os.path.isfile(self._path):\n            # for find_library use the original 'path' value since it may be a library name\n            # without any prefix like 'lib', suffix like '.so', '.dylib' or version number\n            self._path = ctypes.util.find_library(path)\n            if self._path is None:  # then search sys.path and os.environ['PATH']\n                success = False\n                search_dirs = sys.path + os.environ[\"PATH\"].split(os.pathsep)\n                for directory in search_dirs:\n                    p = os.path.join(directory, _path)\n                    if os.path.isfile(p):\n                        self._path = p\n                        success = True\n                        break\n                if not success:\n                    msg = f\"Cannot find {path!r} for libtype={libtype!r}\"\n                    raise OSError(msg)\n    else:\n        self._path = _path\n\n    if libtype == \"cdll\":\n        self._lib = ctypes.CDLL(self._path, **kwargs)\n    elif libtype == \"windll\":\n        self._lib = ctypes.WinDLL(self._path, **kwargs)\n    elif libtype == \"oledll\":\n        self._lib = ctypes.OleDLL(self._path, **kwargs)\n    elif libtype == \"com\":\n        if not utils.is_comtypes_installed():\n            msg = \"Cannot load a COM library because comtypes is not installed.\\nRun: pip install comtypes\"\n            raise OSError(msg)\n\n        from comtypes import GUID\n        from comtypes.client import CreateObject\n\n        try:\n            clsid = GUID.from_progid(self._path)\n        except (TypeError, OSError):\n            clsid = None\n\n        if clsid is None:\n            msg = f\"Cannot find {path!r} for libtype='com'\"\n            raise OSError(msg)\n\n        self._lib = CreateObject(clsid, **kwargs)\n\n    elif libtype == \"activex\":\n        from .activex import Application\n\n        self._app = Application()\n        self._lib = self._app.load(self._path, **kwargs)\n\n    elif libtype == \"java\":\n        if not utils.is_py4j_installed():\n            msg = \"Cannot load a Java file because Py4J is not installed.\\nRun: pip install py4j\"\n            raise OSError(msg)\n\n        from py4j.version import __version__\n        from py4j.java_gateway import JavaGateway, GatewayParameters\n\n        # the address and port to use to host the py4j.GatewayServer\n        address = kwargs.pop(\"address\", \"127.0.0.1\")\n        port = kwargs.pop(\"port\", utils.get_available_port())\n\n        # find the py4j*.jar file (needed to import the py4j.GatewayServer on the Java side)\n        filename = f\"py4j{__version__}.jar\"\n        py4j_jar = os.environ.get(\"PY4J_JAR\", \"\")\n        if py4j_jar:\n            if not os.path.isfile(py4j_jar) or os.path.basename(py4j_jar) != filename:\n                msg = (\n                    f\"A PY4J_JAR environment variable exists, \"\n                    f\"but the full path to {filename} is invalid\\n\"\n                    f\"PY4J_JAR={py4j_jar}\"\n                )\n                raise OSError(msg)\n        else:\n            root = os.path.dirname(sys.executable)\n            for item in [root, os.path.dirname(root), os.path.join(os.path.expanduser(\"~\"), \".local\")]:\n                py4j_jar = os.path.join(item, \"share\", \"py4j\", filename)\n                if os.path.isfile(py4j_jar):\n                    break\n            if not os.path.isfile(py4j_jar):\n                msg = (\n                    f\"Cannot find {filename}\\n\"\n                    f\"Create a PY4J_JAR environment variable \"\n                    f\"to be equal to the full path to {filename}\"\n                )\n                raise OSError(msg)\n\n        # build the java command\n        wrapper = os.path.join(os.path.dirname(__file__), \"py4j-wrapper.jar\")\n        cmd = [\"java\", \"-cp\", f\"{py4j_jar}{os.pathsep}{wrapper}\", \"Py4JWrapper\", str(port)]\n\n        # from the URLClassLoader documentation:\n        #   Any URL that ends with a '/' is assumed to refer to a directory. Otherwise, the URL\n        #   is assumed to refer to a JAR file which will be downloaded and opened as needed.\n        if ext == \".jar\":\n            cmd.append(self._path)\n        else:  # it is a .class file\n            cmd.append(f\"{os.path.dirname(self._path)}/\")\n\n        err = None\n        try:\n            # start the py4j.GatewayServer\n            flags = 0x08000000 if IS_WINDOWS else 0  # fixes issue 31, CREATE_NO_WINDOW = 0x08000000\n            subprocess.Popen(cmd, stderr=subprocess.PIPE, stdout=subprocess.PIPE, creationflags=flags)\n        except OSError as e:\n            err = str(e).rstrip()\n            err += \"\\nYou must have a Java Runtime Environment installed and available on PATH\"\n\n        if err:\n            raise OSError(err)\n\n        try:\n            utils.wait_for_server(address, port, 10.0)\n        except OSError as e:\n            err = str(e).rstrip()\n            err += \"\\nCould not start the Py4J GatewayServer\"\n\n        if err:\n            raise OSError(err)\n\n        self._gateway = JavaGateway(gateway_parameters=GatewayParameters(address=address, port=port, **kwargs))\n\n        self._lib = self._gateway.jvm\n\n    elif libtype == \"net\" or libtype == \"clr\":\n        if not utils.is_pythonnet_installed():\n            msg = \"Cannot load a .NET Assembly because pythonnet is not installed.\\nRun: pip install pythonnet\"\n            raise OSError(msg)\n\n        import clr  # noqa: clr is an alias for pythonnet\n        import System  # noqa: available once pythonnet is imported\n\n        dotnet = {\"System\": System}\n\n        # the library must be available in sys.path\n        head, tail = os.path.split(self._path)\n        sys.path.insert(0, head)\n\n        try:\n            # don't include the library extension\n            clr.AddReference(os.path.splitext(tail)[0])  # noqa: AddReference exists\n        except (System.IO.FileNotFoundException, System.IO.FileLoadException):\n            # The file must exist since its existence is checked above.\n            # There must be another reason why loading the DLL raises this\n            # error. Calling LoadFile (below) provides more information\n            # in the error message.\n            pass\n\n        try:\n            # By default, pythonnet can only load libraries that are for .NET 4.0+\n            #\n            # In order to allow pythonnet to load a library from .NET &lt;4.0 the\n            # useLegacyV2RuntimeActivationPolicy property needs to be enabled\n            # in a &lt;python-executable&gt;.config file. If the following statement\n            # raises a FileLoadException then attempt to create the configuration\n            # file that has the property enabled and then notify the user why\n            # loading the library failed and ask them to re-run their Python\n            # script to load the .NET library.\n            self._assembly = System.Reflection.Assembly.LoadFile(self._path)\n\n        except System.IO.FileLoadException as err:\n            # Example error message that can occur if the library is for .NET &lt;4.0,\n            # and the useLegacyV2RuntimeActivationPolicy is not enabled:\n            #\n            # \" Mixed mode assembly is built against version 'v2.0.50727' of the\n            #  runtime and cannot be loaded in the 4.0 runtime without additional\n            #  configuration information. \"\n            if str(err).startswith(\"Mixed mode assembly is built against version\"):\n                py_exe = sys.executable\n                if sys.prefix != sys.base_prefix:\n                    # Python is running in a venv/virtualenv\n                    # When using conda environments, sys.prefix == sys.base_prefix\n                    py_exe = os.path.join(sys.base_prefix, os.path.basename(py_exe))\n                status, msg = utils.check_dot_net_config(py_exe)\n                if status == 0:\n                    msg = f\"Checking .NET config returned {msg!r} and still cannot load the library.\\n{err}\"\n                raise OSError(msg)\n\n            msg = \"The above 'System.IO.FileLoadException' is not handled.\\n\"\n            raise OSError(msg)\n\n        try:\n            types = self._assembly.GetTypes()\n        except Exception as e:\n            utils.logger.error(e)\n            utils.logger.error(\"The LoaderExceptions are:\")\n            for item in e.LoaderExceptions:  # noqa: LoaderExceptions comes from .NET\n                utils.logger.error(\"  %s\", item.Message)\n        else:\n            for t in types:\n                try:\n                    if t.Namespace:\n                        obj = __import__(t.Namespace)\n                    else:\n                        obj = getattr(__import__(\"clr\"), t.FullName)\n                except:  # noqa: PEP 8: E722 do not use bare 'except'\n                    obj = t\n                    obj.__name__ = t.FullName\n\n                if obj.__name__ not in dotnet:\n                    dotnet[obj.__name__] = obj\n\n        self._lib = DotNet(self._path, dotnet)\n\n    else:\n        assert False, \"Should not get here -- contact developers\"\n\n    utils.logger.debug(\"Loaded %s\", self._path)\n</code></pre>"},{"location":"api/load_library/#msl.loadlib.load_library.LoadLibrary.application","title":"application  <code>property</code>","text":"<pre><code>application\n</code></pre> <p>Application | <code>None</code> \u2014 Reference to the ActiveX application window.</p> <p>If the loaded library is not an ActiveX library, returns <code>None</code>.</p> <p>When an ActiveX library is loaded, the window is not shown (to show it call Application.show) and the message loop is not running (to run it call Application.run).</p> <p>Added in version 1.0</p>"},{"location":"api/load_library/#msl.loadlib.load_library.LoadLibrary.assembly","title":"assembly  <code>property</code>","text":"<pre><code>assembly\n</code></pre> <p>Returns a reference to the .NET Runtime Assembly object.</p> <p>If the loaded library is not a .NET library, returns <code>None</code>.</p> <p>Tip</p> <p>The JetBrains dotPeek program can be used to decompile a .NET Assembly.</p>"},{"location":"api/load_library/#msl.loadlib.load_library.LoadLibrary.gateway","title":"gateway  <code>property</code>","text":"<pre><code>gateway\n</code></pre> <p>JavaGateway | <code>None</code> \u2014 Reference to the Java gateway.</p> <p>If the loaded library is not a Java library, returns <code>None</code>.</p>"},{"location":"api/load_library/#msl.loadlib.load_library.LoadLibrary.lib","title":"lib  <code>property</code>","text":"<pre><code>lib\n</code></pre> <p>Returns the reference to the library object.</p> <p>For example, if <code>libtype</code> is</p> <ul> <li><code>cdll</code> \u2192 ctypes.CDLL</li> <li><code>windll</code> \u2192 ctypes.WinDLL</li> <li><code>oledll</code> \u2192 ctypes.OleDLL</li> <li><code>java</code> \u2192 JVMView</li> <li><code>net</code> or <code>clr</code> \u2192 An object containing .NET namespaces,     classes and System.Types</li> <li><code>com</code> or <code>activex</code> \u2192 ctypes.POINTER</li> </ul>"},{"location":"api/load_library/#msl.loadlib.load_library.LoadLibrary.path","title":"path  <code>property</code>","text":"<pre><code>path\n</code></pre> <p>str \u2014 The path to the library file.</p>"},{"location":"api/load_library/#msl.loadlib.load_library.LoadLibrary.cleanup","title":"cleanup","text":"<pre><code>cleanup()\n</code></pre> <p>Clean up references to the library.</p> <p>Added in version 0.10</p> Source code in <code>src/msl/loadlib/load_library.py</code> <pre><code>def cleanup(self) -&gt; None:\n    \"\"\"Clean up references to the library.\n\n    !!! note \"Added in version 0.10\"\n    \"\"\"\n    self._assembly = None\n    self._lib = None\n    if self._gateway:\n        self._gateway.shutdown()\n        self._gateway = None\n        utils.logger.debug(\"shutdown Py4J.GatewayServer\")\n    if self._app:\n        self._app.close()\n        self._app = None\n        utils.logger.debug(\"close ActiveX application\")\n</code></pre>"},{"location":"api/server32/","title":"Server32","text":"<p>Base class for loading a 32-bit library in 32-bit Python.</p> <p>Server32 is used in combination with Client64 to communicate with a 32-bit library from 64-bit Python.</p>"},{"location":"api/server32/#msl.loadlib.server32.Server32","title":"Server32","text":"<pre><code>Server32(path, libtype, host, port, **kwargs)\n</code></pre> <p>               Bases: <code>HTTPServer</code></p> <p>Base class for loading a 32-bit library in 32-bit Python.</p> <p>All modules that are to be run on the 32-bit server must contain a class that inherits this class. The module may import most of the standard python modules (graphic-related modules, e.g., tkinter, are not available).</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>PathLike</code> <p>The path to the 32-bit library (see LoadLibrary)</p> required <code>libtype</code> <code>LibType</code> <p>The library type (see LoadLibrary).</p> <p>Attention</p> <p>Since Java byte code is executed on the JVM it does not make sense to use Server32 for a Java <code>.jar</code> or <code>.class</code> file. Use LoadLibrary to load a Java library.</p> required <code>host</code> <code>str</code> <p>The IP address (or hostname) to use for the server.</p> required <code>port</code> <code>int</code> <p>The port to open for the server.</p> required <code>kwargs</code> <code>Any</code> <p>All keyword arguments are passed to LoadLibrary.</p> <code>{}</code> Source code in <code>src/msl/loadlib/server32.py</code> <pre><code>def __init__(self, path: PathLike, libtype: LibType, host: str, port: int, **kwargs: Any) -&gt; None:\n    \"\"\"Base class for loading a 32-bit library in 32-bit Python.\n\n    All modules that are to be run on the 32-bit server must contain a class\n    that inherits this class. The module may import most of the\n    [standard](https://docs.python.org/3/py-modindex.html){:target=\"_blank\"}\n    python modules (graphic-related modules, e.g., [tkinter][]{:target=\"_blank\"},\n    are not available).\n\n    Args:\n        path: The path to the 32-bit library (see [LoadLibrary][msl.loadlib.load_library.LoadLibrary])\n        libtype: The library type (see [LoadLibrary][msl.loadlib.load_library.LoadLibrary]).\n\n            !!! attention\n                Since Java byte code is executed on the\n                [JVM](https://en.wikipedia.org/wiki/Java_virtual_machine){:target=\"_blank\"}\n                it does not make sense to use [Server32][] for a Java `.jar` or `.class` file.\n                Use [LoadLibrary][msl.loadlib.load_library.LoadLibrary] to load a Java library.\n\n        host: The IP address (or hostname) to use for the server.\n        port: The port to open for the server.\n        kwargs: All keyword arguments are passed to [LoadLibrary][msl.loadlib.load_library.LoadLibrary].\n    \"\"\"\n    self._library = LoadLibrary(path, libtype=libtype, **kwargs)\n    self._app = self._library.application\n    self._assembly = self._library.assembly\n    self._lib = self._library.lib\n    self._path = self._library.path\n    super().__init__((host, int(port)), _RequestHandler, bind_and_activate=False)\n</code></pre>"},{"location":"api/server32/#msl.loadlib.server32.Server32.application","title":"application  <code>property</code>","text":"<pre><code>application\n</code></pre> <p>Application | <code>None</code> \u2014 Reference to the ActiveX application window.</p> <p>If the loaded library is not an ActiveX library, returns <code>None</code>.</p> <p>When an ActiveX library is loaded, the window is not shown (to show it call Application.show) and the message loop is not running (to run it call Application.run).</p> <p>Added in version 1.0</p>"},{"location":"api/server32/#msl.loadlib.server32.Server32.assembly","title":"assembly  <code>property</code>","text":"<pre><code>assembly\n</code></pre> <p>Returns a reference to the .NET Runtime Assembly object.</p> <p>If the loaded library is not a .NET library, returns <code>None</code>.</p> <p>Tip</p> <p>The JetBrains dotPeek program can be used to decompile a .NET Assembly.</p>"},{"location":"api/server32/#msl.loadlib.server32.Server32.lib","title":"lib  <code>property</code>","text":"<pre><code>lib\n</code></pre> <p>Returns the reference to the library object.</p> <p>For example, if <code>libtype</code> is</p> <ul> <li><code>cdll</code> \u2192 ctypes.CDLL</li> <li><code>windll</code> \u2192 ctypes.WinDLL</li> <li><code>oledll</code> \u2192 ctypes.OleDLL</li> <li><code>net</code> or <code>clr</code> \u2192 An object containing .NET namespaces,     classes and System.Types</li> <li><code>com</code> or <code>activex</code> \u2192 ctypes.POINTER</li> </ul>"},{"location":"api/server32/#msl.loadlib.server32.Server32.path","title":"path  <code>property</code>","text":"<pre><code>path\n</code></pre> <p>str \u2014 The path to the library file.</p>"},{"location":"api/server32/#msl.loadlib.server32.Server32.examples_dir","title":"examples_dir  <code>staticmethod</code>","text":"<pre><code>examples_dir()\n</code></pre> <p>Path \u2014 The directory where the example libraries are located.</p> <p>Added in version 0.9</p> <p>Changed in version 1.0</p> <p>The return type changed from str to Path.</p> Source code in <code>src/msl/loadlib/server32.py</code> <pre><code>@staticmethod\ndef examples_dir() -&gt; Path:\n    \"\"\"[Path][pathlib.Path] &amp;mdash; The directory where the [example][direct] libraries are located.\n\n    !!! note \"Added in version 0.9\"\n    !!! note \"Changed in version 1.0\"\n        The return type changed from [str][]{:target=\"_blank\"} to [Path][pathlib.Path]{:target=\"_blank\"}.\n    \"\"\"\n    path = sys.executable if Server32.is_interpreter() else __file__\n    return Path(path).parent.parent / \"examples\" / \"loadlib\"\n</code></pre>"},{"location":"api/server32/#msl.loadlib.server32.Server32.interactive_console","title":"interactive_console  <code>staticmethod</code>","text":"<pre><code>interactive_console()\n</code></pre> <p>Start an interactive console.</p> <p>This method starts an interactive console, in a new terminal, with the Python interpreter on the 32-bit server.</p> <p>Tip</p> <p>You can start the console from a terminal by running <pre><code>python -c \"from msl.loadlib import Server32; Server32.interactive_console()\"\n</code></pre></p> Source code in <code>src/msl/loadlib/server32.py</code> <pre><code>@staticmethod\ndef interactive_console() -&gt; None:\n    \"\"\"Start an [interactive console]{:target=\"_blank\"}.\n\n    This method starts an [interactive console]{:target=\"_blank\"}, in a new terminal,\n    with the Python interpreter on the 32-bit server.\n\n    !!! tip\n        You can start the console from a terminal by running\n        ```console\n        python -c \"from msl.loadlib import Server32; Server32.interactive_console()\"\n        ```\n\n    [interactive console]: https://docs.python.org/3/tutorial/interpreter.html#interactive-mode\n    \"\"\"\n    exe = os.path.join(os.path.dirname(__file__), SERVER_FILENAME)\n    if IS_WINDOWS:\n        cmd = f'start \"msl.loadlib.Server32 || interactive console\" \"{exe}\" --interactive'\n    else:\n        cmd = f\"gnome-terminal --command='{exe} --interactive'\"\n    os.system(cmd)\n</code></pre>"},{"location":"api/server32/#msl.loadlib.server32.Server32.is_interpreter","title":"is_interpreter  <code>staticmethod</code>","text":"<pre><code>is_interpreter()\n</code></pre> <p>Check if code is running on the 32-bit server.</p> <p>If the same module is executed by both Client64 and Server32 then there may be sections of the code that should only be executed by the correct bitness of the Python interpreter.</p> <p>Example:</p> <pre><code>import sys\nfrom msl.loadlib import Client64, Server32\n\nif Server32.is_interpreter():\n    # Only executed on the 32-bit server\n    assert sys.maxsize &lt; 2**32\n</code></pre> <p>Returns:</p> Type Description <code>bool</code> <p>Whether the module is running on the 32-bit server.</p> <p>Added in version 0.9</p> Source code in <code>src/msl/loadlib/server32.py</code> <pre><code>@staticmethod\ndef is_interpreter() -&gt; bool:\n    \"\"\"Check if code is running on the 32-bit server.\n\n    If the same module is executed by both [Client64][] and [Server32][]\n    then there may be sections of the code that should only be executed\n    by the correct bitness of the Python interpreter.\n\n    **Example:**\n\n    ```python\n    import sys\n    from msl.loadlib import Client64, Server32\n\n    if Server32.is_interpreter():\n        # Only executed on the 32-bit server\n        assert sys.maxsize &lt; 2**32\n    ```\n\n    Returns:\n        Whether the module is running on the 32-bit server.\n\n    !!! note \"Added in version 0.9\"\n    \"\"\"\n    return sys.executable.endswith(SERVER_FILENAME)\n</code></pre>"},{"location":"api/server32/#msl.loadlib.server32.Server32.remove_site_packages_64bit","title":"remove_site_packages_64bit  <code>staticmethod</code>","text":"<pre><code>remove_site_packages_64bit()\n</code></pre> <p>Remove the site-packages directory from the 64-bit process.</p> <p>By default, the site-packages directory of the 64-bit process is included in sys.path of the 32-bit process. Having the 64-bit site-packages directory available can sometimes cause issues. For example, <code>comtypes</code> tries to import <code>numpy</code> so if <code>numpy</code> is installed in the 64-bit process then <code>comtypes</code> will import the 64-bit version of <code>numpy</code> in the 32-bit process. Depending on the version of Python and/or <code>numpy</code> this can cause the 32-bit server to crash.</p> <p>Example:</p> <pre><code>import sys\nfrom msl.loadlib import Server32\n\nclass FileSystem(Server32):\n\n    def __init__(self, host, port):\n\n        # Remove the site-packages directory that was passed from 64-bit Python\n        path = Server32.remove_site_packages_64bit()\n\n        # Load the COM library (this is when `comtypes` gets imported)\n        super().__init__(\"Scripting.FileSystemObject\", \"com\", host, port)\n\n        # Optional: add the site-packages directory back into sys.path\n        sys.path.append(path)\n</code></pre> <p>Returns:</p> Type Description <code>str</code> <p>The path to the site-packages directory that was removed. Can be an empty string if the directory was not found in sys.path.</p> <p>Added in version 0.9</p> Source code in <code>src/msl/loadlib/server32.py</code> <pre><code>@staticmethod\ndef remove_site_packages_64bit() -&gt; str:\n    \"\"\"Remove the _site-packages_ directory from the 64-bit process.\n\n    By default, the _site-packages_ directory of the 64-bit process is\n    included in [sys.path][] of the 32-bit process. Having the\n    64-bit _site-packages_ directory available can sometimes cause issues.\n    For example, `comtypes` tries to import `numpy` so if `numpy` is\n    installed in the 64-bit process then `comtypes` will import the\n    64-bit version of `numpy` in the 32-bit process. Depending on the\n    version of Python and/or `numpy` this can cause the 32-bit server\n    to crash.\n\n    **Example:**\n\n    ```python\n    import sys\n    from msl.loadlib import Server32\n\n    class FileSystem(Server32):\n\n        def __init__(self, host, port):\n\n            # Remove the site-packages directory that was passed from 64-bit Python\n            path = Server32.remove_site_packages_64bit()\n\n            # Load the COM library (this is when `comtypes` gets imported)\n            super().__init__(\"Scripting.FileSystemObject\", \"com\", host, port)\n\n            # Optional: add the site-packages directory back into sys.path\n            sys.path.append(path)\n    ```\n\n    Returns:\n        The path to the _site-packages_ directory that was removed.\n            Can be an empty string if the directory was not found in [sys.path][].\n\n    !!! note \"Added in version 0.9\"\n    \"\"\"\n    for index, path in enumerate(sys.path):\n        if path.endswith(\"site-packages\"):\n            return sys.path.pop(index)\n    return \"\"\n</code></pre>"},{"location":"api/server32/#msl.loadlib.server32.Server32.shutdown_handler","title":"shutdown_handler","text":"<pre><code>shutdown_handler()\n</code></pre> <p>Called just before the server shuts down.</p> <p>Override this method to do any necessary cleanup, such as stopping threads or closing file handles, before the server shuts down.</p> <p>Added in version 0.6</p> Source code in <code>src/msl/loadlib/server32.py</code> <pre><code>def shutdown_handler(self) -&gt; None:\n    \"\"\"Called just before the server shuts down.\n\n    Override this method to do any necessary cleanup, such as stopping\n    threads or closing file handles, before the server shuts down.\n\n    !!! note \"Added in version 0.6\"\n    \"\"\"\n</code></pre>"},{"location":"api/server32/#msl.loadlib.server32.Server32.version","title":"version  <code>staticmethod</code>","text":"<pre><code>version()\n</code></pre> <p>str \u2014 The version of Python that the 32-bit server is running on.</p> <p>Tip</p> <p>You can get the version from a terminal by running <pre><code>python -c \"from msl.loadlib import Server32; Server32.version()\"\n</code></pre></p> Source code in <code>src/msl/loadlib/server32.py</code> <pre><code>@staticmethod\ndef version() -&gt; str:\n    \"\"\"[str][] &amp;mdash; The version of Python that the 32-bit server is running on.\n\n    !!! tip\n        You can get the version from a terminal by running\n        ```console\n        python -c \"from msl.loadlib import Server32; Server32.version()\"\n        ```\n    \"\"\"\n    exe = os.path.join(os.path.dirname(__file__), SERVER_FILENAME)\n    return subprocess.check_output([exe, \"--version\"]).decode().strip()\n</code></pre>"},{"location":"api/types/","title":"types","text":"<p>Custom types.</p>"},{"location":"api/types/#msl.loadlib._types.LibType","title":"LibType  <code>module-attribute</code>","text":"<pre><code>LibType = Literal[\n    \"cdll\",\n    \"windll\",\n    \"oledll\",\n    \"net\",\n    \"clr\",\n    \"java\",\n    \"com\",\n    \"activex\",\n]\n</code></pre> <p>Supported library types.</p>"},{"location":"api/types/#msl.loadlib._types.PathLike","title":"PathLike  <code>module-attribute</code>","text":"<pre><code>PathLike = str | bytes | PathLike[str] | PathLike[bytes]\n</code></pre> <p>A path-like object.</p>"},{"location":"api/utils/","title":"utils","text":"<p>Common utility functions.</p>"},{"location":"api/utils/#msl.loadlib.utils.check_dot_net_config","title":"check_dot_net_config","text":"<pre><code>check_dot_net_config(py_exe_path)\n</code></pre> <p>Checks if the useLegacyV2RuntimeActivationPolicy property is enabled.</p> <p>By default, Python.NET works with .NET 4.0+ and therefore it cannot automatically load a library that was compiled with .NET &lt;4.0.</p> <p>This function ensures that the useLegacyV2RuntimeActivationPolicy property is defined in the py_exe_path.config file and that it is enabled.</p> <p>This link provides an overview explaining why the useLegacyV2RuntimeActivationPolicy property is required.</p> <p>The py_exe_path.config file that is created is</p> <pre><code>&lt;?xml version=\"1.0\" encoding=\"utf-8\" ?&gt;\n&lt;configuration&gt;\n    &lt;startup useLegacyV2RuntimeActivationPolicy=\"true\"&gt;\n        &lt;supportedRuntime version=\"v4.0\" /&gt;\n        &lt;supportedRuntime version=\"v2.0.50727\" /&gt;\n    &lt;/startup&gt;\n&lt;/configuration&gt;\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>py_exe_path</code> <code>str</code> <p>The path to a Python executable.</p> required <p>Returns:</p> Type Description <code>tuple[int, str]</code> <p>A status flag and a message describing the outcome.</p> <p>The flag will be one of the following values:</p> <ul> <li>-1: if there was a problem</li> <li>0: if the .NET property was already enabled, or</li> <li>1: if the property was created successfully.</li> </ul> Source code in <code>src/msl/loadlib/utils.py</code> <pre><code>def check_dot_net_config(py_exe_path: str) -&gt; tuple[int, str]:\n    \"\"\"Checks if the **useLegacyV2RuntimeActivationPolicy** property is enabled.\n\n    By default, [Python.NET](https://pythonnet.github.io/){:target=\"_blank\"} works\n    with .NET 4.0+ and therefore it cannot automatically load a library that was compiled\n    with .NET &amp;lt;4.0.\n\n    This function ensures that the **useLegacyV2RuntimeActivationPolicy** property is\n    defined in the *py_exe_path*.config file and that it is enabled.\n\n    This [link](https://stackoverflow.com/questions/14508627/){:target=\"_blank\"} provides\n    an overview explaining why the **useLegacyV2RuntimeActivationPolicy** property is required.\n\n    The *py_exe_path*.config file that is created is\n\n    ```xml\n    &lt;?xml version=\"1.0\" encoding=\"utf-8\" ?&gt;\n    &lt;configuration&gt;\n        &lt;startup useLegacyV2RuntimeActivationPolicy=\"true\"&gt;\n            &lt;supportedRuntime version=\"v4.0\" /&gt;\n            &lt;supportedRuntime version=\"v2.0.50727\" /&gt;\n        &lt;/startup&gt;\n    &lt;/configuration&gt;\n    ```\n\n    Args:\n        py_exe_path: The path to a Python executable.\n\n    Returns:\n        A status flag and a message describing the outcome.\n\n            The flag will be one of the following values:\n\n            * -1: if there was a problem\n            * 0: if the .NET property was already enabled, or\n            * 1: if the property was created successfully.\n    \"\"\"\n    config_path = f\"{py_exe_path}.config\"\n\n    if os.path.isfile(config_path):\n        try:\n            tree = ElementTree.parse(config_path)\n        except ElementTree.ParseError:\n            msg = f\"Invalid XML file {config_path}\\nCannot create the useLegacyV2RuntimeActivationPolicy property.\\n\"\n            logger.warning(msg)\n            return -1, msg\n\n        root = tree.getroot()\n\n        if root.tag != \"configuration\":\n            msg = (\n                f\"The root tag in {config_path} is &lt;{root.tag}&gt;.\\n\"\n                f\"It must be &lt;configuration&gt; in order to create a .NET Framework config\\n\"\n                f\"file which enables the useLegacyV2RuntimeActivationPolicy property.\\n\"\n                f\"To load an assembly from a .NET Framework version &lt; 4.0 the following\\n\"\n                f\"must be in {config_path}\\n\\n\"\n                f\"&lt;configuration&gt;{NET_FRAMEWORK_FIX}&lt;/configuration&gt;\\n\"\n            )\n            logger.warning(msg)\n            return -1, msg\n\n        # check if the policy exists\n        policy = root.find(\"startup/[@useLegacyV2RuntimeActivationPolicy]\")\n        if policy is None:\n            with open(config_path, mode=\"rt\") as fp:\n                lines = fp.readlines()\n\n            lines.insert(-1, NET_FRAMEWORK_FIX)\n            with open(config_path, mode=\"wt\") as fp:\n                fp.writelines(lines)\n            msg = (\n                f\"Added the useLegacyV2RuntimeActivationPolicy property to\\n\"\n                f\"{config_path}\\n\"\n                f\"Try again to see if Python can now load the .NET library.\\n\"\n            )\n            return 1, msg\n        else:\n            if not policy.attrib[\"useLegacyV2RuntimeActivationPolicy\"].lower() == \"true\":\n                msg = (\n                    f\"The useLegacyV2RuntimeActivationPolicy in\\n{config_path}\\n\"\n                    f'is \"false\". Cannot load an assembly from a .NET Framework '\n                    f\"version &lt; 4.0.\\n\"\n                )\n                logger.warning(msg)\n                return -1, msg\n            return 0, \"The useLegacyV2RuntimeActivationPolicy property is enabled\"\n\n    else:\n        with open(config_path, mode=\"wt\") as f:\n            f.write('&lt;?xml version=\"1.0\" encoding=\"utf-8\" ?&gt;')\n            f.write(NET_FRAMEWORK_DESCRIPTION)\n            f.write(\"&lt;configuration&gt;\")\n            f.write(NET_FRAMEWORK_FIX)\n            f.write(\"&lt;/configuration&gt;\\n\")\n\n        msg = (\n            f\"The library appears to be from a .NET Framework version &lt; 4.0.\\n\"\n            f\"The useLegacyV2RuntimeActivationPolicy property was added to\\n\"\n            f\"{config_path}\\n\"\n            f'to fix the \"System.IO.FileLoadException: Mixed mode assembly...\" error.\\n'\n            f\"Rerun the script, or restart the interactive console, to see if\\n\"\n            f\"Python can now load the .NET library.\\n\"\n        )\n        return 1, msg\n</code></pre>"},{"location":"api/utils/#msl.loadlib.utils.generate_com_wrapper","title":"generate_com_wrapper","text":"<pre><code>generate_com_wrapper(lib, out_dir=None)\n</code></pre> <p>Generate a Python wrapper module around a COM library.</p> <p>For more information see Accessing type libraries.</p> <p>Attention</p> <p>This function is only supported on Windows.</p> <p>Parameters:</p> Name Type Description Default <code>lib</code> <code>Any</code> <p>The COM library to create a wrapper of.</p> <p>Can be any of the following:</p> <ul> <li>a LoadLibrary instance</li> <li>the <code>ProgID</code> or <code>CLSID</code> of a registered COM library as a str</li> <li>a <code>comtypes</code> pointer instance</li> <li>an <code>ITypeLib</code> COM pointer from a loaded type library</li> <li>the path to a library file (.tlb, .exe or .dll) as a str</li> <li> <p>a sequence specifying the <code>GUID</code> of a library, a major and a minor     version number, plus optionally an <code>LCID</code> number, e.g.,</p> <p><code>[\"{EAB22AC0-30C1-11CF-A7EB-0000C05BAE0B}\", 1, 1]</code></p> </li> <li> <p>an object with <code>_reg_libid_</code> and <code>_reg_version_</code> attributes</p> </li> </ul> required <code>out_dir</code> <code>str | None</code> <p>The output directory to save the wrapper to. If not specified, the module is saved to the <code>../site-packages/comtypes/gen</code> directory.</p> <code>None</code> <p>Returns:</p> Type Description <code>ModuleType</code> <p>The wrapper module that was generated.</p> <p>Added in version 0.9</p> Source code in <code>src/msl/loadlib/utils.py</code> <pre><code>def generate_com_wrapper(lib: Any, out_dir: str | None = None) -&gt; ModuleType:\n    \"\"\"Generate a Python wrapper module around a [COM]{:target=\"_blank\"} library.\n\n    For more information see [Accessing type libraries]{:target=\"_blank\"}.\n\n    [COM]: https://learn.microsoft.com/en-us/windows/win32/com/component-object-model--com--portal\n    [Accessing type libraries]: https://comtypes.readthedocs.io/en/stable/client.html#accessing-type-libraries\n\n    !!! attention\n        This function is only supported on Windows.\n\n    Args:\n        lib: The COM library to create a wrapper of.\n\n            Can be any of the following:\n\n            * a [LoadLibrary][] instance\n            * the `ProgID` or `CLSID` of a registered COM library as a [str][]\n            * a `comtypes` pointer instance\n            * an `ITypeLib` COM pointer from a loaded type library\n            * the path to a library file (.tlb, .exe or .dll) as a [str][]\n            * a sequence specifying the `GUID` of a library, a major and a minor\n                version number, plus optionally an `LCID` number, e.g.,\n\n                `[\"{EAB22AC0-30C1-11CF-A7EB-0000C05BAE0B}\", 1, 1]`\n\n            * an object with `_reg_libid_` and `_reg_version_` attributes\n\n        out_dir: The output directory to save the wrapper to. If not specified,\n            the module is saved to the `../site-packages/comtypes/gen` directory.\n\n    Returns:\n        The wrapper module that was generated.\n\n    !!! note \"Added in version 0.9\"\n    \"\"\"\n    if not is_comtypes_installed():\n        msg = \"Cannot create a COM wrapper because comtypes is not installed, run\\n  pip install comtypes\"\n        raise OSError(msg)\n\n    import comtypes.client\n\n    mod = None\n\n    # cache the value of gen_dir to reset it later\n    cached_gen_dir = comtypes.client.gen_dir\n    if out_dir is not None:\n        gen_dir = os.path.abspath(out_dir)\n        if not os.path.isdir(gen_dir):\n            os.makedirs(gen_dir)\n        comtypes.client.gen_dir = gen_dir\n\n    def from_pointer(p):\n        info = p.GetTypeInfo(0)\n        type_lib, index = info.GetContainingTypeLib()\n        return comtypes.client.GetModule(type_lib)\n\n    try:\n        mod = comtypes.client.GetModule(lib)\n    except OSError:\n        pass\n    except (AttributeError, TypeError) as e:\n        if \"LoadLibrary\" in str(e):\n            mod = from_pointer(lib.lib)\n        elif hasattr(lib, \"__com_interface__\"):\n            mod = from_pointer(lib)\n        else:\n            raise\n\n    if not mod and isinstance(lib, str):\n        obj = comtypes.client.CreateObject(lib)\n        mod = from_pointer(obj)\n\n    if out_dir is not None:\n        comtypes.client.gen_dir = cached_gen_dir\n\n    return mod\n</code></pre>"},{"location":"api/utils/#msl.loadlib.utils.get_available_port","title":"get_available_port","text":"<pre><code>get_available_port()\n</code></pre> <p>int \u2014 Returns a port number that is available.</p> Source code in <code>src/msl/loadlib/utils.py</code> <pre><code>def get_available_port() -&gt; int:\n    \"\"\"[int][] &amp;mdash; Returns a port number that is available.\"\"\"\n    with socket.socket() as sock:\n        sock.bind((\"\", 0))\n        port = sock.getsockname()[1]\n    return port\n</code></pre>"},{"location":"api/utils/#msl.loadlib.utils.get_com_info","title":"get_com_info","text":"<pre><code>get_com_info(*additional_keys)\n</code></pre> <p>Reads the registry for the COM libraries that are available.</p> <p>Attention</p> <p>This function is only supported on Windows.</p> <p>Parameters:</p> Name Type Description Default <code>additional_keys</code> <code>str</code> <p>The Program ID (<code>ProgID</code>) key is returned automatically. You can include additional keys (e.g., <code>Version</code>, <code>InprocHandler32</code>, <code>ToolboxBitmap32</code>, <code>VersionIndependentProgID</code>, ...) if you also want this additional information to be returned for each Class ID.</p> <code>()</code> <p>Example:</p> <pre><code>from msl.loadlib import utils\n\ninfo = utils.get_com_info()\nmore_info = utils.get_com_info(\"Version\", \"ToolboxBitmap32\")\n</code></pre> <p>Returns:</p> Type Description <code>dict[str, dict[str, str | None]]</code> <p>The keys are the Class ID's and each value is a dict of the information that was requested.</p> <p>Added in version 0.5</p> Source code in <code>src/msl/loadlib/utils.py</code> <pre><code>def get_com_info(*additional_keys: str) -&gt; dict[str, dict[str, str | None]]:\n    \"\"\"Reads the registry for the [COM]{:target=\"_blank\"} libraries that are available.\n\n    [COM]: https://learn.microsoft.com/en-us/windows/win32/com/component-object-model--com--portal\n\n    !!! attention\n        This function is only supported on Windows.\n\n    Args:\n        additional_keys: The Program ID (`ProgID`) key is returned automatically.\n            You can include additional keys (e.g., `Version`, `InprocHandler32`, `ToolboxBitmap32`,\n            `VersionIndependentProgID`, ...) if you also want this additional\n            information to be returned for each [Class ID]{:target=\"_blank\"}.\n\n            [Class ID]: https://docs.microsoft.com/en-us/windows/desktop/com/clsid-key-hklm\n\n    **Example:**\n\n    ```python\n    from msl.loadlib import utils\n\n    info = utils.get_com_info()\n    more_info = utils.get_com_info(\"Version\", \"ToolboxBitmap32\")\n    ```\n\n    Returns:\n        The keys are the Class ID's and each value is a [dict][] of the information that was requested.\n\n    !!! note \"Added in version 0.5\"\n    \"\"\"\n    if winreg is None:\n        return {}\n\n    results = {}\n    for item in [\"CLSID\", r\"Wow6432Node\\CLSID\"]:\n        try:\n            key = winreg.OpenKey(winreg.HKEY_CLASSES_ROOT, item)\n        except OSError:\n            continue\n        else:\n            logger.debug(r\"Parsing HKEY_CLASSES_ROOT\\%s\\...\", item)\n\n        index = -1\n        while True:\n            index += 1\n            try:\n                clsid = winreg.EnumKey(key, index)\n            except OSError:\n                break\n\n            sub_key = winreg.OpenKey(key, clsid)\n\n            # ProgID is mandatory, if this fails then ignore\n            # this CLSID and go to the next index in the registry\n            try:\n                progid = winreg.QueryValue(sub_key, \"ProgID\")\n            except OSError:\n                pass\n            else:\n                results[clsid] = {}\n                results[clsid][\"ProgID\"] = progid\n\n                for name in additional_keys:\n                    try:\n                        results[clsid][name] = winreg.QueryValue(sub_key, name)\n                    except OSError:\n                        results[clsid][name] = None\n            finally:\n                winreg.CloseKey(sub_key)\n\n        winreg.CloseKey(key)\n\n    return results\n</code></pre>"},{"location":"api/utils/#msl.loadlib.utils.is_comtypes_installed","title":"is_comtypes_installed","text":"<pre><code>is_comtypes_installed()\n</code></pre> <p>Checks if <code>comtypes</code> is installed.</p> <p>Returns:</p> Type Description <code>bool</code> <p>Whether <code>comtypes</code> is installed.</p> <p>Added in version 0.5</p> Source code in <code>src/msl/loadlib/utils.py</code> <pre><code>def is_comtypes_installed() -&gt; bool:\n    \"\"\"Checks if `comtypes` is installed.\n\n    Returns:\n        Whether `comtypes` is installed.\n\n    !!! note \"Added in version 0.5\"\n    \"\"\"\n    try:\n        import comtypes\n    except ImportError:\n        return False\n    return True\n</code></pre>"},{"location":"api/utils/#msl.loadlib.utils.is_port_in_use","title":"is_port_in_use","text":"<pre><code>is_port_in_use(port)\n</code></pre> <p>Checks whether the TCP port is in use.</p> <p>Parameters:</p> Name Type Description Default <code>port</code> <code>int</code> <p>The port number to test.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>Whether the TCP port is in use.</p> <p>Changed in version 0.10</p> <p>Only check TCP ports (instead of both TCP and UDP ports). Uses the <code>ss</code> command instead of <code>netstat</code> on Linux.</p> <p>Changed in version 0.7</p> <p>Renamed from <code>port_in_use</code> and added support for macOS.</p> Source code in <code>src/msl/loadlib/utils.py</code> <pre><code>def is_port_in_use(port: int) -&gt; bool:\n    \"\"\"Checks whether the TCP port is in use.\n\n    Args:\n        port: The port number to test.\n\n    Returns:\n        Whether the TCP port is in use.\n\n    !!! note \"Changed in version 0.10\"\n        Only check TCP ports (instead of both TCP and UDP ports).\n        Uses the ``ss`` command instead of ``netstat`` on Linux.\n\n    !!! note \"Changed in version 0.7\"\n        Renamed from `port_in_use` and added support for macOS.\n    \"\"\"\n    flags = 0\n    if IS_WINDOWS:\n        flags = 0x08000000  # fixes issue 31, CREATE_NO_WINDOW = 0x08000000\n        cmd = [\"netstat\", \"-a\", \"-n\", \"-p\", \"TCP\"]\n    elif IS_LINUX:\n        cmd = [\"ss\", \"-ant\"]\n    else:\n        cmd = [\"lsof\", \"-nPw\", \"-iTCP\"]\n    p = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE, creationflags=flags)\n    out, err = p.communicate()\n    if err:\n        raise RuntimeError(err.decode(errors=\"ignore\"))\n    return out.find(b\":%d \" % port) &gt; 0\n</code></pre>"},{"location":"api/utils/#msl.loadlib.utils.is_py4j_installed","title":"is_py4j_installed","text":"<pre><code>is_py4j_installed()\n</code></pre> <p>Checks if <code>py4j</code> is installed.</p> <p>Returns:</p> Type Description <code>bool</code> <p>Whether <code>py4j</code> is installed.</p> <p>Added in version 0.4</p> Source code in <code>src/msl/loadlib/utils.py</code> <pre><code>def is_py4j_installed() -&gt; bool:\n    \"\"\"Checks if `py4j` is installed.\n\n    Returns:\n        Whether `py4j` is installed.\n\n    !!! note \"Added in version 0.4\"\n    \"\"\"\n    try:\n        import py4j\n    except ImportError:\n        return False\n    return True\n</code></pre>"},{"location":"api/utils/#msl.loadlib.utils.is_pythonnet_installed","title":"is_pythonnet_installed","text":"<pre><code>is_pythonnet_installed()\n</code></pre> <p>Checks if <code>pythonnet</code> is installed.</p> <p>Returns:</p> Type Description <code>bool</code> <p>Whether <code>pythonnet</code> is installed.</p> Source code in <code>src/msl/loadlib/utils.py</code> <pre><code>def is_pythonnet_installed() -&gt; bool:\n    \"\"\"Checks if `pythonnet` is installed.\n\n    Returns:\n        Whether `pythonnet` is installed.\n    \"\"\"\n    try:\n        import clr\n    except ImportError:\n        return False\n    return True\n</code></pre>"},{"location":"api/utils/#msl.loadlib.utils.wait_for_server","title":"wait_for_server","text":"<pre><code>wait_for_server(host, port, timeout)\n</code></pre> <p>Wait for the 32-bit server to start.</p> <p>Parameters:</p> Name Type Description Default <code>host</code> <code>str</code> <p>The hostname or IP address of the server.</p> required <code>port</code> <code>int</code> <p>The port number of the server.</p> required <code>timeout</code> <code>float</code> <p>The maximum number of seconds to wait to establish a connection to the server.</p> required <p>Raises:</p> Type Description <code>ConnectionTimeoutError</code> <p>If a timeout occurred.</p> Source code in <code>src/msl/loadlib/utils.py</code> <pre><code>def wait_for_server(host: str, port: int, timeout: float) -&gt; None:\n    \"\"\"Wait for the 32-bit server to start.\n\n    Args:\n        host: The hostname or IP address of the server.\n        port: The port number of the server.\n        timeout: The maximum number of seconds to wait to establish a connection to the server.\n\n    Raises:\n        ConnectionTimeoutError: If a timeout occurred.\n    \"\"\"\n    stop = time.time() + max(0.0, timeout)\n    while True:\n        if is_port_in_use(port):\n            return\n\n        if time.time() &gt; stop:\n            msg = f\"Timeout after {timeout:.1f} second(s). Could not connect to {host}:{port}\"\n            raise ConnectionTimeoutError(msg)\n</code></pre>"},{"location":"examples/","title":"Examples","text":"<p>The following classes illustrate how the Client-Server communication works.</p> <p>Classes that end in 32 contain a class that is a subclass of Server32. This class is a wrapper around a 32-bit library and is hosted on a 32-bit server. Viewing the source code of this class may be useful to see how different data types (e.g., strings, numbers, arrays) are passed between Python and a function in the library.</p> <p>Classes that end in 64 contain a class that is a subclass of Client64. This class sends a request to the corresponding Server32 subclass to communicate with the 32-bit library.</p> <ul> <li>Cpp32</li> <li>Cpp64</li> <li>DotNet32</li> <li>DotNet64</li> <li>Echo32</li> <li>Echo64</li> <li>Fortran32</li> <li>Fortran64</li> <li>Kernel32</li> <li>Kernel64</li> <li>Labview32</li> <li>Labview64</li> </ul>"},{"location":"examples/cpp32/","title":"Cpp32","text":"<p>Wrapper around a 32-bit C++ library.</p> <p>Example of a server that loads a 32-bit library, cpp_lib, in a 32-bit Python interpreter to host the library. The corresponding Cpp64 class is created in a 64-bit Python interpreter and the Cpp64 class sends requests to the Cpp32 class which calls the 32-bit library to execute the request and then returns the response from the library.</p>"},{"location":"examples/cpp32/#msl.examples.loadlib.cpp32.Cpp32","title":"Cpp32","text":"<pre><code>Cpp32(host, port)\n</code></pre> <p>               Bases: <code>Server32</code></p> <p>Wrapper around a 32-bit C++ library.</p> <p>This class demonstrates how to send/receive various data types to/from a 32-bit C++ library via ctypes.</p> <p>Parameters:</p> Name Type Description Default <code>host</code> <code>str</code> <p>The IP address (or hostname) to use for the server.</p> required <code>port</code> <code>int</code> <p>The port to open for the server.</p> required Source code in <code>src/msl/examples/loadlib/cpp32.py</code> <pre><code>def __init__(self, host: str, port: int) -&gt; None:\n    \"\"\"Wrapper around a 32-bit C++ library.\n\n    This class demonstrates how to send/receive various data types to/from a\n    32-bit C++ library via [ctypes][]{:target=\"_blank\"}.\n\n    Args:\n        host: The IP address (or hostname) to use for the server.\n        port: The port to open for the server.\n    \"\"\"\n    # By not specifying the extension of the library file the server will open\n    # the appropriate file based on the operating system.\n    path = Path(__file__).parent / \"cpp_lib32\"\n    super().__init__(path, \"cdll\", host, port)\n</code></pre>"},{"location":"examples/cpp32/#msl.examples.loadlib.cpp32.Cpp32.add","title":"add","text":"<pre><code>add(a, b)\n</code></pre> <p>Add two integers.</p> <p>The corresponding C++ code is</p> <pre><code>int add(int a, int b) {\n    return a + b;\n}\n</code></pre> <p>See the corresponding Cpp64.add method.</p> <p>Parameters:</p> Name Type Description Default <code>a</code> <code>int</code> <p>First integer.</p> required <code>b</code> <code>int</code> <p>Second integer.</p> required <p>Returns:</p> Type Description <code>int</code> <p>The sum, <code>a + b</code>.</p> Source code in <code>src/msl/examples/loadlib/cpp32.py</code> <pre><code>def add(self, a: int, b: int) -&gt; int:\n    \"\"\"Add two integers.\n\n    The corresponding C++ code is\n\n    ```cpp\n    int add(int a, int b) {\n        return a + b;\n    }\n    ```\n\n    See the corresponding [Cpp64.add][msl.examples.loadlib.Cpp64.add] method.\n\n    Args:\n        a: First integer.\n        b: Second integer.\n\n    Returns:\n        The sum, `a + b`.\n    \"\"\"\n    # restype and argtypes should be defined elsewhere, shown here for illustrative purposes\n    self.lib.add.restype = ctypes.c_int32\n    self.lib.add.argtypes = [ctypes.c_int32, ctypes.c_int32]\n    result: int = self.lib.add(a, b)\n    return result\n</code></pre>"},{"location":"examples/cpp32/#msl.examples.loadlib.cpp32.Cpp32.add_or_subtract","title":"add_or_subtract","text":"<pre><code>add_or_subtract(a, b, *, do_addition)\n</code></pre> <p>Add or subtract two double-precision numbers ('double' refers to the C++ data type).</p> <p>The corresponding C++ code is</p> <pre><code>double add_or_subtract(double a, double b, bool do_addition) {\n    if (do_addition) {\n        return a + b;\n    } else {\n        return a - b;\n    }\n}\n</code></pre> <p>See the corresponding Cpp64.add_or_subtract method.</p> <p>Parameters:</p> Name Type Description Default <code>a</code> <code>float</code> <p>First double-precision number.</p> required <code>b</code> <code>float</code> <p>Second double-precision number.</p> required <code>do_addition</code> <code>bool</code> <p>Whether to add or subtract the numbers.</p> required <p>Returns:</p> Type Description <code>float</code> <p><code>a + b</code> if <code>do_addition</code> is <code>True</code> else <code>a - b</code>.</p> Source code in <code>src/msl/examples/loadlib/cpp32.py</code> <pre><code>def add_or_subtract(self, a: float, b: float, *, do_addition: bool) -&gt; float:\n    \"\"\"Add or subtract two double-precision numbers *('double' refers to the C++ data type)*.\n\n    The corresponding C++ code is\n\n    ```cpp\n    double add_or_subtract(double a, double b, bool do_addition) {\n        if (do_addition) {\n            return a + b;\n        } else {\n            return a - b;\n        }\n    }\n    ```\n\n    See the corresponding [Cpp64.add_or_subtract][msl.examples.loadlib.Cpp64.add_or_subtract] method.\n\n    Args:\n        a: First double-precision number.\n        b: Second double-precision number.\n        do_addition: Whether to add or subtract the numbers.\n\n    Returns:\n        `a + b` if `do_addition` is `True` else `a - b`.\n    \"\"\"\n    # restype and argtypes should be defined elsewhere, shown here for illustrative purposes\n    self.lib.add_or_subtract.restype = ctypes.c_double\n    self.lib.add_or_subtract.argtypes = [ctypes.c_double, ctypes.c_double, ctypes.c_bool]\n    result: float = self.lib.add_or_subtract(a, b, do_addition)\n    return result\n</code></pre>"},{"location":"examples/cpp32/#msl.examples.loadlib.cpp32.Cpp32.circumference","title":"circumference","text":"<pre><code>circumference(radius, n)\n</code></pre> <p>Estimates the circumference of a circle.</p> <p>This method calls the <code>distance_n_points</code> function in cpp_lib.</p> <p>The corresponding C++ code uses the NPoints struct as the input parameter to sum the distance between adjacent points on the circle.</p> <pre><code>double distance_n_points(NPoints p) {\n    if (p.n &lt; 2) {\n        return 0.0;\n    }\n    double d = distance(p.points[0], p.points[p.n-1]);\n    for (int i = 1; i &lt; p.n; i++) {\n        d += distance(p.points[i], p.points[i-1]);\n    }\n    return d;\n}\n</code></pre> <p>See the corresponding Cpp64.circumference method.</p> <p>Parameters:</p> Name Type Description Default <code>radius</code> <code>float</code> <p>The radius of the circle.</p> required <code>n</code> <code>int</code> <p>The number of points to use to estimate the circumference.</p> required <p>Returns:</p> Type Description <code>float</code> <p>The estimated circumference of the circle.</p> Source code in <code>src/msl/examples/loadlib/cpp32.py</code> <pre><code>def circumference(self, radius: float, n: int) -&gt; float:\n    \"\"\"Estimates the circumference of a circle.\n\n    This method calls the `distance_n_points` function in [cpp_lib][cpp-lib].\n\n    The corresponding C++ code uses the [NPoints][msl.examples.loadlib.cpp32.NPoints]\n    struct as the input parameter to sum the distance between adjacent points on the circle.\n\n    ```cpp\n    double distance_n_points(NPoints p) {\n        if (p.n &lt; 2) {\n            return 0.0;\n        }\n        double d = distance(p.points[0], p.points[p.n-1]);\n        for (int i = 1; i &lt; p.n; i++) {\n            d += distance(p.points[i], p.points[i-1]);\n        }\n        return d;\n    }\n    ```\n\n    See the corresponding [Cpp64.circumference][msl.examples.loadlib.Cpp64.circumference] method.\n\n    Args:\n        radius: The radius of the circle.\n        n: The number of points to use to estimate the circumference.\n\n    Returns:\n        The estimated circumference of the circle.\n    \"\"\"\n    # restype and argtypes should be defined elsewhere, shown here for illustrative purposes\n    self.lib.distance_n_points.restype = ctypes.c_double\n    self.lib.distance_n_points.argtypes = [NPoints]\n\n    theta = 0.0\n    delta = (2.0 * math.pi) / float(n) if n != 0 else 0\n\n    pts = NPoints()\n    pts.n = n\n    pts.points = (Point * n)()\n    for i in range(n):\n        pts.points[i] = Point(radius * math.cos(theta), radius * math.sin(theta))\n        theta += delta\n    result: float = self.lib.distance_n_points(pts)\n    return result\n</code></pre>"},{"location":"examples/cpp32/#msl.examples.loadlib.cpp32.Cpp32.distance_4_points","title":"distance_4_points","text":"<pre><code>distance_4_points(four_points)\n</code></pre> <p>Calculates the total distance connecting 4 Points.</p> <p>The corresponding C++ code is</p> <pre><code>double distance_4_points(FourPoints p) {\n    double d = distance(p.points[0], p.points[3]);\n    for (int i = 1; i &lt; 4; i++) {\n        d += distance(p.points[i], p.points[i-1]);\n    }\n    return d;\n}\n</code></pre> <p>See the corresponding Cpp64.distance_4_points method.</p> <p>Parameters:</p> Name Type Description Default <code>four_points</code> <code>FourPoints</code> <p>The points to use to calculate the total distance.</p> required <p>Returns:</p> Type Description <code>float</code> <p>The total distance connecting the 4 points.</p> Source code in <code>src/msl/examples/loadlib/cpp32.py</code> <pre><code>def distance_4_points(self, four_points: FourPoints) -&gt; float:\n    \"\"\"Calculates the total distance connecting 4 [Point][msl.examples.loadlib.cpp32.Point]s.\n\n    The corresponding C++ code is\n\n    ```cpp\n    double distance_4_points(FourPoints p) {\n        double d = distance(p.points[0], p.points[3]);\n        for (int i = 1; i &lt; 4; i++) {\n            d += distance(p.points[i], p.points[i-1]);\n        }\n        return d;\n    }\n    ```\n\n    See the corresponding [Cpp64.distance_4_points][msl.examples.loadlib.Cpp64.distance_4_points] method.\n\n    Args:\n        four_points: The points to use to calculate the total distance.\n\n    Returns:\n        The total distance connecting the 4 points.\n    \"\"\"\n    # restype should be defined elsewhere, shown here for illustrative purposes\n    self.lib.distance_4_points.restype = ctypes.c_double\n    result: float = self.lib.distance_4_points(four_points)\n    return result\n</code></pre>"},{"location":"examples/cpp32/#msl.examples.loadlib.cpp32.Cpp32.reverse_string_v1","title":"reverse_string_v1","text":"<pre><code>reverse_string_v1(original)\n</code></pre> <p>Reverse a string (version 1).</p> <p>In this method Python allocates the memory for the reversed string and passes the string to C++.</p> <p>The corresponding C++ code is</p> <pre><code>void reverse_string_v1(const char* original, int n, char* reversed) {\n    for (int i = 0; i &lt; n; i++) {\n        reversed[i] = original[n-i-1];\n    }\n}\n</code></pre> <p>See the corresponding Cpp64.reverse_string_v1 method.</p> <p>Parameters:</p> Name Type Description Default <code>original</code> <code>str</code> <p>The original string.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The string reversed.</p> Source code in <code>src/msl/examples/loadlib/cpp32.py</code> <pre><code>def reverse_string_v1(self, original: str) -&gt; str:\n    \"\"\"Reverse a string (version 1).\n\n    In this method Python allocates the memory for the reversed string and\n    passes the string to C++.\n\n    The corresponding C++ code is\n\n    ```cpp\n    void reverse_string_v1(const char* original, int n, char* reversed) {\n        for (int i = 0; i &lt; n; i++) {\n            reversed[i] = original[n-i-1];\n        }\n    }\n    ```\n\n    See the corresponding [Cpp64.reverse_string_v1][msl.examples.loadlib.Cpp64.reverse_string_v1] method.\n\n    Args:\n        original: The original string.\n\n    Returns:\n        The string reversed.\n    \"\"\"\n    # restype and argtypes should be defined elsewhere, shown here for illustrative purposes\n    self.lib.reverse_string_v1.restype = None\n    self.lib.reverse_string_v1.argtypes = [ctypes.c_char_p, ctypes.c_int32, ctypes.c_char_p]\n\n    n = len(original)\n    rev = ctypes.create_string_buffer(n)\n    self.lib.reverse_string_v1(original.encode(), n, rev)\n    return rev.raw.decode()\n</code></pre>"},{"location":"examples/cpp32/#msl.examples.loadlib.cpp32.Cpp32.reverse_string_v2","title":"reverse_string_v2","text":"<pre><code>reverse_string_v2(original)\n</code></pre> <p>Reverse a string (version 2).</p> <p>In this method C++ allocates the memory for the reversed string and passes the string to Python.</p> <p>The corresponding C++ code is</p> <pre><code>char* reverse_string_v2(char* original, int n) {\n    char* reversed = new char[n];\n    for (int i = 0; i &lt; n; i++) {\n        reversed[i] = original[n - i - 1];\n    }\n    return reversed;\n}\n</code></pre> <p>See the corresponding Cpp64.reverse_string_v2 method.</p> <p>Parameters:</p> Name Type Description Default <code>original</code> <code>str</code> <p>The original string.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The string reversed.</p> Source code in <code>src/msl/examples/loadlib/cpp32.py</code> <pre><code>def reverse_string_v2(self, original: str) -&gt; str:\n    \"\"\"Reverse a string (version 2).\n\n    In this method C++ allocates the memory for the reversed string and passes\n    the string to Python.\n\n    The corresponding C++ code is\n\n    ```cpp\n    char* reverse_string_v2(char* original, int n) {\n        char* reversed = new char[n];\n        for (int i = 0; i &lt; n; i++) {\n            reversed[i] = original[n - i - 1];\n        }\n        return reversed;\n    }\n    ```\n\n    See the corresponding [Cpp64.reverse_string_v2][msl.examples.loadlib.Cpp64.reverse_string_v2] method.\n\n    Args:\n        original: The original string.\n\n    Returns:\n        The string reversed.\n    \"\"\"\n    # restype and argtypes should be defined elsewhere, shown here for illustrative purposes\n    self.lib.reverse_string_v2.restype = ctypes.c_char_p\n    self.lib.reverse_string_v2.argtypes = [ctypes.c_char_p, ctypes.c_int32]\n\n    n = len(original)\n    rev = self.lib.reverse_string_v2(original.encode(), n)\n    return ctypes.string_at(rev, n).decode()\n</code></pre>"},{"location":"examples/cpp32/#msl.examples.loadlib.cpp32.Cpp32.scalar_multiply","title":"scalar_multiply","text":"<pre><code>scalar_multiply(a, xin)\n</code></pre> <p>Multiply each element in an array by a number.</p> <p>The corresponding C++ code is</p> <pre><code>void scalar_multiply(double a, double* xin, int n, double* xout) {\n    for (int i = 0; i &lt; n; i++) {\n        xout[i] = a * xin[i];\n    }\n}\n</code></pre> <p>See the corresponding Cpp64.scalar_multiply method.</p> <p>Parameters:</p> Name Type Description Default <code>a</code> <code>float</code> <p>Scalar value.</p> required <code>xin</code> <code>Sequence[float]</code> <p>Array to modify.</p> required <p>Returns:</p> Type Description <code>list[float]</code> <p>A new array with each element in <code>xin</code> multiplied by <code>a</code>.</p> Source code in <code>src/msl/examples/loadlib/cpp32.py</code> <pre><code>def scalar_multiply(self, a: float, xin: Sequence[float]) -&gt; list[float]:\n    \"\"\"Multiply each element in an array by a number.\n\n    The corresponding C++ code is\n\n    ```cpp\n    void scalar_multiply(double a, double* xin, int n, double* xout) {\n        for (int i = 0; i &lt; n; i++) {\n            xout[i] = a * xin[i];\n        }\n    }\n    ```\n\n    See the corresponding [Cpp64.scalar_multiply][msl.examples.loadlib.Cpp64.scalar_multiply] method.\n\n    Args:\n        a: Scalar value.\n        xin: Array to modify.\n\n    Returns:\n        A new array with each element in `xin` multiplied by `a`.\n    \"\"\"\n    # restype and argtypes should be defined elsewhere, shown here for illustrative purposes\n    self.lib.scalar_multiply.restype = None\n    self.lib.scalar_multiply.argtypes = [\n        ctypes.c_double,\n        ctypes.POINTER(ctypes.c_double),\n        ctypes.c_int32,\n        ctypes.POINTER(ctypes.c_double),\n    ]\n\n    n = len(xin)\n    c_xin = (ctypes.c_double * n)(*xin)  # convert input array to ctypes\n    c_xout = (ctypes.c_double * n)()  # allocate memory for output array\n    self.lib.scalar_multiply(a, c_xin, n, c_xout)\n    return list(c_xout)\n</code></pre>"},{"location":"examples/cpp32/#msl.examples.loadlib.cpp32.Cpp32.subtract","title":"subtract","text":"<pre><code>subtract(a, b)\n</code></pre> <p>Subtract two floating-point numbers ('float' refers to the C++ data type).</p> <p>The corresponding C++ code is</p> <pre><code>float subtract(float a, float b) {\n    return a - b;\n}\n</code></pre> <p>See the corresponding Cpp64.subtract method.</p> <p>Parameters:</p> Name Type Description Default <code>a</code> <code>float</code> <p>First floating-point number.</p> required <code>b</code> <code>float</code> <p>Second floating-point number.</p> required <p>Returns:</p> Type Description <code>float</code> <p>The difference, <code>a - b</code>.</p> Source code in <code>src/msl/examples/loadlib/cpp32.py</code> <pre><code>def subtract(self, a: float, b: float) -&gt; float:\n    \"\"\"Subtract two floating-point numbers *('float' refers to the C++ data type)*.\n\n    The corresponding C++ code is\n\n    ```cpp\n    float subtract(float a, float b) {\n        return a - b;\n    }\n    ```\n\n    See the corresponding [Cpp64.subtract][msl.examples.loadlib.Cpp64.subtract] method.\n\n    Args:\n        a: First floating-point number.\n        b: Second floating-point number.\n\n    Returns:\n        The difference, `a - b`.\n    \"\"\"\n    # restype and argtypes should be defined elsewhere, shown here for illustrative purposes\n    self.lib.subtract.restype = ctypes.c_float\n    self.lib.subtract.argtypes = [ctypes.c_float, ctypes.c_float]\n    result: float = self.lib.subtract(a, b)\n    return result\n</code></pre>"},{"location":"examples/cpp32/#msl.examples.loadlib.cpp32.FourPoints","title":"FourPoints","text":"<pre><code>FourPoints(point1, point2, point3, point4)\n</code></pre> <p>               Bases: <code>Structure</code></p> <p>C++ struct that is a fixed size in memory.</p> <p>This object can be pickled.</p> <pre><code>struct FourPoints {\n    Point points[4];\n};\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>point1</code> <code>Point</code> <p>The first point.</p> required <code>point2</code> <code>Point</code> <p>The second point.</p> required <code>point3</code> <code>Point</code> <p>The third point.</p> required <code>point4</code> <code>Point</code> <p>The fourth point.</p> required Source code in <code>src/msl/examples/loadlib/cpp32.py</code> <pre><code>def __init__(self, point1: Point, point2: Point, point3: Point, point4: Point) -&gt; None:\n    \"\"\"C++ struct that is a fixed size in memory.\n\n    This object can be [pickle][]{:target=\"_blank\"}d.\n\n    ```cpp\n    struct FourPoints {\n        Point points[4];\n    };\n    ```\n\n    Args:\n        point1: The first point.\n        point2: The second point.\n        point3: The third point.\n        point4: The fourth point.\n    \"\"\"\n    super().__init__()\n    self.points: Array[Point] = (Point * 4)(point1, point2, point3, point4)\n</code></pre>"},{"location":"examples/cpp32/#msl.examples.loadlib.cpp32.NPoints","title":"NPoints","text":"<p>               Bases: <code>Structure</code></p> <p>C++ struct that is not a fixed size in memory.</p> <p>This object cannot be pickled because it contains a pointer. A 32-bit process and a 64-bit process cannot share a pointer.</p> <pre><code>struct NPoints {\n    int n;\n    Point *points;\n};\n</code></pre>"},{"location":"examples/cpp32/#msl.examples.loadlib.cpp32.Point","title":"Point","text":"<p>               Bases: <code>Structure</code></p> <p>C++ struct that is a fixed size in memory.</p> <p>This object can be pickled.</p> <pre><code>struct Point {\n    double x;\n    double y;\n};\n</code></pre>"},{"location":"examples/cpp64/","title":"Cpp64","text":"<p>Communicates with the cpp_lib library via the Cpp32 class that is running on a server.</p>"},{"location":"examples/cpp64/#msl.examples.loadlib.cpp64.Cpp64","title":"Cpp64","text":"<pre><code>Cpp64()\n</code></pre> <p>               Bases: <code>Client64</code></p> <p>Communicates with a 32-bit C++ library.</p> <p>This class demonstrates how to communicate with a 32-bit C++ library if an instance of this class is created within a 64-bit Python interpreter.</p> Source code in <code>src/msl/examples/loadlib/cpp64.py</code> <pre><code>def __init__(self) -&gt; None:\n    \"\"\"Communicates with a 32-bit C++ library via the server running [Cpp32][].\n\n    This class demonstrates how to communicate with a 32-bit C++ library if an\n    instance of this class is created within a 64-bit Python interpreter.\n    \"\"\"\n    # specify the name of the corresponding 32-bit server module, cpp32,\n    # which hosts the 32-bit C++ library -- cpp_lib32.\n    super().__init__(\"cpp32\", append_sys_path=Path(__file__).parent)\n</code></pre>"},{"location":"examples/cpp64/#msl.examples.loadlib.cpp64.Cpp64.add","title":"add","text":"<pre><code>add(a, b)\n</code></pre> <p>Add two integers.</p> <p>See the corresponding Cpp32.add method.</p> <p>Parameters:</p> Name Type Description Default <code>a</code> <code>int</code> <p>First integer.</p> required <code>b</code> <code>int</code> <p>Second integer.</p> required <p>Returns:</p> Type Description <code>int</code> <p>The sum, <code>a + b</code>.</p> Source code in <code>src/msl/examples/loadlib/cpp64.py</code> <pre><code>def add(self, a: int, b: int) -&gt; int:\n    \"\"\"Add two integers.\n\n    See the corresponding [Cpp32.add][msl.examples.loadlib.cpp32.Cpp32.add] method.\n\n    Args:\n        a: First integer.\n        b: Second integer.\n\n    Returns:\n        The sum, `a + b`.\n    \"\"\"\n    reply: int = self.request32(\"add\", a, b)\n    return reply\n</code></pre>"},{"location":"examples/cpp64/#msl.examples.loadlib.cpp64.Cpp64.add_or_subtract","title":"add_or_subtract","text":"<pre><code>add_or_subtract(a, b, *, do_addition)\n</code></pre> <p>Add or subtract two floating-point numbers ('double' refers to the C++ data type).</p> <p>See the corresponding Cpp32.add_or_subtract method.</p> <p>Parameters:</p> Name Type Description Default <code>a</code> <code>float</code> <p>First double-precision number.</p> required <code>b</code> <code>float</code> <p>Second double-precision number.</p> required <code>do_addition</code> <code>bool</code> <p>Whether to add or subtract the numbers.</p> required <p>Returns:</p> Type Description <code>float</code> <p><code>a + b</code> if <code>do_addition</code> is <code>True</code> else <code>a - b</code>.</p> Source code in <code>src/msl/examples/loadlib/cpp64.py</code> <pre><code>def add_or_subtract(self, a: float, b: float, *, do_addition: bool) -&gt; float:\n    \"\"\"Add or subtract two floating-point numbers *('double' refers to the C++ data type)*.\n\n    See the corresponding [Cpp32.add_or_subtract][msl.examples.loadlib.cpp32.Cpp32.add_or_subtract] method.\n\n    Args:\n        a: First double-precision number.\n        b: Second double-precision number.\n        do_addition: Whether to add or subtract the numbers.\n\n    Returns:\n        `a + b` if `do_addition` is `True` else `a - b`.\n    \"\"\"\n    reply: float = self.request32(\"add_or_subtract\", a, b, do_addition=do_addition)\n    return reply\n</code></pre>"},{"location":"examples/cpp64/#msl.examples.loadlib.cpp64.Cpp64.circumference","title":"circumference","text":"<pre><code>circumference(radius, n)\n</code></pre> <p>Estimates the circumference of a circle.</p> <p>This method calls the <code>distance_n_points</code> function in cpp_lib.</p> <p>See the corresponding Cpp32.circumference method.</p> <p>Parameters:</p> Name Type Description Default <code>radius</code> <code>float</code> <p>The radius of the circle.</p> required <code>n</code> <code>int</code> <p>The number of points to use to estimate the circumference.</p> required <p>Returns:</p> Type Description <code>float</code> <p>The estimated circumference of the circle.</p> Source code in <code>src/msl/examples/loadlib/cpp64.py</code> <pre><code>def circumference(self, radius: float, n: int) -&gt; float:\n    \"\"\"Estimates the circumference of a circle.\n\n    This method calls the `distance_n_points` function in [cpp_lib][cpp-lib].\n\n    See the corresponding [Cpp32.circumference][msl.examples.loadlib.cpp32.Cpp32.circumference] method.\n\n    Args:\n        radius: The radius of the circle.\n        n: The number of points to use to estimate the circumference.\n\n    Returns:\n        The estimated circumference of the circle.\n    \"\"\"\n    reply: float = self.request32(\"circumference\", radius, n)\n    return reply\n</code></pre>"},{"location":"examples/cpp64/#msl.examples.loadlib.cpp64.Cpp64.distance_4_points","title":"distance_4_points","text":"<pre><code>distance_4_points(points)\n</code></pre> <p>Calculates the total distance connecting 4 Points.</p> <p>See the corresponding Cpp32.distance_4_points method.</p> <p>Parameters:</p> Name Type Description Default <code>points</code> <code>FourPoints</code> <p>The points to use to calculate the total distance. Since <code>points</code> is a struct that is a fixed size we can pass the ctypes.Structure object directly from 64-bit Python to the 32-bit Python. The ctypes module on the 32-bit server can load the pickled ctypes.Structure.</p> required <p>Returns:</p> Type Description <code>float</code> <p>The total distance connecting the 4 points.</p> Source code in <code>src/msl/examples/loadlib/cpp64.py</code> <pre><code>def distance_4_points(self, points: FourPoints) -&gt; float:\n    \"\"\"Calculates the total distance connecting 4 [Point][msl.examples.loadlib.cpp32.Point]s.\n\n    See the corresponding [Cpp32.distance_4_points][msl.examples.loadlib.cpp32.Cpp32.distance_4_points] method.\n\n    Args:\n        points: The points to use to calculate the total distance.\n            Since `points` is a struct that is a fixed size we can pass the\n            [ctypes.Structure][]{:target=\"_blank\"} object directly from 64-bit Python to\n            the 32-bit Python. The [ctypes][]{:target=\"_blank\"} module on the 32-bit server\n            can load the [pickle][]{:target=\"_blank\"}d [ctypes.Structure][]{:target=\"_blank\"}.\n\n    Returns:\n        The total distance connecting the 4 points.\n    \"\"\"\n    reply: float = self.request32(\"distance_4_points\", points)\n    return reply\n</code></pre>"},{"location":"examples/cpp64/#msl.examples.loadlib.cpp64.Cpp64.reverse_string_v1","title":"reverse_string_v1","text":"<pre><code>reverse_string_v1(original)\n</code></pre> <p>Reverse a string (version 1).</p> <p>In this method Python allocates the memory for the reversed string and passes the string to C++.</p> <p>See the corresponding Cpp32.reverse_string_v1 method.</p> <p>Parameters:</p> Name Type Description Default <code>original</code> <code>str</code> <p>The original string.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The string reversed.</p> Source code in <code>src/msl/examples/loadlib/cpp64.py</code> <pre><code>def reverse_string_v1(self, original: str) -&gt; str:\n    \"\"\"Reverse a string (version 1).\n\n    In this method Python allocates the memory for the reversed string\n    and passes the string to C++.\n\n    See the corresponding [Cpp32.reverse_string_v1][msl.examples.loadlib.cpp32.Cpp32.reverse_string_v1] method.\n\n    Args:\n        original: The original string.\n\n    Returns:\n        The string reversed.\n    \"\"\"\n    reply: str = self.request32(\"reverse_string_v1\", original)\n    return reply\n</code></pre>"},{"location":"examples/cpp64/#msl.examples.loadlib.cpp64.Cpp64.reverse_string_v2","title":"reverse_string_v2","text":"<pre><code>reverse_string_v2(original)\n</code></pre> <p>Reverse a string (version 2).</p> <p>In this method C++ allocates the memory for the reversed string and passes the string to Python.</p> <p>See the corresponding Cpp32.reverse_string_v2 method.</p> <p>Parameters:</p> Name Type Description Default <code>original</code> <code>str</code> <p>The original string.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The string reversed.</p> Source code in <code>src/msl/examples/loadlib/cpp64.py</code> <pre><code>def reverse_string_v2(self, original: str) -&gt; str:\n    \"\"\"Reverse a string (version 2).\n\n    In this method C++ allocates the memory for the reversed string and passes\n    the string to Python.\n\n    See the corresponding [Cpp32.reverse_string_v2][msl.examples.loadlib.cpp32.Cpp32.reverse_string_v2] method.\n\n    Args:\n        original: The original string.\n\n    Returns:\n        The string reversed.\n    \"\"\"\n    reply: str = self.request32(\"reverse_string_v2\", original)\n    return reply\n</code></pre>"},{"location":"examples/cpp64/#msl.examples.loadlib.cpp64.Cpp64.scalar_multiply","title":"scalar_multiply","text":"<pre><code>scalar_multiply(a, xin)\n</code></pre> <p>Multiply each element in an array by a number.</p> <p>See the corresponding Cpp32.scalar_multiply method.</p> <p>Parameters:</p> Name Type Description Default <code>a</code> <code>float</code> <p>Scalar value.</p> required <code>xin</code> <code>Sequence[float]</code> <p>Array to modify.</p> required <p>Returns:</p> Type Description <code>list[float]</code> <p>A new array with each element in <code>xin</code> multiplied by <code>a</code>.</p> Source code in <code>src/msl/examples/loadlib/cpp64.py</code> <pre><code>def scalar_multiply(self, a: float, xin: Sequence[float]) -&gt; list[float]:\n    \"\"\"Multiply each element in an array by a number.\n\n    See the corresponding [Cpp32.scalar_multiply][msl.examples.loadlib.cpp32.Cpp32.scalar_multiply] method.\n\n    Args:\n        a: Scalar value.\n        xin: Array to modify.\n\n    Returns:\n        A new array with each element in `xin` multiplied by `a`.\n    \"\"\"\n    reply: list[float] = self.request32(\"scalar_multiply\", a, xin)\n    return reply\n</code></pre>"},{"location":"examples/cpp64/#msl.examples.loadlib.cpp64.Cpp64.subtract","title":"subtract","text":"<pre><code>subtract(a, b)\n</code></pre> <p>Subtract two floating-point numbers ('float' refers to the C++ data type).</p> <p>See the corresponding Cpp32.subtract method.</p> <p>Parameters:</p> Name Type Description Default <code>a</code> <code>float</code> <p>First floating-point number.</p> required <code>b</code> <code>float</code> <p>Second floating-point number.</p> required <p>Returns:</p> Type Description <code>float</code> <p>The difference, <code>a - b</code>.</p> Source code in <code>src/msl/examples/loadlib/cpp64.py</code> <pre><code>def subtract(self, a: float, b: float) -&gt; float:\n    \"\"\"Subtract two floating-point numbers *('float' refers to the C++ data type)*.\n\n    See the corresponding [Cpp32.subtract][msl.examples.loadlib.cpp32.Cpp32.subtract] method.\n\n    Args:\n        a: First floating-point number.\n        b: Second floating-point number.\n\n    Returns:\n        The difference, `a - b`.\n    \"\"\"\n    reply: float = self.request32(\"subtract\", a, b)\n    return reply\n</code></pre>"},{"location":"examples/dotnet32/","title":"DotNet32","text":"<p>Wrapper around a 32-bit .NET library.</p> <p>Example of a server that loads a 32-bit library, dotnet_lib32.dll, in a 32-bit Python interpreter to host the library. The corresponding DotNet64 class is created in a 64-bit Python interpreter and the DotNet64 class sends requests to the DotNet32 class which calls the 32-bit library to execute the request and then returns the response from the library.</p>"},{"location":"examples/dotnet32/#msl.examples.loadlib.dotnet32.DotNet32","title":"DotNet32","text":"<pre><code>DotNet32(host, port)\n</code></pre> <p>               Bases: <code>Server32</code></p> <p>Wrapper around a 32-bit .NET library.</p> <p>Python.NET can handle many native Python data types as input arguments.</p> <p>Parameters:</p> Name Type Description Default <code>host</code> <code>str</code> <p>The IP address (or hostname) to use for the server.</p> required <code>port</code> <code>int</code> <p>The port to open for the server.</p> required Source code in <code>src/msl/examples/loadlib/dotnet32.py</code> <pre><code>def __init__(self, host: str, port: int) -&gt; None:\n    \"\"\"Wrapper around a 32-bit .NET library.\n\n    [Python.NET](https://pythonnet.github.io/){:target=\"_blank\"}\n    can handle many native Python data types as input arguments.\n\n    Args:\n        host: The IP address (or hostname) to use for the server.\n        port: The port to open for the server.\n    \"\"\"\n    path = Path(__file__).parent / \"dotnet_lib32.dll\"\n    super().__init__(path, \"net\", host, port)\n\n    self.BasicMath = self.lib.DotNetMSL.BasicMath()\n    self.ArrayManipulation = self.lib.DotNetMSL.ArrayManipulation()\n</code></pre>"},{"location":"examples/dotnet32/#msl.examples.loadlib.dotnet32.DotNet32.add_integers","title":"add_integers","text":"<pre><code>add_integers(a, b)\n</code></pre> <p>Add two integers.</p> <p>The corresponding C# code is</p> <pre><code>public int add_integers(int a, int b)\n{\n    return a + b;\n}\n</code></pre> <p>See the corresponding DotNet64.add_integers method.</p> <p>Parameters:</p> Name Type Description Default <code>a</code> <code>int</code> <p>First integer.</p> required <code>b</code> <code>int</code> <p>Second integer.</p> required <p>Returns:</p> Type Description <code>int</code> <p>The sum, <code>a + b</code>.</p> Source code in <code>src/msl/examples/loadlib/dotnet32.py</code> <pre><code>def add_integers(self, a: int, b: int) -&gt; int:\n    \"\"\"Add two integers.\n\n    The corresponding C# code is\n\n    ```csharp\n    public int add_integers(int a, int b)\n    {\n        return a + b;\n    }\n    ```\n\n    See the corresponding [DotNet64.add_integers][msl.examples.loadlib.dotnet64.DotNet64.add_integers] method.\n\n    Args:\n        a: First integer.\n        b: Second integer.\n\n    Returns:\n        The sum, `a + b`.\n    \"\"\"\n    result: int = self.BasicMath.add_integers(a, b)\n    return result\n</code></pre>"},{"location":"examples/dotnet32/#msl.examples.loadlib.dotnet32.DotNet32.add_multiple","title":"add_multiple","text":"<pre><code>add_multiple(a, b, c, d, e)\n</code></pre> <p>Add multiple integers.</p> <p>Calls a static method in a static class.</p> <p>The corresponding C# code is</p> <pre><code>public static int add_multiple(int a, int b, int c, int d, int e)\n{\n    return a + b + c + d + e;\n}\n</code></pre> <p>See the corresponding DotNet64.add_multiple method.</p> <p>Parameters:</p> Name Type Description Default <code>a</code> <code>int</code> <p>First integer.</p> required <code>b</code> <code>int</code> <p>Second integer.</p> required <code>c</code> <code>int</code> <p>Third integer.</p> required <code>d</code> <code>int</code> <p>Fourth integer.</p> required <code>e</code> <code>int</code> <p>Fifth integer.</p> required <p>Returns:</p> Type Description <code>int</code> <p>The sum of the input arguments.</p> Source code in <code>src/msl/examples/loadlib/dotnet32.py</code> <pre><code>def add_multiple(self, a: int, b: int, c: int, d: int, e: int) -&gt; int:\n    \"\"\"Add multiple integers.\n\n    Calls a static method in a static class.\n\n    The corresponding C# code is\n\n    ```csharp\n    public static int add_multiple(int a, int b, int c, int d, int e)\n    {\n        return a + b + c + d + e;\n    }\n    ```\n\n    See the corresponding [DotNet64.add_multiple][msl.examples.loadlib.dotnet64.DotNet64.add_multiple] method.\n\n    Args:\n        a: First integer.\n        b: Second integer.\n        c: Third integer.\n        d: Fourth integer.\n        e: Fifth integer.\n\n    Returns:\n        The sum of the input arguments.\n    \"\"\"\n    result: int = self.lib.StaticClass.add_multiple(a, b, c, d, e)\n    return result\n</code></pre>"},{"location":"examples/dotnet32/#msl.examples.loadlib.dotnet32.DotNet32.add_or_subtract","title":"add_or_subtract","text":"<pre><code>add_or_subtract(a, b, *, do_addition)\n</code></pre> <p>Add or subtract two C# double-precision numbers.</p> <p>The corresponding C# code is</p> <pre><code>public double add_or_subtract(double a, double b, bool do_addition)\n{\n    if (do_addition)\n    {\n        return a + b;\n    }\n    else\n    {\n        return a - b;\n    }\n}\n</code></pre> <p>See the corresponding DotNet64.add_or_subtract method.</p> <p>Parameters:</p> Name Type Description Default <code>a</code> <code>float</code> <p>First double-precision number.</p> required <code>b</code> <code>float</code> <p>Second double-precision number.</p> required <code>do_addition</code> <code>bool</code> <p>Whether to add or subtract the numbers.</p> required <p>Returns:</p> Type Description <code>float</code> <p><code>a + b</code> if <code>do_addition</code> is <code>True</code> else <code>a - b</code>.</p> Source code in <code>src/msl/examples/loadlib/dotnet32.py</code> <pre><code>def add_or_subtract(self, a: float, b: float, *, do_addition: bool) -&gt; float:\n    \"\"\"Add or subtract two C# double-precision numbers.\n\n    The corresponding C# code is\n\n    ```csharp\n    public double add_or_subtract(double a, double b, bool do_addition)\n    {\n        if (do_addition)\n        {\n            return a + b;\n        }\n        else\n        {\n            return a - b;\n        }\n    }\n    ```\n\n    See the corresponding [DotNet64.add_or_subtract][msl.examples.loadlib.dotnet64.DotNet64.add_or_subtract] method.\n\n    Args:\n        a: First double-precision number.\n        b: Second double-precision number.\n        do_addition: Whether to add or subtract the numbers.\n\n    Returns:\n        `a + b` if `do_addition` is `True` else `a - b`.\n    \"\"\"\n    result: float = self.BasicMath.add_or_subtract(a, b, do_addition=do_addition)\n    return result\n</code></pre>"},{"location":"examples/dotnet32/#msl.examples.loadlib.dotnet32.DotNet32.concatenate","title":"concatenate","text":"<pre><code>concatenate(a, b, c, d, e)\n</code></pre> <p>Concatenate strings.</p> <p>Calls a static method in a static class.</p> <p>The corresponding C# code is</p> <pre><code>public static string concatenate(string a, string b, string c, bool d, string e)\n{\n    string res = a + b + c;\n    if (d)\n    {\n        res += e;\n    }\n    return res;\n}\n</code></pre> <p>See the corresponding DotNet64.concatenate method.</p> <p>Parameters:</p> Name Type Description Default <code>a</code> <code>str</code> <p>First string.</p> required <code>b</code> <code>str</code> <p>Second string.</p> required <code>c</code> <code>str</code> <p>Third string.</p> required <code>d</code> <code>bool</code> <p>Whether to include <code>e</code> in the concatenation.</p> required <code>e</code> <code>str</code> <p>Fourth string.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The strings concatenated together.</p> Source code in <code>src/msl/examples/loadlib/dotnet32.py</code> <pre><code>def concatenate(self, a: str, b: str, c: str, d: bool, e: str) -&gt; str:  # noqa: FBT001\n    \"\"\"Concatenate strings.\n\n    Calls a static method in a static class.\n\n    The corresponding C# code is\n\n    ```csharp\n    public static string concatenate(string a, string b, string c, bool d, string e)\n    {\n        string res = a + b + c;\n        if (d)\n        {\n            res += e;\n        }\n        return res;\n    }\n    ```\n\n    See the corresponding [DotNet64.concatenate][msl.examples.loadlib.dotnet64.DotNet64.concatenate] method.\n\n    Args:\n        a: First string.\n        b: Second string.\n        c: Third string.\n        d: Whether to include `e` in the concatenation.\n        e: Fourth string.\n\n    Returns:\n        The strings concatenated together.\n    \"\"\"\n    result: str = self.lib.StaticClass.concatenate(a, b, c, d, e)\n    return result\n</code></pre>"},{"location":"examples/dotnet32/#msl.examples.loadlib.dotnet32.DotNet32.divide_floats","title":"divide_floats","text":"<pre><code>divide_floats(a, b)\n</code></pre> <p>Divide two C# floating-point numbers.</p> <p>The corresponding C# code is</p> <pre><code>public float divide_floats(float a, float b)\n{\n    return a / b;\n}\n</code></pre> <p>See the corresponding DotNet64.divide_floats method.</p> <p>Parameters:</p> Name Type Description Default <code>a</code> <code>float</code> <p>The numerator.</p> required <code>b</code> <code>float</code> <p>The denominator.</p> required <p>Returns:</p> Type Description <code>float</code> <p>The quotient, <code>a / b</code>.</p> Source code in <code>src/msl/examples/loadlib/dotnet32.py</code> <pre><code>def divide_floats(self, a: float, b: float) -&gt; float:\n    \"\"\"Divide two C# floating-point numbers.\n\n    The corresponding C# code is\n\n    ```csharp\n    public float divide_floats(float a, float b)\n    {\n        return a / b;\n    }\n    ```\n\n    See the corresponding [DotNet64.divide_floats][msl.examples.loadlib.dotnet64.DotNet64.divide_floats] method.\n\n    Args:\n        a: The numerator.\n        b: The denominator.\n\n    Returns:\n        The quotient, `a / b`.\n    \"\"\"\n    result: float = self.BasicMath.divide_floats(a, b)\n    return result\n</code></pre>"},{"location":"examples/dotnet32/#msl.examples.loadlib.dotnet32.DotNet32.get_class_names","title":"get_class_names","text":"<pre><code>get_class_names()\n</code></pre> <p>Gets the class names in the library.</p> <p>Calls GetTypes using the assembly property.</p> <p>See the corresponding DotNet64.get_class_names method.</p> <p>Returns:</p> Type Description <code>list[str]</code> <p>The names of the classes that are available in dotnet_lib32.dll.</p> Source code in <code>src/msl/examples/loadlib/dotnet32.py</code> <pre><code>def get_class_names(self) -&gt; list[str]:\n    \"\"\"Gets the class names in the library.\n\n    Calls [GetTypes](https://learn.microsoft.com/en-us/dotnet/api/system.reflection.assembly.gettypes){:target=\"_blank\"}\n    using the [assembly][msl.loadlib.load_library.LoadLibrary.assembly] property.\n\n    See the corresponding [DotNet64.get_class_names][msl.examples.loadlib.dotnet64.DotNet64.get_class_names] method.\n\n    Returns:\n        The names of the classes that are available in [dotnet_lib32.dll][dotnet-lib].\n    \"\"\"\n    return \";\".join(str(name) for name in self.assembly.GetTypes()).split(\";\")\n</code></pre>"},{"location":"examples/dotnet32/#msl.examples.loadlib.dotnet32.DotNet32.multiply_doubles","title":"multiply_doubles","text":"<pre><code>multiply_doubles(a, b)\n</code></pre> <p>Multiply two C# double-precision numbers.</p> <p>The corresponding C# code is</p> <pre><code>public double multiply_doubles(double a, double b)\n{\n    return a * b;\n}\n</code></pre> <p>See the corresponding DotNet64.multiply_doubles method.</p> <p>Parameters:</p> Name Type Description Default <code>a</code> <code>float</code> <p>First double-precision number.</p> required <code>b</code> <code>float</code> <p>Second double-precision number.</p> required <p>Returns:</p> Type Description <code>float</code> <p>The product, <code>a * b</code>.</p> Source code in <code>src/msl/examples/loadlib/dotnet32.py</code> <pre><code>def multiply_doubles(self, a: float, b: float) -&gt; float:\n    \"\"\"Multiply two C# double-precision numbers.\n\n    The corresponding C# code is\n\n    ```csharp\n    public double multiply_doubles(double a, double b)\n    {\n        return a * b;\n    }\n    ```\n\n    See the corresponding [DotNet64.multiply_doubles][msl.examples.loadlib.dotnet64.DotNet64.multiply_doubles]\n    method.\n\n    Args:\n        a: First double-precision number.\n        b: Second double-precision number.\n\n    Returns:\n        The product, `a * b`.\n    \"\"\"\n    result: float = self.BasicMath.multiply_doubles(a, b)\n    return result\n</code></pre>"},{"location":"examples/dotnet32/#msl.examples.loadlib.dotnet32.DotNet32.multiply_matrices","title":"multiply_matrices","text":"<pre><code>multiply_matrices(a1, a2)\n</code></pre> <p>Multiply two matrices.</p> <p>The corresponding C# code is</p> <pre><code>public double[,] multiply_matrices(double[,] A, double[,] B)\n{\n    int rA = A.GetLength(0);\n    int cA = A.GetLength(1);\n    int rB = B.GetLength(0);\n    int cB = B.GetLength(1);\n    double temp = 0;\n    double[,] C = new double[rA, cB];\n    if (cA != rB)\n    {\n        Console.WriteLine(\"matrices can't be multiplied!\");\n        return new double[0, 0];\n    }\n    else\n    {\n        for (int i = 0; i &lt; rA; i++)\n        {\n            for (int j = 0; j &lt; cB; j++)\n            {\n                temp = 0;\n                for (int k = 0; k &lt; cA; k++)\n                {\n                    temp += A[i, k] * B[k, j];\n                }\n                C[i, j] = temp;\n            }\n        }\n        return C;\n    }\n}\n</code></pre> <p>See the corresponding DotNet64.multiply_matrices method.</p> <p>Parameters:</p> Name Type Description Default <code>a1</code> <code>Sequence[Sequence[float]]</code> <p>First matrix.</p> required <code>a2</code> <code>Sequence[Sequence[float]]</code> <p>Second matrix.</p> required <p>Returns:</p> Type Description <code>list[list[float]]</code> <p>The result, <code>a1 @ a2</code>.</p> Source code in <code>src/msl/examples/loadlib/dotnet32.py</code> <pre><code>def multiply_matrices(self, a1: Sequence[Sequence[float]], a2: Sequence[Sequence[float]]) -&gt; list[list[float]]:\n    \"\"\"Multiply two matrices.\n\n    The corresponding C# code is\n\n    ```csharp\n    public double[,] multiply_matrices(double[,] A, double[,] B)\n    {\n        int rA = A.GetLength(0);\n        int cA = A.GetLength(1);\n        int rB = B.GetLength(0);\n        int cB = B.GetLength(1);\n        double temp = 0;\n        double[,] C = new double[rA, cB];\n        if (cA != rB)\n        {\n            Console.WriteLine(\"matrices can't be multiplied!\");\n            return new double[0, 0];\n        }\n        else\n        {\n            for (int i = 0; i &lt; rA; i++)\n            {\n                for (int j = 0; j &lt; cB; j++)\n                {\n                    temp = 0;\n                    for (int k = 0; k &lt; cA; k++)\n                    {\n                        temp += A[i, k] * B[k, j];\n                    }\n                    C[i, j] = temp;\n                }\n            }\n            return C;\n        }\n    }\n    ```\n\n    See the corresponding [DotNet64.multiply_matrices][msl.examples.loadlib.dotnet64.DotNet64.multiply_matrices]\n    method.\n\n    Args:\n        a1: First matrix.\n        a2: Second matrix.\n\n    Returns:\n        The result, `a1 @ a2`.\n    \"\"\"\n    n_rows1 = len(a1)\n    n_cols1 = len(a1[0])\n\n    n_rows2 = len(a2)\n    n_cols2 = len(a2[0])\n\n    if n_cols1 != n_rows2:\n        msg = f\"Cannot multiply a {n_rows1}x{n_cols1} matrix with a {n_rows2}x{n_cols2} matrix\"\n        raise ValueError(msg)\n\n    m1 = self.lib.System.Array.CreateInstance(self.lib.System.Double, n_rows1, n_cols1)\n    for r in range(n_rows1):\n        for c in range(n_cols1):\n            m1[r, c] = a1[r][c]\n\n    m2 = self.lib.System.Array.CreateInstance(self.lib.System.Double, n_rows2, n_cols2)\n    for r in range(n_rows2):\n        for c in range(n_cols2):\n            m2[r, c] = a2[r][c]\n\n    ret = self.ArrayManipulation.multiply_matrices(m1, m2)\n    return [[ret[r, c] for c in range(n_cols2)] for r in range(n_rows1)]\n</code></pre>"},{"location":"examples/dotnet32/#msl.examples.loadlib.dotnet32.DotNet32.reverse_string","title":"reverse_string","text":"<pre><code>reverse_string(original)\n</code></pre> <p>Reverse a string.</p> <p>The corresponding C# code is</p> <pre><code>public string reverse_string(string original)\n{\n    char[] charArray = original.ToCharArray();\n    Array.Reverse(charArray);\n    return new string(charArray);\n}\n</code></pre> <p>See the corresponding DotNet64.reverse_string method.</p> <p>Parameters:</p> Name Type Description Default <code>original</code> <code>str</code> <p>The original string.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The string reversed.</p> Source code in <code>src/msl/examples/loadlib/dotnet32.py</code> <pre><code>def reverse_string(self, original: str) -&gt; str:\n    \"\"\"Reverse a string.\n\n    The corresponding C# code is\n\n    ```csharp\n    public string reverse_string(string original)\n    {\n        char[] charArray = original.ToCharArray();\n        Array.Reverse(charArray);\n        return new string(charArray);\n    }\n    ```\n\n    See the corresponding [DotNet64.reverse_string][msl.examples.loadlib.dotnet64.DotNet64.reverse_string] method.\n\n    Args:\n        original: The original string.\n\n    Returns:\n        The string reversed.\n    \"\"\"\n    result: str = self.lib.StringManipulation().reverse_string(original)\n    return result\n</code></pre>"},{"location":"examples/dotnet32/#msl.examples.loadlib.dotnet32.DotNet32.scalar_multiply","title":"scalar_multiply","text":"<pre><code>scalar_multiply(a, xin)\n</code></pre> <p>Multiply each element in an array by a number.</p> <p>The corresponding C# code is</p> <pre><code>public double[] scalar_multiply(double a, double[] xin)\n{\n    int n = xin.GetLength(0);\n    double[] xout = new double[n];\n    for (int i = 0; i &lt; n; i++)\n    {\n        xout[i] = a * xin[i];\n    }\n    return xout;\n}\n</code></pre> <p>See the corresponding DotNet64.scalar_multiply method.</p> <p>Parameters:</p> Name Type Description Default <code>a</code> <code>float</code> <p>Scalar value.</p> required <code>xin</code> <code>Sequence[float]</code> <p>Array to modify.</p> required <p>Returns:</p> Type Description <code>list[float]</code> <p>A new array with each element in <code>xin</code> multiplied by <code>a</code>.</p> Source code in <code>src/msl/examples/loadlib/dotnet32.py</code> <pre><code>def scalar_multiply(self, a: float, xin: Sequence[float]) -&gt; list[float]:\n    \"\"\"Multiply each element in an array by a number.\n\n    The corresponding C# code is\n\n    ```csharp\n    public double[] scalar_multiply(double a, double[] xin)\n    {\n        int n = xin.GetLength(0);\n        double[] xout = new double[n];\n        for (int i = 0; i &lt; n; i++)\n        {\n            xout[i] = a * xin[i];\n        }\n        return xout;\n    }\n    ```\n\n    See the corresponding [DotNet64.scalar_multiply][msl.examples.loadlib.dotnet64.DotNet64.scalar_multiply] method.\n\n    Args:\n        a: Scalar value.\n        xin: Array to modify.\n\n    Returns:\n        A new array with each element in `xin` multiplied by `a`.\n    \"\"\"\n    ret = self.ArrayManipulation.scalar_multiply(a, xin)\n    return list(ret)\n</code></pre>"},{"location":"examples/dotnet64/","title":"DotNet64","text":"<p>Communicates with the dotnet_lib32 library via the DotNet32 class that is running on a server.</p>"},{"location":"examples/dotnet64/#msl.examples.loadlib.dotnet64.DotNet64","title":"DotNet64","text":"<pre><code>DotNet64()\n</code></pre> <p>               Bases: <code>Client64</code></p> <p>Communicates with a 32-bit .NET library.</p> <p>This class demonstrates how to communicate with a 32-bit .NET library if an instance of this class is created within a 64-bit Python interpreter.</p> Source code in <code>src/msl/examples/loadlib/dotnet64.py</code> <pre><code>def __init__(self) -&gt; None:\n    \"\"\"Communicates with the 32-bit .NET [dotnet_lib32.dll][dotnet-lib] library.\n\n    This class demonstrates how to communicate with a 32-bit .NET library if an\n    instance of this class is created within a 64-bit Python interpreter.\n    \"\"\"\n    # specify the name of the corresponding 32-bit server module, dotnet32, which hosts\n    # the 32-bit .NET library -- dotnet_lib32.dll.\n    super().__init__(\"dotnet32\", append_sys_path=Path(__file__).parent)\n</code></pre>"},{"location":"examples/dotnet64/#msl.examples.loadlib.dotnet64.DotNet64.add_integers","title":"add_integers","text":"<pre><code>add_integers(a, b)\n</code></pre> <p>Add two integers.</p> <p>See the corresponding DotNet32.add_integers method.</p> <p>Parameters:</p> Name Type Description Default <code>a</code> <code>int</code> <p>First integer.</p> required <code>b</code> <code>int</code> <p>Second integer.</p> required <p>Returns:</p> Type Description <code>int</code> <p>The sum, <code>a + b</code>.</p> Source code in <code>src/msl/examples/loadlib/dotnet64.py</code> <pre><code>def add_integers(self, a: int, b: int) -&gt; int:\n    \"\"\"Add two integers.\n\n    See the corresponding [DotNet32.add_integers][msl.examples.loadlib.dotnet32.DotNet32.add_integers] method.\n\n    Args:\n        a: First integer.\n        b: Second integer.\n\n    Returns:\n        The sum, `a + b`.\n    \"\"\"\n    reply: int = self.request32(\"add_integers\", a, b)\n    return reply\n</code></pre>"},{"location":"examples/dotnet64/#msl.examples.loadlib.dotnet64.DotNet64.add_multiple","title":"add_multiple","text":"<pre><code>add_multiple(a, b, c, d, e)\n</code></pre> <p>Add multiple integers.</p> <p>Calls a static method in a static class.</p> <p>See the corresponding DotNet32.add_multiple method.</p> <p>Parameters:</p> Name Type Description Default <code>a</code> <code>int</code> <p>First integer.</p> required <code>b</code> <code>int</code> <p>Second integer.</p> required <code>c</code> <code>int</code> <p>Third integer.</p> required <code>d</code> <code>int</code> <p>Fourth integer.</p> required <code>e</code> <code>int</code> <p>Fifth integer.</p> required <p>Returns:</p> Type Description <code>int</code> <p>The sum of the input arguments.</p> Source code in <code>src/msl/examples/loadlib/dotnet64.py</code> <pre><code>def add_multiple(self, a: int, b: int, c: int, d: int, e: int) -&gt; int:\n    \"\"\"Add multiple integers.\n\n    Calls a static method in a static class.\n\n    See the corresponding [DotNet32.add_multiple][msl.examples.loadlib.dotnet32.DotNet32.add_multiple] method.\n\n    Args:\n        a: First integer.\n        b: Second integer.\n        c: Third integer.\n        d: Fourth integer.\n        e: Fifth integer.\n\n    Returns:\n        The sum of the input arguments.\n    \"\"\"\n    reply: int = self.request32(\"add_multiple\", a, b, c, d, e)\n    return reply\n</code></pre>"},{"location":"examples/dotnet64/#msl.examples.loadlib.dotnet64.DotNet64.add_or_subtract","title":"add_or_subtract","text":"<pre><code>add_or_subtract(a, b, *, do_addition)\n</code></pre> <p>Add or subtract two C# double-precision numbers.</p> <p>See the corresponding DotNet32.add_or_subtract method.</p> <p>Parameters:</p> Name Type Description Default <code>a</code> <code>float</code> <p>First double-precision number.</p> required <code>b</code> <code>float</code> <p>Second double-precision number.</p> required <code>do_addition</code> <code>bool</code> <p>Whether to add or subtract the numbers.</p> required <p>Returns:</p> Type Description <code>float</code> <p><code>a + b</code> if <code>do_addition</code> is <code>True</code> else <code>a - b</code>.</p> Source code in <code>src/msl/examples/loadlib/dotnet64.py</code> <pre><code>def add_or_subtract(self, a: float, b: float, *, do_addition: bool) -&gt; float:\n    \"\"\"Add or subtract two C# double-precision numbers.\n\n    See the corresponding [DotNet32.add_or_subtract][msl.examples.loadlib.dotnet32.DotNet32.add_or_subtract] method.\n\n    Args:\n        a: First double-precision number.\n        b: Second double-precision number.\n        do_addition: Whether to add or subtract the numbers.\n\n    Returns:\n        `a + b` if `do_addition` is `True` else `a - b`.\n    \"\"\"\n    reply: float = self.request32(\"add_or_subtract\", a, b, do_addition=do_addition)\n    return reply\n</code></pre>"},{"location":"examples/dotnet64/#msl.examples.loadlib.dotnet64.DotNet64.concatenate","title":"concatenate","text":"<pre><code>concatenate(a, b, c, d, e)\n</code></pre> <p>Concatenate strings.</p> <p>Calls a static method in a static class.</p> <p>See the corresponding DotNet32.concatenate method.</p> <p>Parameters:</p> Name Type Description Default <code>a</code> <code>str</code> <p>First string.</p> required <code>b</code> <code>str</code> <p>Second string.</p> required <code>c</code> <code>str</code> <p>Third string.</p> required <code>d</code> <code>bool</code> <p>Whether to include <code>e</code> in the concatenation.</p> required <code>e</code> <code>str</code> <p>Fourth string.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The strings concatenated together.</p> Source code in <code>src/msl/examples/loadlib/dotnet64.py</code> <pre><code>def concatenate(self, a: str, b: str, c: str, d: bool, e: str) -&gt; str:  # noqa: FBT001\n    \"\"\"Concatenate strings.\n\n    Calls a static method in a static class.\n\n    See the corresponding [DotNet32.concatenate][msl.examples.loadlib.dotnet32.DotNet32.concatenate] method.\n\n    Args:\n        a: First string.\n        b: Second string.\n        c: Third string.\n        d: Whether to include `e` in the concatenation.\n        e: Fourth string.\n\n    Returns:\n        The strings concatenated together.\n    \"\"\"\n    reply: str = self.request32(\"concatenate\", a, b, c, d, e)\n    return reply\n</code></pre>"},{"location":"examples/dotnet64/#msl.examples.loadlib.dotnet64.DotNet64.divide_floats","title":"divide_floats","text":"<pre><code>divide_floats(a, b)\n</code></pre> <p>Divide two C# floating-point numbers.</p> <p>See the corresponding DotNet32.divide_floats method.</p> <p>Parameters:</p> Name Type Description Default <code>a</code> <code>float</code> <p>The numerator.</p> required <code>b</code> <code>float</code> <p>The denominator.</p> required <p>Returns:</p> Type Description <code>float</code> <p>The quotient, <code>a / b</code>.</p> Source code in <code>src/msl/examples/loadlib/dotnet64.py</code> <pre><code>def divide_floats(self, a: float, b: float) -&gt; float:\n    \"\"\"Divide two C# floating-point numbers.\n\n    See the corresponding [DotNet32.divide_floats][msl.examples.loadlib.dotnet32.DotNet32.divide_floats] method.\n\n    Args:\n        a: The numerator.\n        b: The denominator.\n\n    Returns:\n        The quotient, `a / b`.\n    \"\"\"\n    reply: float = self.request32(\"divide_floats\", a, b)\n    return reply\n</code></pre>"},{"location":"examples/dotnet64/#msl.examples.loadlib.dotnet64.DotNet64.get_class_names","title":"get_class_names","text":"<pre><code>get_class_names()\n</code></pre> <p>Gets the class names in the library.</p> <p>Calls GetTypes using the assembly property.</p> <p>See the corresponding DotNet32.get_class_names method.</p> <p>Returns:</p> Type Description <code>list[str]</code> <p>The names of the classes that are available in dotnet_lib32.dll.</p> Source code in <code>src/msl/examples/loadlib/dotnet64.py</code> <pre><code>def get_class_names(self) -&gt; list[str]:\n    \"\"\"Gets the class names in the library.\n\n    Calls [GetTypes](https://learn.microsoft.com/en-us/dotnet/api/system.reflection.assembly.gettypes){:target=\"_blank\"}\n    using the [assembly][msl.loadlib.load_library.LoadLibrary.assembly] property.\n\n    See the corresponding [DotNet32.get_class_names][msl.examples.loadlib.dotnet32.DotNet32.get_class_names] method.\n\n    Returns:\n        The names of the classes that are available in [dotnet_lib32.dll][dotnet-lib].\n    \"\"\"\n    reply: list[str] = self.request32(\"get_class_names\")\n    return reply\n</code></pre>"},{"location":"examples/dotnet64/#msl.examples.loadlib.dotnet64.DotNet64.multiply_doubles","title":"multiply_doubles","text":"<pre><code>multiply_doubles(a, b)\n</code></pre> <p>Multiply two C# double-precision numbers.</p> <p>See the corresponding DotNet32.multiply_doubles method.</p> <p>Parameters:</p> Name Type Description Default <code>a</code> <code>float</code> <p>First double-precision number.</p> required <code>b</code> <code>float</code> <p>Second double-precision number.</p> required <p>Returns:</p> Type Description <code>float</code> <p>The product, <code>a * b</code>.</p> Source code in <code>src/msl/examples/loadlib/dotnet64.py</code> <pre><code>def multiply_doubles(self, a: float, b: float) -&gt; float:\n    \"\"\"Multiply two C# double-precision numbers.\n\n    See the corresponding [DotNet32.multiply_doubles][msl.examples.loadlib.dotnet32.DotNet32.multiply_doubles]\n    method.\n\n    Args:\n        a: First double-precision number.\n        b: Second double-precision number.\n\n    Returns:\n        The product, `a * b`.\n    \"\"\"\n    reply: float = self.request32(\"multiply_doubles\", a, b)\n    return reply\n</code></pre>"},{"location":"examples/dotnet64/#msl.examples.loadlib.dotnet64.DotNet64.multiply_matrices","title":"multiply_matrices","text":"<pre><code>multiply_matrices(a1, a2)\n</code></pre> <p>Multiply two matrices.</p> <p>See the corresponding DotNet32.multiply_matrices method.</p> <p>Parameters:</p> Name Type Description Default <code>a1</code> <code>Sequence[Sequence[float]]</code> <p>First matrix.</p> required <code>a2</code> <code>Sequence[Sequence[float]]</code> <p>Second matrix.</p> required Return <p>The product, <code>a1 @ a2</code>.</p> Source code in <code>src/msl/examples/loadlib/dotnet64.py</code> <pre><code>def multiply_matrices(self, a1: Sequence[Sequence[float]], a2: Sequence[Sequence[float]]) -&gt; list[list[float]]:\n    \"\"\"Multiply two matrices.\n\n    See the corresponding [DotNet32.multiply_matrices][msl.examples.loadlib.dotnet32.DotNet32.multiply_matrices]\n    method.\n\n    Args:\n        a1: First matrix.\n        a2: Second matrix.\n\n    Return:\n        The product, `a1 @ a2`.\n    \"\"\"\n    reply: list[list[float]] = self.request32(\"multiply_matrices\", a1, a2)\n    return reply\n</code></pre>"},{"location":"examples/dotnet64/#msl.examples.loadlib.dotnet64.DotNet64.reverse_string","title":"reverse_string","text":"<pre><code>reverse_string(original)\n</code></pre> <p>Reverse a string.</p> <p>See the corresponding DotNet32.reverse_string method.</p> <p>Parameters:</p> Name Type Description Default <code>original</code> <code>str</code> <p>The original string.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The string reversed.</p> Source code in <code>src/msl/examples/loadlib/dotnet64.py</code> <pre><code>def reverse_string(self, original: str) -&gt; str:\n    \"\"\"Reverse a string.\n\n    See the corresponding [DotNet32.reverse_string][msl.examples.loadlib.dotnet32.DotNet32.reverse_string] method.\n\n    Args:\n        original: The original string.\n\n    Returns:\n        The string reversed.\n    \"\"\"\n    reply: str = self.request32(\"reverse_string\", original)\n    return reply\n</code></pre>"},{"location":"examples/dotnet64/#msl.examples.loadlib.dotnet64.DotNet64.scalar_multiply","title":"scalar_multiply","text":"<pre><code>scalar_multiply(a, xin)\n</code></pre> <p>Multiply each element in an array by a number.</p> <p>See the corresponding DotNet32.scalar_multiply method.</p> <p>Parameters:</p> Name Type Description Default <code>a</code> <code>float</code> <p>Scalar value.</p> required <code>xin</code> <code>Sequence[float]</code> <p>Array to modify.</p> required <p>Returns:</p> Type Description <code>list[float]</code> <p>A new array with each element in <code>xin</code> multiplied by <code>a</code>.</p> Source code in <code>src/msl/examples/loadlib/dotnet64.py</code> <pre><code>def scalar_multiply(self, a: float, xin: Sequence[float]) -&gt; list[float]:\n    \"\"\"Multiply each element in an array by a number.\n\n    See the corresponding [DotNet32.scalar_multiply][msl.examples.loadlib.dotnet32.DotNet32.scalar_multiply] method.\n\n    Args:\n        a: Scalar value.\n        xin: Array to modify.\n\n    Returns:\n        A new array with each element in `xin` multiplied by `a`.\n    \"\"\"\n    reply: list[float] = self.request32(\"scalar_multiply\", a, xin)\n    return reply\n</code></pre>"},{"location":"examples/echo32/","title":"Echo32","text":"<p>An example of a 32-bit echo server.</p> <p>Echo32 is the 32-bit server class and Echo64 is the 64-bit client class. These Echo classes do not actually communicate with a library. The point of these Echo classes is to show that a Python data type in a 64-bit process appears as the same data type in the 32-bit process and vice versa. (provided that the data type is pickleable.)</p>"},{"location":"examples/echo32/#msl.examples.loadlib.echo32.Echo32","title":"Echo32","text":"<pre><code>Echo32(host, port)\n</code></pre> <p>               Bases: <code>Server32</code></p> <p>Example that shows Python data types are preserved between Echo32 and Echo64.</p> <p>Parameters:</p> Name Type Description Default <code>host</code> <code>str</code> <p>The IP address (or hostname) to use for the server.</p> required <code>port</code> <code>int</code> <p>The port to open for the server.</p> required Source code in <code>src/msl/examples/loadlib/echo32.py</code> <pre><code>def __init__(self, host: str, port: int) -&gt; None:\n    \"\"\"Example that shows Python data types are preserved between [Echo32][] and [Echo64][].\n\n    Args:\n        host: The IP address (or hostname) to use for the server.\n        port: The port to open for the server.\n    \"\"\"\n    # even though this is a *echo* class that does not call a library\n    # we still need to provide a library file that exists. Use the C++ library.\n    path = Path(__file__).parent / \"cpp_lib32\"\n    super().__init__(path, \"cdll\", host, port)\n</code></pre>"},{"location":"examples/echo32/#msl.examples.loadlib.echo32.Echo32.received_data","title":"received_data  <code>staticmethod</code>","text":"<pre><code>received_data(*args, **kwargs)\n</code></pre> <p>Process a request from the Echo64.send_data method.</p> <p>Parameters:</p> Name Type Description Default <code>args</code> <code>Any</code> <p>The arguments.</p> <code>()</code> <code>kwargs</code> <code>Any</code> <p>The keyword arguments.</p> <code>{}</code> <p>Returns:</p> Type Description <code>tuple[tuple[Any, ...], dict[str, Any]]</code> <p>The <code>args</code> and <code>kwargs</code> that were received.</p> Source code in <code>src/msl/examples/loadlib/echo32.py</code> <pre><code>@staticmethod\ndef received_data(*args: Any, **kwargs: Any) -&gt; tuple[tuple[Any, ...], dict[str, Any]]:  # type: ignore[misc]\n    \"\"\"Process a request from the [Echo64.send_data][msl.examples.loadlib.echo64.Echo64.send_data] method.\n\n    Args:\n        args: The arguments.\n        kwargs: The keyword arguments.\n\n    Returns:\n        The `args` and `kwargs` that were received.\n    \"\"\"\n    return args, kwargs\n</code></pre>"},{"location":"examples/echo64/","title":"Echo64","text":"<p>An example of a 64-bit echo client.</p> <p>Echo32 is the 32-bit server class and Echo64 is the 64-bit client class. These Echo classes do not actually communicate with a library. The point of these Echo classes is to show that a Python data type in a 64-bit process appears as the same data type in the 32-bit process and vice versa (provided that the data type is pickleable.)</p>"},{"location":"examples/echo64/#msl.examples.loadlib.echo64.Echo64","title":"Echo64","text":"<pre><code>Echo64()\n</code></pre> <p>               Bases: <code>Client64</code></p> <p>Example that shows Python data types are preserved between Echo32 and Echo64.</p> Source code in <code>src/msl/examples/loadlib/echo64.py</code> <pre><code>def __init__(self) -&gt; None:\n    \"\"\"Example that shows Python data types are preserved between [Echo32][] and [Echo64][].\"\"\"\n    super().__init__(\"echo32\", append_sys_path=Path(__file__).parent)\n</code></pre>"},{"location":"examples/echo64/#msl.examples.loadlib.echo64.Echo64.send_data","title":"send_data","text":"<pre><code>send_data(*args, **kwargs)\n</code></pre> <p>Send a request to Echo32.received_data.</p> <p>Parameters:</p> Name Type Description Default <code>args</code> <code>Any</code> <p>The arguments to send.</p> <code>()</code> <code>kwargs</code> <code>Any</code> <p>The keyword arguments to send.</p> <code>{}</code> <p>Returns:</p> Type Description <code>tuple[tuple[Any, ...], dict[str, Any]]</code> <p>The <code>args</code> and <code>kwargs</code> that were sent.</p> Source code in <code>src/msl/examples/loadlib/echo64.py</code> <pre><code>def send_data(self, *args: Any, **kwargs: Any) -&gt; tuple[tuple[Any, ...], dict[str, Any]]:\n    \"\"\"Send a request to [Echo32.received_data][msl.examples.loadlib.echo32.Echo32.received_data].\n\n    Args:\n        args: The arguments to send.\n        kwargs: The keyword arguments to send.\n\n    Returns:\n        The `args` and `kwargs` that were sent.\n    \"\"\"\n    reply: tuple[tuple[Any, ...], dict[str, Any]] = self.request32(\"received_data\", *args, **kwargs)\n    return reply\n</code></pre>"},{"location":"examples/fortran32/","title":"Fortran32","text":"<p>Wrapper around a 32-bit FORTRAN library.</p> <p>Example of a server that loads a 32-bit library, fortran_lib32, in a 32-bit Python interpreter to host the library. The corresponding Fortran64 class is created in a 64-bit Python interpreter and the Fortran64 class sends requests to the Fortran32 class which calls the 32-bit library to execute the request and then returns the response from the library.</p>"},{"location":"examples/fortran32/#msl.examples.loadlib.fortran32.Fortran32","title":"Fortran32","text":"<pre><code>Fortran32(host, port)\n</code></pre> <p>               Bases: <code>Server32</code></p> <p>Wrapper around a 32-bit FORTRAN library.</p> <p>This class demonstrates how to pass various data types to/from a 32-bit FORTRAN library via ctypes.</p> <p>Parameters:</p> Name Type Description Default <code>host</code> <code>str</code> <p>The IP address (or hostname) to use for the server.</p> required <code>port</code> <code>int</code> <p>The port to open for the server.</p> required Source code in <code>src/msl/examples/loadlib/fortran32.py</code> <pre><code>def __init__(self, host: str, port: int) -&gt; None:\n    \"\"\"A wrapper around a 32-bit FORTRAN library, [fortran_lib32][fortran-lib].\n\n    This class demonstrates how to pass various data types to/from a\n    32-bit FORTRAN library via [ctypes][]{:target=\"_blank\"}.\n\n    Args:\n        host: The IP address (or hostname) to use for the server.\n        port: The port to open for the server.\n    \"\"\"\n    # By not specifying the extension of the library file the server will open\n    # the appropriate file based on the operating system.\n    path = Path(__file__).parent / \"fortran_lib32\"\n    super().__init__(path, \"cdll\", host, port)\n</code></pre>"},{"location":"examples/fortran32/#msl.examples.loadlib.fortran32.Fortran32.add_1d_arrays","title":"add_1d_arrays","text":"<pre><code>add_1d_arrays(a1, a2)\n</code></pre> <p>Perform an element-wise addition of two 1D double-precision arrays.</p> <p>The corresponding FORTRAN code is</p> <pre><code>subroutine add_1d_arrays(a, in1, in2, n)\n    !DEC$ ATTRIBUTES DLLEXPORT, ALIAS:'add_1d_arrays' :: add_1d_arrays\n    implicit none\n    integer(4) :: n ! the length of the input arrays\n    double precision :: in1(n), in2(n) ! the arrays to add (element-wise)\n    double precision :: a(n) ! the array that will contain the element-wise sum\n    a(:) = in1(:) + in2(:)\nend subroutine add_1d_arrays\n</code></pre> <p>See the corresponding Fortran64.add_1d_arrays method.</p> <p>Parameters:</p> Name Type Description Default <code>a1</code> <code>Sequence[float]</code> <p>First array.</p> required <code>a2</code> <code>Sequence[float]</code> <p>Second array.</p> required <p>Returns:</p> Type Description <code>list[float]</code> <p>The element-wise addition of <code>a1 + a2</code>.</p> Source code in <code>src/msl/examples/loadlib/fortran32.py</code> <pre><code>def add_1d_arrays(self, a1: Sequence[float], a2: Sequence[float]) -&gt; list[float]:\n    \"\"\"Perform an element-wise addition of two 1D double-precision arrays.\n\n    The corresponding FORTRAN code is\n\n    ```fortran\n    subroutine add_1d_arrays(a, in1, in2, n)\n        !DEC$ ATTRIBUTES DLLEXPORT, ALIAS:'add_1d_arrays' :: add_1d_arrays\n        implicit none\n        integer(4) :: n ! the length of the input arrays\n        double precision :: in1(n), in2(n) ! the arrays to add (element-wise)\n        double precision :: a(n) ! the array that will contain the element-wise sum\n        a(:) = in1(:) + in2(:)\n    end subroutine add_1d_arrays\n    ```\n\n    See the corresponding [Fortran64.add_1d_arrays][msl.examples.loadlib.fortran64.Fortran64.add_1d_arrays] method.\n\n    Args:\n        a1: First array.\n        a2: Second array.\n\n    Returns:\n        The element-wise addition of `a1 + a2`.\n    \"\"\"\n    # restype should be defined elsewhere, shown here for illustrative purposes\n    self.lib.add_1d_arrays.restype = None\n\n    n = len(a1)\n    nc = ctypes.c_int32(n)\n    out = (ctypes.c_double * n)()\n    self.lib.add_1d_arrays(out, (ctypes.c_double * n)(*a1), (ctypes.c_double * n)(*a2), ctypes.byref(nc))\n    return list(out)\n</code></pre>"},{"location":"examples/fortran32/#msl.examples.loadlib.fortran32.Fortran32.add_or_subtract","title":"add_or_subtract","text":"<pre><code>add_or_subtract(a, b, *, do_addition)\n</code></pre> <p>Add or subtract two integers.</p> <p>The corresponding FORTRAN code is</p> <pre><code>function add_or_subtract(a, b, do_addition) result(value)\n    !DEC$ ATTRIBUTES DLLEXPORT, ALIAS:'add_or_subtract' :: add_or_subtract\n    implicit none\n    logical :: do_addition\n    integer(4) :: a, b, value\n    if (do_addition) then\n        value = a + b\n    else\n        value = a - b\n    endif\nend function add_or_subtract\n</code></pre> <p>See the corresponding Fortran64.add_or_subtract method.</p> <p>Parameters:</p> Name Type Description Default <code>a</code> <code>int</code> <p>First integer.</p> required <code>b</code> <code>int</code> <p>Second integer.</p> required <code>do_addition</code> <code>bool</code> <p>Whether to add or subtract the numbers.</p> required Return <p><code>a + b</code> if <code>do_addition</code> is <code>True</code> else <code>a - b</code>.</p> Source code in <code>src/msl/examples/loadlib/fortran32.py</code> <pre><code>def add_or_subtract(self, a: int, b: int, *, do_addition: bool) -&gt; int:\n    \"\"\"Add or subtract two integers.\n\n    The corresponding FORTRAN code is\n\n    ```fortran\n    function add_or_subtract(a, b, do_addition) result(value)\n        !DEC$ ATTRIBUTES DLLEXPORT, ALIAS:'add_or_subtract' :: add_or_subtract\n        implicit none\n        logical :: do_addition\n        integer(4) :: a, b, value\n        if (do_addition) then\n            value = a + b\n        else\n            value = a - b\n        endif\n    end function add_or_subtract\n    ```\n\n    See the corresponding [Fortran64.add_or_subtract][msl.examples.loadlib.fortran64.Fortran64.add_or_subtract]\n    method.\n\n    Args:\n        a: First integer.\n        b: Second integer.\n        do_addition: Whether to add or subtract the numbers.\n\n    Return:\n        `a + b` if `do_addition` is `True` else `a - b`.\n    \"\"\"\n    # restype should be defined elsewhere, shown here for illustrative purposes\n    self.lib.add_or_subtract.restype = ctypes.c_int32\n\n    ac = ctypes.c_int32(a)\n    bc = ctypes.c_int32(b)\n    logical = ctypes.c_bool(do_addition)\n    result: int = self.lib.add_or_subtract(ctypes.byref(ac), ctypes.byref(bc), ctypes.byref(logical))\n    return result\n</code></pre>"},{"location":"examples/fortran32/#msl.examples.loadlib.fortran32.Fortran32.besselJ0","title":"besselJ0","text":"<pre><code>besselJ0(x)\n</code></pre> <p>Compute the Bessel function of the first kind of order 0 of x.</p> <p>The corresponding FORTRAN code is</p> <pre><code>function besselj0(x) result(val)\n    !DEC$ ATTRIBUTES DLLEXPORT, ALIAS:'besselj0' :: besselj0\n    double precision :: x, val\n    val = BESSEL_J0(x)\nend function besselJ0\n</code></pre> <p>See the corresponding Fortran64.besselJ0 method.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>float</code> <p>The value to compute <code>BESSEL_J0</code> of.</p> required <p>Returns:</p> Type Description <code>float</code> <p>The value of <code>BESSEL_J0(x)</code>.</p> Source code in <code>src/msl/examples/loadlib/fortran32.py</code> <pre><code>def besselJ0(self, x: float) -&gt; float:  # noqa: N802\n    \"\"\"Compute the Bessel function of the first kind of order 0 of x.\n\n    The corresponding FORTRAN code is\n\n    ```fortran\n    function besselj0(x) result(val)\n        !DEC$ ATTRIBUTES DLLEXPORT, ALIAS:'besselj0' :: besselj0\n        double precision :: x, val\n        val = BESSEL_J0(x)\n    end function besselJ0\n    ```\n\n    See the corresponding [Fortran64.besselJ0][msl.examples.loadlib.fortran64.Fortran64.besselJ0] method.\n\n    Args:\n        x: The value to compute `BESSEL_J0` of.\n\n    Returns:\n        The value of `BESSEL_J0(x)`.\n    \"\"\"\n    # restype should be defined elsewhere, shown here for illustrative purposes\n    self.lib.besselj0.restype = ctypes.c_double\n\n    xc = ctypes.c_double(x)\n    result: float = self.lib.besselj0(ctypes.byref(xc))\n    return result\n</code></pre>"},{"location":"examples/fortran32/#msl.examples.loadlib.fortran32.Fortran32.factorial","title":"factorial","text":"<pre><code>factorial(n)\n</code></pre> <p>Compute the n'th factorial.</p> <p>The corresponding FORTRAN code is</p> <pre><code>function factorial(n) result(value)\n    !DEC$ ATTRIBUTES DLLEXPORT, ALIAS:'factorial' :: factorial\n    implicit none\n    integer(1) :: n\n    integer(4) :: i\n    double precision value\n    if (n &lt; 0) then\n        value = 0.d0\n        print *, \"Cannot compute the factorial of a negative number\", n\n    else\n        value = 1.d0\n        do i = 2, n\n            value = value * i\n        enddo\n    endif\nend function factorial\n</code></pre> <p>See the corresponding Fortran64.factorial method.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int</code> <p>The integer to computer the factorial of. The maximum allowed value is 127.</p> required <p>Returns:</p> Type Description <code>float</code> <p>The factorial of <code>n</code>.</p> Source code in <code>src/msl/examples/loadlib/fortran32.py</code> <pre><code>def factorial(self, n: int) -&gt; float:\n    \"\"\"Compute the n'th factorial.\n\n    The corresponding FORTRAN code is\n\n    ```fortran\n    function factorial(n) result(value)\n        !DEC$ ATTRIBUTES DLLEXPORT, ALIAS:'factorial' :: factorial\n        implicit none\n        integer(1) :: n\n        integer(4) :: i\n        double precision value\n        if (n &lt; 0) then\n            value = 0.d0\n            print *, \"Cannot compute the factorial of a negative number\", n\n        else\n            value = 1.d0\n            do i = 2, n\n                value = value * i\n            enddo\n        endif\n    end function factorial\n    ```\n\n    See the corresponding [Fortran64.factorial][msl.examples.loadlib.fortran64.Fortran64.factorial] method.\n\n    Args:\n        n: The integer to computer the factorial of. The maximum allowed value is 127.\n\n    Returns:\n        The factorial of `n`.\n    \"\"\"\n    # restype should be defined elsewhere, shown here for illustrative purposes\n    self.lib.factorial.restype = ctypes.c_double\n\n    ac = ctypes.c_int8(n)\n    result: float = self.lib.factorial(ctypes.byref(ac))\n    return result\n</code></pre>"},{"location":"examples/fortran32/#msl.examples.loadlib.fortran32.Fortran32.is_positive","title":"is_positive","text":"<pre><code>is_positive(a)\n</code></pre> <p>Returns whether the value of the input argument is &gt; 0.</p> <p>The corresponding FORTRAN code is</p> <pre><code>function is_positive(a) result(value)\n    !DEC$ ATTRIBUTES DLLEXPORT, ALIAS:'is_positive' :: is_positive\n    implicit none\n    logical :: value\n    real(8) :: a\n    value = a &gt; 0.d0\nend function is_positive\n</code></pre> <p>See the corresponding Fortran64.is_positive method.</p> <p>Parameters:</p> Name Type Description Default <code>a</code> <code>float</code> <p>Double-precision number.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>Whether the value of <code>a</code> is &gt; 0.</p> Source code in <code>src/msl/examples/loadlib/fortran32.py</code> <pre><code>def is_positive(self, a: float) -&gt; bool:\n    \"\"\"Returns whether the value of the input argument is &gt; 0.\n\n    The corresponding FORTRAN code is\n\n    ```fortran\n    function is_positive(a) result(value)\n        !DEC$ ATTRIBUTES DLLEXPORT, ALIAS:'is_positive' :: is_positive\n        implicit none\n        logical :: value\n        real(8) :: a\n        value = a &gt; 0.d0\n    end function is_positive\n    ```\n\n    See the corresponding [Fortran64.is_positive][msl.examples.loadlib.fortran64.Fortran64.is_positive] method.\n\n    Args:\n        a: Double-precision number.\n\n\n    Returns:\n        Whether the value of `a` is &amp;gt; 0.\n    \"\"\"\n    # restype should be defined elsewhere, shown here for illustrative purposes\n    self.lib.is_positive.restype = ctypes.c_bool\n\n    ac = ctypes.c_double(a)\n    result: bool = self.lib.is_positive(ctypes.byref(ac))\n    return result\n</code></pre>"},{"location":"examples/fortran32/#msl.examples.loadlib.fortran32.Fortran32.matrix_multiply","title":"matrix_multiply","text":"<pre><code>matrix_multiply(a1, a2)\n</code></pre> <p>Multiply two matrices.</p> <p>The corresponding FORTRAN code is</p> <pre><code>subroutine matrix_multiply(a, a1, r1, c1, a2, r2, c2)\n    !DEC$ ATTRIBUTES DLLEXPORT, ALIAS:'matrix_multiply' :: matrix_multiply\n    implicit none\n    integer(4) :: r1, c1, r2, c2 ! the dimensions of the input arrays\n    double precision :: a1(r1,c1), a2(r2,c2) ! the arrays to multiply\n    double precision :: a(r1,c2) ! resultant array\n    a = MATMUL(a1, a2)\nend subroutine matrix_multiply\n</code></pre> <p>Note</p> <p>FORTRAN stores multidimensional arrays in column-major order, as opposed to row-major order like C (Python) arrays. Therefore, the input matrices need to be transposed before sending the matrices to FORTRAN and also the result needs to be transposed.</p> <p>See the corresponding Fortran64.matrix_multiply method.</p> <p>Parameters:</p> Name Type Description Default <code>a1</code> <code>Sequence[Sequence[float]]</code> <p>First matrix.</p> required <code>a2</code> <code>Sequence[Sequence[float]]</code> <p>Second matrix.</p> required <p>Returns:</p> Type Description <code>list[list[float]]</code> <p>The product, <code>a1 @ a2</code>.</p> Source code in <code>src/msl/examples/loadlib/fortran32.py</code> <pre><code>def matrix_multiply(self, a1: Sequence[Sequence[float]], a2: Sequence[Sequence[float]]) -&gt; list[list[float]]:\n    \"\"\"Multiply two matrices.\n\n    The corresponding FORTRAN code is\n\n    ```fortran\n    subroutine matrix_multiply(a, a1, r1, c1, a2, r2, c2)\n        !DEC$ ATTRIBUTES DLLEXPORT, ALIAS:'matrix_multiply' :: matrix_multiply\n        implicit none\n        integer(4) :: r1, c1, r2, c2 ! the dimensions of the input arrays\n        double precision :: a1(r1,c1), a2(r2,c2) ! the arrays to multiply\n        double precision :: a(r1,c2) ! resultant array\n        a = MATMUL(a1, a2)\n    end subroutine matrix_multiply\n    ```\n\n    !!! note\n        FORTRAN stores multidimensional arrays in [column-major order][order]{:target=\"_blank\"},\n        as opposed to [row-major order][order]{:target=\"_blank\"} like C (Python) arrays. Therefore,\n        the input matrices need to be transposed before sending the matrices to FORTRAN\n        and also the result needs to be transposed.\n\n        [order]: https://en.wikipedia.org/wiki/Row-_and_column-major_order\n\n    See the corresponding [Fortran64.matrix_multiply][msl.examples.loadlib.fortran64.Fortran64.matrix_multiply]\n    method.\n\n    Args:\n        a1: First matrix.\n        a2: Second matrix.\n\n    Returns:\n        The product, `a1 @ a2`.\n    \"\"\"\n    # restype should be defined elsewhere, shown here for illustrative purposes\n    self.lib.matrix_multiply.restype = None\n\n    n_rows1 = ctypes.c_int32(len(a1))\n    n_cols1 = ctypes.c_int32(len(a1[0]))\n\n    n_rows2 = ctypes.c_int32(len(a2))\n    n_cols2 = ctypes.c_int32(len(a2[0]))\n\n    if n_cols1.value != n_rows2.value:\n        msg = (\n            f\"Cannot multiply a {n_rows1.value}x{n_cols1.value} matrix \"\n            f\"with a {n_rows2.value}x{n_cols2.value} matrix\"\n        )\n        raise ValueError(msg)\n\n    m1 = ((ctypes.c_double * n_rows1.value) * n_cols1.value)()\n    for r in range(n_rows1.value):\n        for c in range(n_cols1.value):\n            m1[c][r] = a1[r][c]\n\n    m2 = ((ctypes.c_double * n_rows2.value) * n_cols2.value)()\n    for r in range(n_rows2.value):\n        for c in range(n_cols2.value):\n            m2[c][r] = a2[r][c]\n\n    out = ((ctypes.c_double * n_rows1.value) * n_cols2.value)()\n\n    self.lib.matrix_multiply(\n        out, m1, ctypes.byref(n_rows1), ctypes.byref(n_cols1), m2, ctypes.byref(n_rows2), ctypes.byref(n_cols2)\n    )\n\n    return [[out[c][r] for c in range(n_cols2.value)] for r in range(n_rows1.value)]\n</code></pre>"},{"location":"examples/fortran32/#msl.examples.loadlib.fortran32.Fortran32.multiply_float32","title":"multiply_float32","text":"<pre><code>multiply_float32(a, b)\n</code></pre> <p>Multiply two FORTRAN floating-point numbers.</p> <p>The corresponding FORTRAN code is</p> <pre><code>function multiply_float32(a, b) result(value)\n    !DEC$ ATTRIBUTES DLLEXPORT, ALIAS:'multiply_float32' :: multiply_float32\n    implicit none\n    real(4) :: a, b, value\n    value = a * b\nend function multiply_float32\n</code></pre> <p>See the corresponding Fortran64.multiply_float32 method.</p> <p>Parameters:</p> Name Type Description Default <code>a</code> <code>float</code> <p>First floating-point number.</p> required <code>b</code> <code>float</code> <p>Second floating-point number.</p> required <p>Returns:</p> Type Description <code>float</code> <p>The product, <code>a * b</code>.</p> Source code in <code>src/msl/examples/loadlib/fortran32.py</code> <pre><code>def multiply_float32(self, a: float, b: float) -&gt; float:\n    \"\"\"Multiply two FORTRAN floating-point numbers.\n\n    The corresponding FORTRAN code is\n\n    ```fortran\n    function multiply_float32(a, b) result(value)\n        !DEC$ ATTRIBUTES DLLEXPORT, ALIAS:'multiply_float32' :: multiply_float32\n        implicit none\n        real(4) :: a, b, value\n        value = a * b\n    end function multiply_float32\n    ```\n\n    See the corresponding [Fortran64.multiply_float32][msl.examples.loadlib.fortran64.Fortran64.multiply_float32]\n    method.\n\n    Args:\n        a: First floating-point number.\n        b: Second floating-point number.\n\n    Returns:\n        The product, `a * b`.\n    \"\"\"\n    # restype should be defined elsewhere, shown here for illustrative purposes\n    self.lib.multiply_float32.restype = ctypes.c_float\n\n    ac = ctypes.c_float(a)\n    bc = ctypes.c_float(b)\n    result: float = self.lib.multiply_float32(ctypes.byref(ac), ctypes.byref(bc))\n    return result\n</code></pre>"},{"location":"examples/fortran32/#msl.examples.loadlib.fortran32.Fortran32.multiply_float64","title":"multiply_float64","text":"<pre><code>multiply_float64(a, b)\n</code></pre> <p>Multiply two FORTRAN double-precision numbers.</p> <p>The corresponding FORTRAN code is</p> <pre><code>function multiply_float64(a, b) result(value)\n    !DEC$ ATTRIBUTES DLLEXPORT, ALIAS:'multiply_float64' :: multiply_float64\n    implicit none\n    real(8) :: a, b, value\n    value = a * b\nend function multiply_float64\n</code></pre> <p>See the corresponding Fortran64.multiply_float64 method.</p> <p>Parameters:</p> Name Type Description Default <code>a</code> <code>float</code> <p>First double-precision number.</p> required <code>b</code> <code>float</code> <p>Second double-precision number.</p> required <p>Returns:</p> Type Description <code>float</code> <p>The product, <code>a * b</code>.</p> Source code in <code>src/msl/examples/loadlib/fortran32.py</code> <pre><code>def multiply_float64(self, a: float, b: float) -&gt; float:\n    \"\"\"Multiply two FORTRAN double-precision numbers.\n\n    The corresponding FORTRAN code is\n\n    ```fortran\n    function multiply_float64(a, b) result(value)\n        !DEC$ ATTRIBUTES DLLEXPORT, ALIAS:'multiply_float64' :: multiply_float64\n        implicit none\n        real(8) :: a, b, value\n        value = a * b\n    end function multiply_float64\n    ```\n\n    See the corresponding [Fortran64.multiply_float64][msl.examples.loadlib.fortran64.Fortran64.multiply_float64]\n    method.\n\n    Args:\n        a: First double-precision number.\n        b: Second double-precision number.\n\n    Returns:\n        The product, `a * b`.\n    \"\"\"\n    # restype should be defined elsewhere, shown here for illustrative purposes\n    self.lib.multiply_float64.restype = ctypes.c_double\n\n    ac = ctypes.c_double(a)\n    bc = ctypes.c_double(b)\n    result: float = self.lib.multiply_float64(ctypes.byref(ac), ctypes.byref(bc))\n    return result\n</code></pre>"},{"location":"examples/fortran32/#msl.examples.loadlib.fortran32.Fortran32.reverse_string","title":"reverse_string","text":"<pre><code>reverse_string(original)\n</code></pre> <p>Reverse a string.</p> <p>The corresponding FORTRAN code is</p> <pre><code>subroutine reverse_string(original, n, reversed)\n    !DEC$ ATTRIBUTES DLLEXPORT, ALIAS:'reverse_string' :: reverse_string\n    !DEC$ ATTRIBUTES REFERENCE :: original, reversed\n    implicit none\n    integer :: i, n\n    character(len=n) :: original, reversed\n    do i = 1, n\n        reversed(i:i) = original(n-i+1:n-i+1)\n    end do\nend subroutine reverse_string\n</code></pre> <p>See the corresponding Fortran64.reverse_string method.</p> <p>Parameters:</p> Name Type Description Default <code>original</code> <code>str</code> <p>The original string.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The string reversed.</p> Source code in <code>src/msl/examples/loadlib/fortran32.py</code> <pre><code>def reverse_string(self, original: str) -&gt; str:\n    \"\"\"Reverse a string.\n\n    The corresponding FORTRAN code is\n\n    ```fortran\n    subroutine reverse_string(original, n, reversed)\n        !DEC$ ATTRIBUTES DLLEXPORT, ALIAS:'reverse_string' :: reverse_string\n        !DEC$ ATTRIBUTES REFERENCE :: original, reversed\n        implicit none\n        integer :: i, n\n        character(len=n) :: original, reversed\n        do i = 1, n\n            reversed(i:i) = original(n-i+1:n-i+1)\n        end do\n    end subroutine reverse_string\n    ```\n\n    See the corresponding [Fortran64.reverse_string][msl.examples.loadlib.fortran64.Fortran64.reverse_string]\n    method.\n\n    Args:\n        original: The original string.\n\n    Returns:\n        The string reversed.\n    \"\"\"\n    # restype should be defined elsewhere, shown here for illustrative purposes\n    self.lib.reverse_string.restype = None\n\n    n = len(original)\n    nc = ctypes.c_int32(n)\n    rev = ctypes.create_string_buffer(n)\n    self.lib.reverse_string(ctypes.c_char_p(original.encode()), ctypes.byref(nc), rev)\n    return rev.raw.decode()\n</code></pre>"},{"location":"examples/fortran32/#msl.examples.loadlib.fortran32.Fortran32.standard_deviation","title":"standard_deviation","text":"<pre><code>standard_deviation(data)\n</code></pre> <p>Compute the standard deviation.</p> <p>The corresponding FORTRAN code is</p> <pre><code>function standard_deviation(a, n) result(var)\n    !DEC$ ATTRIBUTES DLLEXPORT, ALIAS:'standard_deviation' :: standard_deviation\n    integer :: n ! the length of the array\n    double precision :: var, a(n)\n    var = SUM(a)/SIZE(a) ! SUM is a built-in fortran function\n    var = SQRT(SUM((a-var)**2)/(SIZE(a)-1.0))\nend function standard_deviation\n</code></pre> <p>See the corresponding Fortran64.standard_deviation method.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Sequence[float]</code> <p>The values to compute the standard deviation of.</p> required <p>Returns:</p> Type Description <code>float</code> <p>The standard deviation of <code>data</code>.</p> Source code in <code>src/msl/examples/loadlib/fortran32.py</code> <pre><code>def standard_deviation(self, data: Sequence[float]) -&gt; float:\n    \"\"\"Compute the standard deviation.\n\n    The corresponding FORTRAN code is\n\n    ```fortran\n    function standard_deviation(a, n) result(var)\n        !DEC$ ATTRIBUTES DLLEXPORT, ALIAS:'standard_deviation' :: standard_deviation\n        integer :: n ! the length of the array\n        double precision :: var, a(n)\n        var = SUM(a)/SIZE(a) ! SUM is a built-in fortran function\n        var = SQRT(SUM((a-var)**2)/(SIZE(a)-1.0))\n    end function standard_deviation\n    ```\n\n    See the corresponding\n    [Fortran64.standard_deviation][msl.examples.loadlib.fortran64.Fortran64.standard_deviation]\n    method.\n\n    Args:\n        data: The values to compute the standard deviation of.\n\n    Returns:\n        The standard deviation of `data`.\n    \"\"\"\n    # restype should be defined elsewhere, shown here for illustrative purposes\n    self.lib.standard_deviation.restype = ctypes.c_double\n\n    n = len(data)\n    nc = ctypes.c_int32(n)\n    data_c = (ctypes.c_double * n)(*data)\n    result: float = self.lib.standard_deviation(ctypes.byref(data_c), ctypes.byref(nc))\n    return result\n</code></pre>"},{"location":"examples/fortran32/#msl.examples.loadlib.fortran32.Fortran32.sum_16bit","title":"sum_16bit","text":"<pre><code>sum_16bit(a, b)\n</code></pre> <p>Add two 16-bit signed integers.</p> <p>Python only has one int data type to represent integer values. This method converts the data types of <code>a</code> and <code>b</code> to be c_int16.</p> <p>The corresponding FORTRAN code is</p> <pre><code>function sum_16bit(a, b) result(value)\n    !DEC$ ATTRIBUTES DLLEXPORT, ALIAS:'sum_16bit' :: sum_16bit\n    implicit none\n    integer(2) :: a, b, value\n    value = a + b\nend function sum_16bit\n</code></pre> <p>See the corresponding Fortran64.sum_16bit method.</p> <p>Parameters:</p> Name Type Description Default <code>a</code> <code>int</code> <p>First 16-bit signed integer.</p> required <code>b</code> <code>int</code> <p>Second 16-bit signed integer.</p> required <p>Returns:</p> Type Description <code>int</code> <p>The sum, <code>a + b</code>.</p> Source code in <code>src/msl/examples/loadlib/fortran32.py</code> <pre><code>def sum_16bit(self, a: int, b: int) -&gt; int:\n    \"\"\"Add two 16-bit signed integers.\n\n    Python only has one [int][]{:target=\"_blank\"} data type to represent integer values.\n    This method converts the data types of `a` and `b` to be\n    [c_int16][ctypes.c_int16]{:target=\"_blank\"}.\n\n    The corresponding FORTRAN code is\n\n    ```fortran\n    function sum_16bit(a, b) result(value)\n        !DEC$ ATTRIBUTES DLLEXPORT, ALIAS:'sum_16bit' :: sum_16bit\n        implicit none\n        integer(2) :: a, b, value\n        value = a + b\n    end function sum_16bit\n    ```\n\n    See the corresponding [Fortran64.sum_16bit][msl.examples.loadlib.fortran64.Fortran64.sum_16bit] method.\n\n    Args:\n        a: First 16-bit signed integer.\n        b: Second 16-bit signed integer.\n\n    Returns:\n        The sum, `a + b`.\n    \"\"\"\n    # restype should be defined elsewhere, shown here for illustrative purposes\n    self.lib.sum_16bit.restype = ctypes.c_int16\n\n    ac = ctypes.c_int16(a)\n    bc = ctypes.c_int16(b)\n    result: int = self.lib.sum_16bit(ctypes.byref(ac), ctypes.byref(bc))\n    return result\n</code></pre>"},{"location":"examples/fortran32/#msl.examples.loadlib.fortran32.Fortran32.sum_32bit","title":"sum_32bit","text":"<pre><code>sum_32bit(a, b)\n</code></pre> <p>Add two 32-bit signed integers.</p> <p>Python only has one int data type to represent integer values. This method converts the data types of <code>a</code> and <code>b</code> to be c_int32.</p> <p>The corresponding FORTRAN code is</p> <pre><code>function sum_32bit(a, b) result(value)\n    !DEC$ ATTRIBUTES DLLEXPORT, ALIAS:'sum_32bit' :: sum_32bit\n    implicit none\n    integer(4) :: a, b, value\n    value = a + b\nend function sum_32bit\n</code></pre> <p>See the corresponding Fortran64.sum_32bit method.</p> <p>Parameters:</p> Name Type Description Default <code>a</code> <code>int</code> <p>First 32-bit signed integer.</p> required <code>b</code> <code>int</code> <p>Second 32-bit signed integer.</p> required <p>Returns:</p> Type Description <code>int</code> <p>The sum, <code>a + b</code>.</p> Source code in <code>src/msl/examples/loadlib/fortran32.py</code> <pre><code>def sum_32bit(self, a: int, b: int) -&gt; int:\n    \"\"\"Add two 32-bit signed integers.\n\n    Python only has one [int][]{:target=\"_blank\"} data type to represent integer values.\n    This method converts the data types of `a` and `b` to be\n    [c_int32][ctypes.c_int32]{:target=\"_blank\"}.\n\n    The corresponding FORTRAN code is\n\n    ```fortran\n    function sum_32bit(a, b) result(value)\n        !DEC$ ATTRIBUTES DLLEXPORT, ALIAS:'sum_32bit' :: sum_32bit\n        implicit none\n        integer(4) :: a, b, value\n        value = a + b\n    end function sum_32bit\n    ```\n\n    See the corresponding [Fortran64.sum_32bit][msl.examples.loadlib.fortran64.Fortran64.sum_32bit] method.\n\n    Args:\n        a: First 32-bit signed integer.\n        b: Second 32-bit signed integer.\n\n    Returns:\n        The sum, `a + b`.\n    \"\"\"\n    # restype should be defined elsewhere, shown here for illustrative purposes\n    self.lib.sum_32bit.restype = ctypes.c_int32\n\n    ac = ctypes.c_int32(a)\n    bc = ctypes.c_int32(b)\n    result: int = self.lib.sum_32bit(ctypes.byref(ac), ctypes.byref(bc))\n    return result\n</code></pre>"},{"location":"examples/fortran32/#msl.examples.loadlib.fortran32.Fortran32.sum_64bit","title":"sum_64bit","text":"<pre><code>sum_64bit(a, b)\n</code></pre> <p>Add two 64-bit signed integers.</p> <p>Python only has one int data type to represent integer values. This method converts the data types of <code>a</code> and <code>b</code> to be c_int64.</p> <p>The corresponding FORTRAN code is</p> <pre><code>function sum_64bit(a, b) result(value)\n    !DEC$ ATTRIBUTES DLLEXPORT, ALIAS:'sum_64bit' :: sum_64bit\n    implicit none\n    integer(8) :: a, b, value\n    value = a + b\nend function sum_64bit\n</code></pre> <p>See the corresponding Fortran64.sum_64bit method.</p> <p>Parameters:</p> Name Type Description Default <code>a</code> <code>int</code> <p>First 64-bit signed integer.</p> required <code>b</code> <code>int</code> <p>Second 64-bit signed integer.</p> required <p>Returns:</p> Type Description <code>int</code> <p>The sum, <code>a + b</code>.</p> Source code in <code>src/msl/examples/loadlib/fortran32.py</code> <pre><code>def sum_64bit(self, a: int, b: int) -&gt; int:\n    \"\"\"Add two 64-bit signed integers.\n\n    Python only has one [int][]{:target=\"_blank\"} data type to represent integer values.\n    This method converts the data types of `a` and `b` to be\n    [c_int64][ctypes.c_int64]{:target=\"_blank\"}.\n\n    The corresponding FORTRAN code is\n\n    ```fortran\n    function sum_64bit(a, b) result(value)\n        !DEC$ ATTRIBUTES DLLEXPORT, ALIAS:'sum_64bit' :: sum_64bit\n        implicit none\n        integer(8) :: a, b, value\n        value = a + b\n    end function sum_64bit\n    ```\n\n    See the corresponding [Fortran64.sum_64bit][msl.examples.loadlib.fortran64.Fortran64.sum_64bit] method.\n\n    Args:\n        a: First 64-bit signed integer.\n        b: Second 64-bit signed integer.\n\n    Returns:\n        The sum, `a + b`.\n    \"\"\"\n    # restype should be defined elsewhere, shown here for illustrative purposes\n    self.lib.sum_64bit.restype = ctypes.c_int64\n\n    ac = ctypes.c_int64(a)\n    bc = ctypes.c_int64(b)\n    result: int = self.lib.sum_64bit(ctypes.byref(ac), ctypes.byref(bc))\n    return result\n</code></pre>"},{"location":"examples/fortran32/#msl.examples.loadlib.fortran32.Fortran32.sum_8bit","title":"sum_8bit","text":"<pre><code>sum_8bit(a, b)\n</code></pre> <p>Add two 8-bit signed integers.</p> <p>Python only has one int data type to represent integer values. This method converts the data types of <code>a</code> and <code>b</code> to be c_int8.</p> <p>The corresponding FORTRAN code is</p> <pre><code>function sum_8bit(a, b) result(value)\n    !DEC$ ATTRIBUTES DLLEXPORT, ALIAS:'sum_8bit' :: sum_8bit\n    implicit none\n    integer(1) :: a, b, value\n    value = a + b\nend function sum_8bit\n</code></pre> <p>See the corresponding Fortran64.sum_8bit method.</p> <p>Parameters:</p> Name Type Description Default <code>a</code> <code>int</code> <p>First 8-bit signed integer.</p> required <code>b</code> <code>int</code> <p>Second 8-bit signed integer.</p> required <p>Returns:</p> Type Description <code>int</code> <p>The sum, <code>a + b</code>.</p> Source code in <code>src/msl/examples/loadlib/fortran32.py</code> <pre><code>def sum_8bit(self, a: int, b: int) -&gt; int:\n    \"\"\"Add two 8-bit signed integers.\n\n    Python only has one [int][]{:target=\"_blank\"} data type to represent integer values.\n    This method converts the data types of `a` and `b` to be\n    [c_int8][ctypes.c_int8]{:target=\"_blank\"}.\n\n    The corresponding FORTRAN code is\n\n    ```fortran\n    function sum_8bit(a, b) result(value)\n        !DEC$ ATTRIBUTES DLLEXPORT, ALIAS:'sum_8bit' :: sum_8bit\n        implicit none\n        integer(1) :: a, b, value\n        value = a + b\n    end function sum_8bit\n    ```\n\n    See the corresponding [Fortran64.sum_8bit][msl.examples.loadlib.fortran64.Fortran64.sum_8bit] method.\n\n    Args:\n        a: First 8-bit signed integer.\n        b: Second 8-bit signed integer.\n\n    Returns:\n        The sum, `a + b`.\n    \"\"\"\n    # restype should be defined elsewhere, shown here for illustrative purposes\n    self.lib.sum_8bit.restype = ctypes.c_int8\n\n    ac = ctypes.c_int8(a)\n    bc = ctypes.c_int8(b)\n    result: int = self.lib.sum_8bit(ctypes.byref(ac), ctypes.byref(bc))\n    return result\n</code></pre>"},{"location":"examples/fortran64/","title":"Fortran64","text":"<p>Communicates with the fortran_lib library via the Fortran32 class that is running on a server.</p>"},{"location":"examples/fortran64/#msl.examples.loadlib.fortran64.Fortran64","title":"Fortran64","text":"<pre><code>Fortran64()\n</code></pre> <p>               Bases: <code>Client64</code></p> <p>Communicates with a 32-bit FORTRAN library.</p> <p>This class demonstrates how to communicate with a 32-bit FORTRAN library if an instance of this class is created within a 64-bit Python interpreter.</p> Source code in <code>src/msl/examples/loadlib/fortran64.py</code> <pre><code>def __init__(self) -&gt; None:\n    \"\"\"Communicates with the 32-bit .NET [fortran_lib][fortran-lib] library.\n\n    This class demonstrates how to communicate with a 32-bit FORTRAN library if an\n    instance of this class is created within a 64-bit Python interpreter.\n    \"\"\"\n    # specify the name of the corresponding 32-bit server module, fortran32, which hosts\n    # the 32-bit FORTRAN library -- fortran_lib32.\n    super().__init__(module32=\"fortran32\", append_sys_path=Path(__file__).parent)\n</code></pre>"},{"location":"examples/fortran64/#msl.examples.loadlib.fortran64.Fortran64.add_1d_arrays","title":"add_1d_arrays","text":"<pre><code>add_1d_arrays(a1, a2)\n</code></pre> <p>Perform an element-wise addition of two 1D double-precision arrays.</p> <p>See the corresponding Fortran32.add_1d_arrays method.</p> <p>Parameters:</p> Name Type Description Default <code>a1</code> <code>Sequence[float]</code> <p>First array.</p> required <code>a2</code> <code>Sequence[float]</code> <p>Second array.</p> required <p>Returns:</p> Type Description <code>list[float]</code> <p>The element-wise addition of <code>a1 + a2</code>.</p> Source code in <code>src/msl/examples/loadlib/fortran64.py</code> <pre><code>def add_1d_arrays(self, a1: Sequence[float], a2: Sequence[float]) -&gt; list[float]:\n    \"\"\"Perform an element-wise addition of two 1D double-precision arrays.\n\n    See the corresponding [Fortran32.add_1d_arrays][msl.examples.loadlib.fortran32.Fortran32.add_1d_arrays] method.\n\n    Args:\n        a1: First array.\n        a2: Second array.\n\n    Returns:\n        The element-wise addition of `a1 + a2`.\n    \"\"\"\n    reply: list[float] = self.request32(\"add_1d_arrays\", a1, a2)\n    return reply\n</code></pre>"},{"location":"examples/fortran64/#msl.examples.loadlib.fortran64.Fortran64.add_or_subtract","title":"add_or_subtract","text":"<pre><code>add_or_subtract(a, b, *, do_addition)\n</code></pre> <p>Add or subtract two integers.</p> <p>See the corresponding Fortran32.add_or_subtract method.</p> <p>Parameters:</p> Name Type Description Default <code>a</code> <code>int</code> <p>First integer.</p> required <code>b</code> <code>int</code> <p>Second integer.</p> required <code>do_addition</code> <code>bool</code> <p>Whether to add or subtract the numbers.</p> required <p>Returns:</p> Type Description <code>int</code> <p><code>a + b</code> if <code>do_addition</code> is <code>True</code> else <code>a - b</code>.</p> Source code in <code>src/msl/examples/loadlib/fortran64.py</code> <pre><code>def add_or_subtract(self, a: int, b: int, *, do_addition: bool) -&gt; int:\n    \"\"\"Add or subtract two integers.\n\n    See the corresponding [Fortran32.add_or_subtract][msl.examples.loadlib.fortran32.Fortran32.add_or_subtract]\n    method.\n\n    Args:\n        a: First integer.\n        b: Second integer.\n        do_addition: Whether to add or subtract the numbers.\n\n    Returns:\n        `a + b` if `do_addition` is `True` else `a - b`.\n    \"\"\"\n    reply: int = self.request32(\"add_or_subtract\", a, b, do_addition=do_addition)\n    return reply\n</code></pre>"},{"location":"examples/fortran64/#msl.examples.loadlib.fortran64.Fortran64.besselJ0","title":"besselJ0","text":"<pre><code>besselJ0(x)\n</code></pre> <p>Compute the Bessel function of the first kind of order 0 of x.</p> <p>See the corresponding Fortran32.besselJ0 method.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>float</code> <p>The value to compute <code>BESSEL_J0</code> of.</p> required <p>Returns:</p> Type Description <code>float</code> <p>The value of <code>BESSEL_J0(x)</code>.</p> Source code in <code>src/msl/examples/loadlib/fortran64.py</code> <pre><code>def besselJ0(self, x: float) -&gt; float:  # noqa: N802\n    \"\"\"Compute the Bessel function of the first kind of order 0 of x.\n\n    See the corresponding [Fortran32.besselJ0][msl.examples.loadlib.fortran32.Fortran32.besselJ0] method.\n\n    Args:\n        x: The value to compute `BESSEL_J0` of.\n\n    Returns:\n        The value of `BESSEL_J0(x)`.\n    \"\"\"\n    reply: float = self.request32(\"besselJ0\", x)\n    return reply\n</code></pre>"},{"location":"examples/fortran64/#msl.examples.loadlib.fortran64.Fortran64.factorial","title":"factorial","text":"<pre><code>factorial(n)\n</code></pre> <p>Compute the n'th factorial.</p> <p>See the corresponding Fortran32.factorial method.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int</code> <p>The integer to computer the factorial of. The maximum allowed value is 127.</p> required <p>Returns:</p> Type Description <code>float</code> <p>The factorial of <code>n</code>.</p> Source code in <code>src/msl/examples/loadlib/fortran64.py</code> <pre><code>def factorial(self, n: int) -&gt; float:\n    \"\"\"Compute the n'th factorial.\n\n    See the corresponding [Fortran32.factorial][msl.examples.loadlib.fortran32.Fortran32.factorial] method.\n\n    Args:\n        n: The integer to computer the factorial of. The maximum allowed value is 127.\n\n    Returns:\n        The factorial of `n`.\n    \"\"\"\n    reply: float = self.request32(\"factorial\", n)\n    return reply\n</code></pre>"},{"location":"examples/fortran64/#msl.examples.loadlib.fortran64.Fortran64.is_positive","title":"is_positive","text":"<pre><code>is_positive(a)\n</code></pre> <p>Returns whether the value of the input argument is &gt; 0.</p> <p>See the corresponding Fortran32.is_positive method.</p> <p>Parameters:</p> Name Type Description Default <code>a</code> <code>float</code> <p>Double-precision number.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>Whether the value of <code>a</code> is &gt; 0.</p> Source code in <code>src/msl/examples/loadlib/fortran64.py</code> <pre><code>def is_positive(self, a: float) -&gt; bool:\n    \"\"\"Returns whether the value of the input argument is &gt; 0.\n\n    See the corresponding [Fortran32.is_positive][msl.examples.loadlib.fortran32.Fortran32.is_positive] method.\n\n    Args:\n        a: Double-precision number.\n\n    Returns:\n        Whether the value of `a` is &amp;gt; 0.\n    \"\"\"\n    reply: bool = self.request32(\"is_positive\", a)\n    return reply\n</code></pre>"},{"location":"examples/fortran64/#msl.examples.loadlib.fortran64.Fortran64.matrix_multiply","title":"matrix_multiply","text":"<pre><code>matrix_multiply(a1, a2)\n</code></pre> <p>Multiply two matrices.</p> <p>See the corresponding Fortran32.matrix_multiply method.</p> <p>Parameters:</p> Name Type Description Default <code>a1</code> <code>Sequence[Sequence[float]]</code> <p>First matrix.</p> required <code>a2</code> <code>Sequence[Sequence[float]]</code> <p>Second matrix.</p> required <p>Returns:</p> Type Description <code>list[list[float]]</code> <p>The product, <code>a1 @ a2</code>.</p> Source code in <code>src/msl/examples/loadlib/fortran64.py</code> <pre><code>def matrix_multiply(self, a1: Sequence[Sequence[float]], a2: Sequence[Sequence[float]]) -&gt; list[list[float]]:\n    \"\"\"Multiply two matrices.\n\n    See the corresponding [Fortran32.matrix_multiply][msl.examples.loadlib.fortran32.Fortran32.matrix_multiply]\n    method.\n\n    Args:\n        a1: First matrix.\n        a2: Second matrix.\n\n    Returns:\n        The product, `a1 @ a2`.\n    \"\"\"\n    reply: list[list[float]] = self.request32(\"matrix_multiply\", a1, a2)\n    return reply\n</code></pre>"},{"location":"examples/fortran64/#msl.examples.loadlib.fortran64.Fortran64.multiply_float32","title":"multiply_float32","text":"<pre><code>multiply_float32(a, b)\n</code></pre> <p>Send a request to multiply two FORTRAN floating-point numbers.</p> <p>See the corresponding Fortran32.multiply_float32 method.</p> <p>Parameters:</p> Name Type Description Default <code>a</code> <code>float</code> <p>First floating-point number.</p> required <code>b</code> <code>float</code> <p>Second floating-point number.</p> required <p>Returns:</p> Type Description <code>float</code> <p>The product, <code>a * b</code>.</p> Source code in <code>src/msl/examples/loadlib/fortran64.py</code> <pre><code>def multiply_float32(self, a: float, b: float) -&gt; float:\n    \"\"\"Send a request to multiply two FORTRAN floating-point numbers.\n\n    See the corresponding [Fortran32.multiply_float32][msl.examples.loadlib.fortran32.Fortran32.multiply_float32]\n    method.\n\n    Args:\n        a: First floating-point number.\n        b: Second floating-point number.\n\n    Returns:\n        The product, `a * b`.\n    \"\"\"\n    reply: float = self.request32(\"multiply_float32\", a, b)\n    return reply\n</code></pre>"},{"location":"examples/fortran64/#msl.examples.loadlib.fortran64.Fortran64.multiply_float64","title":"multiply_float64","text":"<pre><code>multiply_float64(a, b)\n</code></pre> <p>Send a request to multiply two FORTRAN double-precision numbers.</p> <p>See the corresponding Fortran32.multiply_float64 method.</p> <p>Parameters:</p> Name Type Description Default <code>a</code> <code>float</code> <p>First double-precision number.</p> required <code>b</code> <code>float</code> <p>Second double-precision number.</p> required <p>Returns:</p> Type Description <code>float</code> <p>The product, <code>a * b</code>.</p> Source code in <code>src/msl/examples/loadlib/fortran64.py</code> <pre><code>def multiply_float64(self, a: float, b: float) -&gt; float:\n    \"\"\"Send a request to multiply two FORTRAN double-precision numbers.\n\n    See the corresponding [Fortran32.multiply_float64][msl.examples.loadlib.fortran32.Fortran32.multiply_float64]\n    method.\n\n    Args:\n        a: First double-precision number.\n        b: Second double-precision number.\n\n    Returns:\n        The product, `a * b`.\n    \"\"\"\n    reply: float = self.request32(\"multiply_float64\", a, b)\n    return reply\n</code></pre>"},{"location":"examples/fortran64/#msl.examples.loadlib.fortran64.Fortran64.reverse_string","title":"reverse_string","text":"<pre><code>reverse_string(original)\n</code></pre> <p>Reverse a string.</p> <p>See the corresponding Fortran32.reverse_string method.</p> <p>Parameters:</p> Name Type Description Default <code>original</code> <code>str</code> <p>The original string.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The string reversed.</p> Source code in <code>src/msl/examples/loadlib/fortran64.py</code> <pre><code>def reverse_string(self, original: str) -&gt; str:\n    \"\"\"Reverse a string.\n\n    See the corresponding [Fortran32.reverse_string][msl.examples.loadlib.fortran32.Fortran32.reverse_string]\n    method.\n\n    Args:\n        original: The original string.\n\n    Returns:\n        The string reversed.\n    \"\"\"\n    reply: str = self.request32(\"reverse_string\", original)\n    return reply\n</code></pre>"},{"location":"examples/fortran64/#msl.examples.loadlib.fortran64.Fortran64.standard_deviation","title":"standard_deviation","text":"<pre><code>standard_deviation(data)\n</code></pre> <p>Compute the standard deviation.</p> <p>See the corresponding Fortran32.standard_deviation method.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Sequence[float]</code> <p>The values to compute the standard deviation of.</p> required <p>Returns:</p> Type Description <code>float</code> <p>The standard deviation of <code>data</code>.</p> Source code in <code>src/msl/examples/loadlib/fortran64.py</code> <pre><code>def standard_deviation(self, data: Sequence[float]) -&gt; float:\n    \"\"\"Compute the standard deviation.\n\n    See the corresponding\n    [Fortran32.standard_deviation][msl.examples.loadlib.fortran32.Fortran32.standard_deviation]\n    method.\n\n    Args:\n        data: The values to compute the standard deviation of.\n\n    Returns:\n        The standard deviation of `data`.\n    \"\"\"\n    reply: float = self.request32(\"standard_deviation\", data)\n    return reply\n</code></pre>"},{"location":"examples/fortran64/#msl.examples.loadlib.fortran64.Fortran64.sum_16bit","title":"sum_16bit","text":"<pre><code>sum_16bit(a, b)\n</code></pre> <p>Send a request to add two 16-bit signed integers.</p> <p>See the corresponding Fortran32.sum_16bit method.</p> <p>Parameters:</p> Name Type Description Default <code>a</code> <code>int</code> <p>First 16-bit signed integer.</p> required <code>b</code> <code>int</code> <p>Second 16-bit signed integer.</p> required <p>Returns:</p> Type Description <code>int</code> <p>The sum, <code>a + b</code>.</p> Source code in <code>src/msl/examples/loadlib/fortran64.py</code> <pre><code>def sum_16bit(self, a: int, b: int) -&gt; int:\n    \"\"\"Send a request to add two 16-bit signed integers.\n\n    See the corresponding [Fortran32.sum_16bit][msl.examples.loadlib.fortran32.Fortran32.sum_16bit] method.\n\n    Args:\n        a: First 16-bit signed integer.\n        b: Second 16-bit signed integer.\n\n    Returns:\n        The sum, `a + b`.\n    \"\"\"\n    reply: int = self.request32(\"sum_16bit\", a, b)\n    return reply\n</code></pre>"},{"location":"examples/fortran64/#msl.examples.loadlib.fortran64.Fortran64.sum_32bit","title":"sum_32bit","text":"<pre><code>sum_32bit(a, b)\n</code></pre> <p>Send a request to add two 32-bit signed integers.</p> <p>See the corresponding Fortran32.sum_32bit method.</p> <p>Parameters:</p> Name Type Description Default <code>a</code> <code>int</code> <p>First 32-bit signed integer.</p> required <code>b</code> <code>int</code> <p>Second 32-bit signed integer.</p> required <p>Returns:</p> Type Description <code>int</code> <p>The sum, <code>a + b</code>.</p> Source code in <code>src/msl/examples/loadlib/fortran64.py</code> <pre><code>def sum_32bit(self, a: int, b: int) -&gt; int:\n    \"\"\"Send a request to add two 32-bit signed integers.\n\n    See the corresponding [Fortran32.sum_32bit][msl.examples.loadlib.fortran32.Fortran32.sum_32bit] method.\n\n    Args:\n        a: First 32-bit signed integer.\n        b: Second 32-bit signed integer.\n\n    Returns:\n        The sum, `a + b`.\n    \"\"\"\n    reply: int = self.request32(\"sum_32bit\", a, b)\n    return reply\n</code></pre>"},{"location":"examples/fortran64/#msl.examples.loadlib.fortran64.Fortran64.sum_64bit","title":"sum_64bit","text":"<pre><code>sum_64bit(a, b)\n</code></pre> <p>Send a request to add two 64-bit signed integers.</p> <p>See the corresponding Fortran32.sum_64bit method.</p> <p>Parameters:</p> Name Type Description Default <code>a</code> <code>int</code> <p>First 64-bit signed integer.</p> required <code>b</code> <code>int</code> <p>Second 64-bit signed integer.</p> required <p>Returns:</p> Type Description <code>int</code> <p>The sum, <code>a + b</code>.</p> Source code in <code>src/msl/examples/loadlib/fortran64.py</code> <pre><code>def sum_64bit(self, a: int, b: int) -&gt; int:\n    \"\"\"Send a request to add two 64-bit signed integers.\n\n    See the corresponding [Fortran32.sum_64bit][msl.examples.loadlib.fortran32.Fortran32.sum_64bit] method.\n\n    Args:\n        a: First 64-bit signed integer.\n        b: Second 64-bit signed integer.\n\n    Returns:\n        The sum, `a + b`.\n    \"\"\"\n    reply: int = self.request32(\"sum_64bit\", a, b)\n    return reply\n</code></pre>"},{"location":"examples/fortran64/#msl.examples.loadlib.fortran64.Fortran64.sum_8bit","title":"sum_8bit","text":"<pre><code>sum_8bit(a, b)\n</code></pre> <p>Send a request to add two 8-bit signed integers.</p> <p>See the corresponding Fortran32.sum_8bit method.</p> <p>Parameters:</p> Name Type Description Default <code>a</code> <code>int</code> <p>First 8-bit signed integer.</p> required <code>b</code> <code>int</code> <p>Second 8-bit signed integer.</p> required <p>Returns:</p> Type Description <code>int</code> <p>The sum, <code>a + b</code>.</p> Source code in <code>src/msl/examples/loadlib/fortran64.py</code> <pre><code>def sum_8bit(self, a: int, b: int) -&gt; int:\n    \"\"\"Send a request to add two 8-bit signed integers.\n\n    See the corresponding [Fortran32.sum_8bit][msl.examples.loadlib.fortran32.Fortran32.sum_8bit] method.\n\n    Args:\n        a: First 8-bit signed integer.\n        b: Second 8-bit signed integer.\n\n    Returns:\n        The sum, `a + b`.\n    \"\"\"\n    reply: int = self.request32(\"sum_8bit\", a, b)\n    return reply\n</code></pre>"},{"location":"examples/kernel32/","title":"Kernel32 (Windows <code>__stdcall</code>)","text":"<p>Wrapper around the 32-bit Windows <code>__stdcall</code> library, kernel32.dll.</p> <p>Example of a server that loads a 32-bit Windows library, kernel32.dll, in a 32-bit Python interpreter to host the library. The corresponding Kernel64 class is created in a 64-bit Python interpreter and the Kernel64 class sends requests to the Kernel32 class which calls the 32-bit library to execute the request and then returns the response from the library.</p> <p>Note</p> <p>This example is only valid on Windows.</p>"},{"location":"examples/kernel32/#msl.examples.loadlib.kernel32.Kernel32","title":"Kernel32","text":"<pre><code>Kernel32(host, port)\n</code></pre> <p>               Bases: <code>Server32</code></p> <p>Wrapper around the 32-bit Windows <code>__stdcall</code> library.</p> <p>Parameters:</p> Name Type Description Default <code>host</code> <code>str</code> <p>The IP address (or hostname) to use for the server.</p> required <code>port</code> <code>int</code> <p>The port to open for the server.</p> required Source code in <code>src/msl/examples/loadlib/kernel32.py</code> <pre><code>def __init__(self, host: str, port: int) -&gt; None:\n    \"\"\"Wrapper around the 32-bit Windows `__stdcall` library, [kernel32.dll]{:target=\"_blank\"}.\n\n    [kernel32.dll]: https://www.geoffchappell.com/studies/windows/win32/kernel32/api/\n\n    Args:\n        host: The IP address (or hostname) to use for the server.\n        port: The port to open for the server.\n    \"\"\"\n    super().__init__(\"C:/Windows/SysWOW64/kernel32.dll\", \"windll\", host, port)\n</code></pre>"},{"location":"examples/kernel32/#msl.examples.loadlib.kernel32.Kernel32.get_local_time","title":"get_local_time","text":"<pre><code>get_local_time()\n</code></pre> <p>Calls the kernel32.GetLocalTime function to get the current date and time.</p> <p>See the corresponding Kernel64.get_local_time method.</p> <p>Returns:</p> Type Description <code>datetime</code> <p>The current date and time.</p> Source code in <code>src/msl/examples/loadlib/kernel32.py</code> <pre><code>def get_local_time(self) -&gt; datetime:\n    \"\"\"Calls the [kernel32.GetLocalTime]{:target=\"_blank\"} function to get the current date and time.\n\n    See the corresponding [Kernel64.get_local_time][msl.examples.loadlib.kernel64.Kernel64.get_local_time] method.\n\n    [kernel32.GetLocalTime]: https://learn.microsoft.com/en-us/windows/win32/api/sysinfoapi/nf-sysinfoapi-getlocaltime\n\n    Returns:\n        The current date and time.\n    \"\"\"\n    st = SystemTime()\n    self.lib.GetLocalTime(ctypes.byref(st))\n    return datetime(  # noqa: DTZ001\n        st.wYear,\n        month=st.wMonth,\n        day=st.wDay,\n        hour=st.wHour,\n        minute=st.wMinute,\n        second=st.wSecond,\n        microsecond=st.wMilliseconds * 1000,\n    )\n</code></pre>"},{"location":"examples/kernel32/#msl.examples.loadlib.kernel32.SystemTime","title":"SystemTime","text":"<p>               Bases: <code>Structure</code></p> <p>A SYSTEMTIME Structure.</p>"},{"location":"examples/kernel64/","title":"Kernel64 (Windows <code>__stdcall</code>)","text":"<p>Communicate with the kernel32.dll library via the Kernel32 class that is running on a server.</p> <p>Note</p> <p>This example is only valid on Windows.</p>"},{"location":"examples/kernel64/#msl.examples.loadlib.kernel64.Kernel64","title":"Kernel64","text":"<pre><code>Kernel64()\n</code></pre> <p>               Bases: <code>Client64</code></p> <p>Communicate with a 32-bit Windows <code>__stdcall</code> library.</p> <p>This class demonstrates how to communicate with a Windows 32-bit library if an instance of this class is created within a 64-bit Python interpreter.</p> Source code in <code>src/msl/examples/loadlib/kernel64.py</code> <pre><code>def __init__(self) -&gt; None:\n    \"\"\"Communicate with a 32-bit Windows `__stdcall` library, [kernel32.dll]{:target=\"_blank\"}.\n\n    This class demonstrates how to communicate with a Windows 32-bit library if an\n    instance of this class is created within a 64-bit Python interpreter.\n\n    [kernel32.dll]: https://www.geoffchappell.com/studies/windows/win32/kernel32/api/\n    \"\"\"\n    # specify the name of the corresponding 32-bit server module, kernel32, which hosts\n    # the Windows 32-bit library -- kernel32.dll\n    super().__init__(module32=\"kernel32\", append_sys_path=Path(__file__).parent)\n</code></pre>"},{"location":"examples/kernel64/#msl.examples.loadlib.kernel64.Kernel64.get_local_time","title":"get_local_time","text":"<pre><code>get_local_time()\n</code></pre> <p>Requests kernel32.GetLocalTime function to get the current date and time.</p> <p>See the corresponding Kernel32.get_local_time method.</p> <p>Returns:</p> Type Description <code>datetime</code> <p>The current date and time.</p> Source code in <code>src/msl/examples/loadlib/kernel64.py</code> <pre><code>def get_local_time(self) -&gt; datetime:\n    \"\"\"Requests [kernel32.GetLocalTime]{:target=\"_blank\"} function to get the current date and time.\n\n    See the corresponding [Kernel32.get_local_time][msl.examples.loadlib.kernel32.Kernel32.get_local_time] method.\n\n    [kernel32.GetLocalTime]: https://learn.microsoft.com/en-us/windows/win32/api/sysinfoapi/nf-sysinfoapi-getlocaltime\n\n    Returns:\n        The current date and time.\n    \"\"\"\n    reply: datetime = self.request32(\"get_local_time\")\n    return reply\n</code></pre>"},{"location":"examples/labview32/","title":"Labview32","text":"<p>Wrapper around a 32-bit LabVIEW library.</p> <p>Example of a server that loads a 32-bit LabVIEW library, labview_lib, in a 32-bit Python interpreter to host the library. The corresponding Labview64 class is created in a 64-bit Python interpreter and the Labview64 class sends requests to the Labview32 class which calls the 32-bit library to execute the request and then returns the response from the library.</p> <p>Attention</p> <p>This example requires that a 32-bit LabVIEW Run-Time Engine is installed and that the operating system is Windows.</p>"},{"location":"examples/labview32/#msl.examples.loadlib.labview32.Labview32","title":"Labview32","text":"<pre><code>Labview32(host, port)\n</code></pre> <p>               Bases: <code>Server32</code></p> <p>Wrapper around the 32-bit LabVIEW library, labview_lib.</p> <p>Parameters:</p> Name Type Description Default <code>host</code> <code>str</code> <p>The IP address (or hostname) to use for the server.</p> required <code>port</code> <code>int</code> <p>The port to open for the server.</p> required Source code in <code>src/msl/examples/loadlib/labview32.py</code> <pre><code>def __init__(self, host: str, port: int) -&gt; None:\n    \"\"\"Wrapper around the 32-bit LabVIEW library, [labview_lib][labview-lib].\n\n    Args:\n        host: The IP address (or hostname) to use for the server.\n        port: The port to open for the server.\n    \"\"\"\n    path = Path(__file__).parent / \"labview_lib32.dll\"\n    super().__init__(path, \"cdll\", host, port)\n</code></pre>"},{"location":"examples/labview32/#msl.examples.loadlib.labview32.Labview32.stdev","title":"stdev","text":"<pre><code>stdev(x, weighting=0)\n</code></pre> <p>Calculates the mean, variance and standard deviation of the values in the input <code>x</code>.</p> <p>See the corresponding Labview64.stdev method.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>Sequence[float]</code> <p>The data to calculate the mean, variance and standard deviation of.</p> required <code>weighting</code> <code>int</code> <p>Whether to calculate the sample (<code>weighting = 0</code>) or the population (<code>weighting = 1</code>) standard deviation and variance.</p> <code>0</code> <p>Returns:</p> Type Description <code>tuple[float, float, float]</code> <p>The mean, variance and standard deviation.</p> Source code in <code>src/msl/examples/loadlib/labview32.py</code> <pre><code>def stdev(self, x: Sequence[float], weighting: int = 0) -&gt; tuple[float, float, float]:\n    \"\"\"Calculates the mean, variance and standard deviation of the values in the input `x`.\n\n    See the corresponding [Labview64.stdev][msl.examples.loadlib.labview64.Labview64.stdev] method.\n\n    Args:\n        x: The data to calculate the mean, variance and standard deviation of.\n        weighting: Whether to calculate the sample (`weighting = 0`) or the\n            population (`weighting = 1`) standard deviation and variance.\n\n    Returns:\n        The mean, variance and standard deviation.\n    \"\"\"\n    data = (c_double * len(x))(*x)\n    mean, variance, std = c_double(), c_double(), c_double()\n    self.lib.stdev(data, len(x), weighting, byref(mean), byref(variance), byref(std))\n    return mean.value, variance.value, std.value\n</code></pre>"},{"location":"examples/labview64/","title":"Labview64","text":"<p>Communicates with the labview_lib library via the Labview32 class that is running on a server.</p> <p>Attention</p> <p>This example requires that a 32-bit LabVIEW Run-Time Engine is installed and that the operating system is Windows.</p>"},{"location":"examples/labview64/#msl.examples.loadlib.labview64.Labview64","title":"Labview64","text":"<pre><code>Labview64()\n</code></pre> <p>               Bases: <code>Client64</code></p> <p>Communicates with a 32-bit LabVIEW library, labview_lib.</p> <p>This class demonstrates how to communicate with a 32-bit LabVIEW library if an instance of this class is created within a 64-bit Python interpreter.</p> Source code in <code>src/msl/examples/loadlib/labview64.py</code> <pre><code>def __init__(self) -&gt; None:\n    \"\"\"Communicates with a 32-bit LabVIEW library, [labview_lib][labview-lib].\n\n    This class demonstrates how to communicate with a 32-bit LabVIEW library if an\n    instance of this class is created within a 64-bit Python interpreter.\n    \"\"\"\n    # specify the name of the corresponding 32-bit server module, labview32, which hosts\n    # the 32-bit LabVIEW library -- labview_lib32.dll\n    super().__init__(module32=\"labview32\", append_sys_path=Path(__file__).parent)\n</code></pre>"},{"location":"examples/labview64/#msl.examples.loadlib.labview64.Labview64.stdev","title":"stdev","text":"<pre><code>stdev(x, weighting=0)\n</code></pre> <p>Calculates the mean, variance and standard deviation of the values in the input <code>x</code>.</p> <p>See the corresponding Labview32.stdev method.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>Sequence[float]</code> <p>The data to calculate the mean, variance and standard deviation of.</p> required <code>weighting</code> <code>int</code> <p>Whether to calculate the sample (<code>weighting = 0</code>) or the population (<code>weighting = 1</code>) standard deviation and variance.</p> <code>0</code> <p>Returns:</p> Type Description <code>tuple[float, float, float]</code> <p>The mean, variance and standard deviation.</p> Source code in <code>src/msl/examples/loadlib/labview64.py</code> <pre><code>def stdev(self, x: Sequence[float], weighting: int = 0) -&gt; tuple[float, float, float]:\n    \"\"\"Calculates the mean, variance and standard deviation of the values in the input `x`.\n\n    See the corresponding [Labview32.stdev][msl.examples.loadlib.labview32.Labview32.stdev] method.\n\n    Args:\n        x: The data to calculate the mean, variance and standard deviation of.\n        weighting: Whether to calculate the sample (`weighting = 0`) or the\n            population (`weighting = 1`) standard deviation and variance.\n\n    Returns:\n        The mean, variance and standard deviation.\n    \"\"\"\n    if weighting not in {0, 1}:\n        msg = f\"The weighting must be either 0 or 1, got {weighting}\"\n        raise ValueError(msg)\n\n    reply: tuple[float, float, float] = self.request32(\"stdev\", x, weighting)\n    return reply\n</code></pre>"},{"location":"faq/freeze/","title":"Freezing the <code>msl-loadlib</code> package","text":"<p>If you want to use PyInstaller or cx-Freeze to bundle <code>msl-loadlib</code> in a frozen application, the 32-bit server must be added as a data file.</p> <p>For example, using PyInstaller on Windows you would include an <code>--add-data</code> option</p> <pre><code>pyinstaller --add-data \"..\\site-packages\\msl\\loadlib\\server32-windows.exe:.\"\n</code></pre> <p>where you must replace the leading <code>..</code> prefix with the parent directories to the file (i.e., specify the absolute path to the file). On Linux, replace <code>server32-windows.exe:.</code> with <code>server32-linux:.</code></p> <p>If the server is loading a .NET library that was compiled with .NET &lt; 4.0, you must also add the <code>server32-windows.exe.config</code> data file. Otherwise, you do not need to add this config file.</p> <p>cx-Freeze appears to automatically bundle the 32-bit server (tested with cx-Freeze version 6.14.5) so there may not be anything you need to do. If the <code>server32</code> executable is not bundled, you can specify the absolute path to the <code>server32</code> executable as the <code>include_files</code> option for the <code>build_exe</code> command.</p> <p>You may also wish to refreeze the 32-bit server and add your custom server to your application.</p>"},{"location":"faq/mock/","title":"Mocking the connection to the server","text":"<p>You may mock the connection to the server by passing in <code>host=None</code> when you instantiate Client64. Also, the Server32 may need to decide which library to load.</p> <p>When the connection is mocked, both Client64 and Server32 instances will run in the same Python interpreter, therefore the server must load a library that is the same bitness as the Python interpreter that the client is running in. The pickle module is not used when the connection is mocked, so there is no overhead of using a file as a middle step to process requests and responses (which has a side effect that a mocked connection can return objects in a server's response that are not pickleable).</p> <p>One reason that you may want to mock the connection is that you wrote a lot of code that had to load a 32-bit library but now a 64-bit version of the library is available. You may also need to support the 32-bit and 64-bit libraries at the same time. Instead of making a relatively large change to your code, or managing different code bases, you can simply specify a keyword argument when instantiating your client class to decide whether to use the 32-bit library or the 64-bit library and the client class behaves exactly the same.</p> <p>Here is an example on how a client (running within 64-bit Python) can have a Server32 subclass load a 32-bit library or a 64-bit library.</p> <pre><code>from msl.loadlib import Client64, Server32\n\nclass MockableServer(Server32):\n\n    def __init__(self, host, port, **kwargs):\n        # Decide which library to load on the server.\n        # `host` is `None` when the connection is mocked.\n        if host is None:\n            path = \"path/to/64bit/c/library.so\"\n        else:\n            path = \"path/to/32bit/c/library.so\"\n        super().__init__(path, \"cdll\", host, port)\n\nclass MockableClient(Client64):\n\n    def __init__(self, **kwargs):\n        super().__init__(__file__, **kwargs)\n\nif __name__ == \"__main__\":\n    client_uses_32bit_library = MockableClient()\n    client_uses_64bit_library = MockableClient(host=None)\n</code></pre>"},{"location":"faq/streams/","title":"Access <code>stdout</code> and <code>stderr</code> from the server","text":"<p>You have access to the console output, <code>stdout</code> and <code>stderr</code>, of the 32-bit server once it has shut down. For example, suppose your 64-bit client class is called <code>MyClient</code>, you could do something like</p> <pre><code>c = MyClient()\nc.do_something()\nc.do_something_else()\nstdout, stderr = c.shutdown_server32()\nprint(stdout.read())\nprint(stderr.read())\n</code></pre> <p>If you want to be able to poll the console output in real time (while the server is running) you have two options:</p> <ol> <li> <p>Have the server write to a file and the client read from the file.</p> </li> <li> <p>Implement a <code>polling</code> method on the server for the client to send requests to. The following is a runnable example</p> </li> </ol> <pre><code>import os\n\nfrom msl.loadlib import Client64, Server32\n\nclass Polling32(Server32):\n\n    def __init__(self, host, port):\n        # Loading a \"dummy\" 32-bit library for this example\n        path = os.path.join(Server32.examples_dir(), \"cpp_lib32\")\n        super().__init__(path, \"cdll\", host, port)\n\n        # Create a list to store 'print' messages in\n        self._stdout = []\n\n        # Use your own print method instead of calling the\n        # builtin print() function\n        self.print(\"Polling32 has been initiated\")\n\n    def say_hello(self, name):\n        \"\"\"Return a greeting.\"\"\"\n        self.print(f\"say_hello was called with argument {name!r}\")\n        return f\"Hello, {name}!\"\n\n    def poll(self):\n        \"\"\"Get the latest message.\"\"\"\n        try:\n            return self._stdout[-1]\n        except IndexError:\n            return \"\"\n\n    def flush(self):\n        \"\"\"Get all messages and clear the cache.\"\"\"\n        messages = \"\\n\".join(self._stdout)\n        self._stdout.clear()\n        return messages\n\n    def print(self, message):\n        \"\"\"Append a message.\"\"\"\n        self._stdout.append(message)\n\nclass Polling64(Client64):\n\n    def __init__(self):\n        super().__init__(__file__)\n\n    def __getattr__(self, name):\n        def send(*args, **kwargs):\n            return self.request32(name, *args, **kwargs)\n        return send\n\n# Only execute this section of code on the 64-bit client\n# (not on the 32-bit server). You may also prefer to write the\n# Server32 class and the Client64 class in separate files.\nif __name__ == \"__main__\":\n    p = Polling64()\n    print(\"poll -&gt;\", p.poll())\n    print(\"say_hello -&gt;\", p.say_hello(\"world\"))\n    print(\"poll -&gt;\", p.poll())\n    print(\"flush -&gt;\", repr(p.flush()))\n    print(\"poll -&gt;\", repr(p.poll()))\n    p.shutdown_server32()\n</code></pre> <p>Running the above script will output:</p> <pre><code>poll -&gt; Polling32 has been initiated\nsay_hello -&gt; Hello, world!\npoll -&gt; say_hello was called with argument 'world'\nflush -&gt; \"Polling32 has been initiated\\nsay_hello was called with argument 'world'\"\npoll -&gt; ''\n</code></pre>"},{"location":"usage/overview/","title":"Overview","text":"<p>There are two ways to load a library</p> <ol> <li>Directly load a 64-bit library in 64-bit Python (or a 32-bit library in 32-bit Python)</li> <li>Use a Client-Server implementation to communicate with a 32-bit library from 64-bit Python. You may also create a custom server.</li> </ol>"},{"location":"usage/refreeze/","title":"Custom Server","text":"<p>If you want to create a custom 32-bit server, you will need</p> <ul> <li>a 32-bit version of Python (version 3.8 or later) installed</li> <li>PyInstaller installed in the 32-bit Python environment (ideally, you would use a virtual environment to install the necessary packages to create the server)</li> </ul> <p>Some reasons why you may want to create a custom 32-bit server are that you want to</p> <ul> <li>run the server with a different version of Python,</li> <li>build the server for a different architecture,</li> <li>install a different version of <code>comtypes</code> or <code>pythonnet</code> (on Windows),</li> <li>install additional packages on the server (e.g., <code>numpy</code>, <code>my_custom_package</code>),</li> <li>embed your own data files in the frozen server.</li> </ul> <p>Using pip from a 32-bit Python interpreter, run</p> <p>You may also want to install additional packages.</p> <pre><code>pip install msl-loadlib pyinstaller\n</code></pre> <p>You have two options to create a 32-bit server</p> <ol> <li>Using the API</li> <li>Using the CLI</li> </ol> <p>and you have two options to use your custom server</p> <ol> <li>Copy your <code>server32-*</code> file to the <code>../site-packages/msl/loadlib</code> directory where you have <code>msl-loadlib</code> installed in your 64-bit version of Python to replace the existing server file.</li> <li>Specify the directory where your <code>server32-*</code> file is located as the value of the <code>server32_dir</code> keyword argument in Client64.</li> </ol>"},{"location":"usage/refreeze/#refreeze-api","title":"Using the API","text":"<p>Create a script that calls the freeze_server32.main function with the appropriate keyword arguments and run your script using a 32-bit Python interpreter. For example, the following script will include 32-bit <code>numpy</code> on the server</p> <pre><code>from msl.loadlib import freeze_server32\nfreeze_server32.main(imports=\"numpy\")\n</code></pre>"},{"location":"usage/refreeze/#refreeze-cli","title":"Using the CLI","text":"<p>When <code>msl-loadlib</code> is installed, a console script is included (named <code>freeze32</code>) that may be executed from the command line to create a new frozen 32-bit server.</p> <p>To see the help for <code>freeze32</code>, run</p> <pre><code>freeze32 --help\n</code></pre> <p>For example, if you want to include your own package and data files, you would run</p> <pre><code>freeze32 --imports my_package --data .\\my_data\\lib32.dll\n</code></pre>"},{"location":"usage/direct/","title":"Directly loading a library","text":"<p>If you are loading a 64-bit library in 64-bit Python (or a 32-bit library in 32-bit Python) then you can directly load the library using the LoadLibrary class.</p> <p>Attention</p> <p>See Client-Server if you want to load a 32-bit library in 64-bit Python.</p> <p>The following examples are included with the <code>msl-loadlib</code> package:</p> <ul> <li>C++ \u2013 compiled in 32- and 64-bit Windows and Linux and in 64-bit macOS</li> <li>FORTRAN \u2013 compiled in 32- and 64-bit Windows and Linux and in 64-bit macOS</li> <li>.NET \u2013 complied in 32- and 64-bit using Microsoft Visual Studio 2017</li> <li>Java \u2013 platform and bitness independent since it runs in the JVM</li> <li>COM \u2013 load a Component Object Model library on Windows</li> <li>ActiveX \u2013 illustrates how to load ActiveX controls on Windows</li> <li>Windows __stdcall \u2013 a 32-bit library that uses the <code>__stdcall</code> calling convention</li> <li>LabVIEW \u2013 built using 32- and 64-bit LabVIEW on Windows</li> </ul>"},{"location":"usage/direct/activex/","title":"ActiveX","text":"<p>The following runnable example shows how to create a main window that (could) contain ActiveX controls and how to create a menubar in the application to handle callbacks. This example is only valid on Windows and requires comtypes to be installed.</p> <pre><code>from __future__ import annotations\n\nimport sys\n\nfrom msl.loadlib.activex import Application, Icon, MenuGroup, MenuItem\n\n\ndef letter_clicked(item: MenuItem) -&gt; None:\n    \"\"\"A callback function. You could interact with the `ocx` object.\"\"\"\n    print(item, item.data)\n    if item.text == \"C\":\n        item.checked = not item.checked\n\n\ndef group_clicked(item: MenuItem) -&gt; None:\n    \"\"\"A callback function. You could interact with the `ocx` object.\"\"\"\n    print(item)\n    group.checked = item\n\n\n# Create an application window\napp = Application(title=\"My ActiveX Control\", icon=Icon(sys.executable))\n\n# Create a new 'Letters' menu\nletters = app.menu.create(\"Letters\")\n\n# Append items to the 'Letters' menu\napp.menu.append(letters, \"A\")\napp.menu.append(letters, \"B\", callback=letter_clicked, data=1)\napp.menu.append_separator(letters)\napp.menu.append(letters, \"C\", callback=letter_clicked, data=[1, 2, 3])\n\n# Create a new menu group\ngroup = MenuGroup()\ngroup.append(\"Group 1\", callback=group_clicked)\ngroup.append(\"Group 2\", callback=group_clicked)\ngroup.append(\"Group 3\", callback=group_clicked)\n\n# Create a new 'Numbers' menu\nnumbers = app.menu.create(\"Numbers\")\n# Add the group to the 'Numbers' menu\napp.menu.append_group(numbers, group)\n# Add a separator then another item\napp.menu.append_separator(numbers)\napp.menu.append(numbers, \"Not in Group\")\n\n# Define the size of the main application window\nwidth = 300\nheight = 300\n\n# Uncomment the next line to load your ActiveX control in the main window\n# ocx = app.load(\"My.OCX.Application\", width=width, height=height)\n\napp.set_window_size(width, height)\napp.show()\n\n# Calling `app.run` is a blocking call. You may not want to call it yet\n# (or at all) and interact with the `ocx` object. It is shown here to keep\n# the window open until it is manually closed.\napp.run()\n</code></pre>"},{"location":"usage/direct/com/","title":"COM","text":"<p>To load a Component Object Model (COM) library you pass in the library's Program or Class ID. To view the COM libraries that are available on your computer you can use the get_com_info function.</p> <p>Attention</p> <p>This example is only valid on Windows.</p> <p>Here we load the FileSystemObject and include the <code>\"com\"</code> argument to indicate that it is a COM library</p> <pre><code>&gt;&gt;&gt; from msl.loadlib import LoadLibrary\n&gt;&gt;&gt; com = LoadLibrary(\"Scripting.FileSystemObject\", \"com\")\n&gt;&gt;&gt; com\n&lt;LoadLibrary libtype=POINTER(IFileSystem3) path=Scripting.FileSystemObject&gt;\n</code></pre> <p>We can then use the library to create, edit and close a text file by using the CreateTextFile method</p> <pre><code>&gt;&gt;&gt; fp = com.lib.CreateTextFile(\"a_new_file.txt\")\n&gt;&gt;&gt; fp.Write(\"This is a test.\")\n0\n&gt;&gt;&gt; fp.Close()\n0\n</code></pre> <p>Verify that the file exists and that the text is correct</p> <pre><code>&gt;&gt;&gt; com.lib.FileExists(\"a_new_file.txt\")\nTrue\n&gt;&gt;&gt; file = com.lib.OpenTextFile(\"a_new_file.txt\")\n&gt;&gt;&gt; file.ReadAll()\n'This is a test.'\n&gt;&gt;&gt; file.Close()\n0\n</code></pre>"},{"location":"usage/direct/cpp/","title":"C++","text":"<p>Load the example 64-bit C++ library in 64-bit Python. To load the 32-bit library in 32-bit Python use <code>\"cpp_lib32\"</code> as the filename.</p> <p>Tip</p> <p>If the file extension is not specified, a default extension, <code>.dll</code> (Windows), <code>.so</code> (Linux) or <code>.dylib</code> (macOS) is used.</p>"},{"location":"usage/direct/cpp/#example","title":"Example","text":"<p>Load the example C++ library</p> <pre><code>&gt;&gt;&gt; from msl.loadlib import LoadLibrary\n&gt;&gt;&gt; from msl.examples.loadlib import EXAMPLES_DIR\n&gt;&gt;&gt; cpp = LoadLibrary(EXAMPLES_DIR / \"cpp_lib64\")\n</code></pre> <p>By default, ctypes treats all input argument types and the return type of a library function to be a c_int. Therefore, the argtypes and the restype should be defined for each function in the library. A few examples for the C++ library are shown below</p> <pre><code>&gt;&gt;&gt; from ctypes import c_char_p, c_float, c_int32\n&gt;&gt;&gt; cpp.lib.subtract.argtypes = [c_float, c_float]\n&gt;&gt;&gt; cpp.lib.subtract.restype = c_float\n&gt;&gt;&gt; cpp.lib.reverse_string_v1.argtypes = [c_char_p, c_int32, c_char_p]\n&gt;&gt;&gt; cpp.lib.reverse_string_v1.restype = None\n</code></pre> <p>Call the <code>add</code> function to calculate the sum of two integers</p> <pre><code>&gt;&gt;&gt; cpp.lib.add(1, 2)\n3\n</code></pre> <p>Call the <code>subtract</code> function to calculate the difference between two floats</p> <pre><code>&gt;&gt;&gt; cpp.lib.subtract(7.1, 2.1)\n5.0\n</code></pre> <p>Call the <code>reverse_string_v1</code> function to reverse the characters in a byte string. Python manages the memory of the reversed sting by creating a string buffer of the necessary length</p> <pre><code>&gt;&gt;&gt; from ctypes import create_string_buffer\n&gt;&gt;&gt; original = b\"olleh\"\n&gt;&gt;&gt; reverse = create_string_buffer(len(original))\n&gt;&gt;&gt; cpp.lib.reverse_string_v1(original, len(original), reverse)\n&gt;&gt;&gt; reverse.raw.decode()\n'hello'\n</code></pre>"},{"location":"usage/direct/cpp/#cpp-lib","title":"C++ Source Code","text":"cpp_lib cpp_lib.cppcpp_lib.h <pre><code>// cpp_lib.cpp\n// Examples that show how to pass various data types between Python and a C++ library.\n//\n// Compiled using:\n//   g++ cpp_lib.cpp -fPIC -shared -Bstatic -Wall -o cpp_lib64.so\n//\n#include &lt;math.h&gt;\n#include \"cpp_lib.h\"\n\nint add(int a, int b) {\n    return a + b;\n}\n\nfloat subtract(float a, float b) {\n    return a - b;\n}\n\ndouble add_or_subtract(double a, double b, bool do_addition) {\n    if (do_addition) {\n        return a + b;\n    } else {\n        return a - b;\n    }\n}\n\nvoid scalar_multiply(double a, double* xin, int n, double* xout) {\n    for (int i = 0; i &lt; n; i++) {\n        xout[i] = a * xin[i];\n    }\n}\n\nvoid reverse_string_v1(const char* original, int n, char* reversed) {\n    for (int i = 0; i &lt; n; i++) {\n        reversed[i] = original[n-i-1];\n    }\n}\n\nchar* reverse_string_v2(char* original, int n) {\n    char* reversed = new char[n];\n    for (int i = 0; i &lt; n; i++) {\n        reversed[i] = original[n - i - 1];\n    }\n    return reversed;\n}\n\n// this function is not exported to the shared library\ndouble distance(Point p1, Point p2) {\n    double d = sqrt(pow(p1.x - p2.x, 2) + pow(p1.y - p2.y, 2));\n    return d;\n}\n\ndouble distance_4_points(FourPoints p) {\n    double d = distance(p.points[0], p.points[3]);\n    for (int i = 1; i &lt; 4; i++) {\n        d += distance(p.points[i], p.points[i-1]);\n    }\n    return d;\n}\n\ndouble distance_n_points(NPoints p) {\n    if (p.n &lt; 2) {\n        return 0.0;\n    }\n    double d = distance(p.points[0], p.points[p.n-1]);\n    for (int i = 1; i &lt; p.n; i++) {\n        d += distance(p.points[i], p.points[i-1]);\n    }\n    return d;\n}\n</code></pre> <pre><code>// cpp_lib.h\n// Contains the declaration of exported functions.\n//\n\n#if defined(_MSC_VER)\n    // Microsoft\n    #define EXPORT __declspec(dllexport)\n#elif defined(__GNUC__)\n    // G++\n    #define EXPORT __attribute__((visibility(\"default\")))\n#else\n#   error \"Unknown EXPORT semantics\"\n#endif\n\nstruct Point {\n    double x;\n    double y;\n};\n\nstruct FourPoints {\n    Point points[4];\n};\n\nstruct NPoints {\n    int n;\n    Point *points;\n};\n\nextern \"C\" {\n\n    // a + b\n    EXPORT int add(int a, int b);\n\n    // a - b\n    EXPORT float subtract(float a, float b);\n\n    // IF do_addition IS TRUE THEN a + b ELSE a - b\n    EXPORT double add_or_subtract(double a, double b, bool do_addition);\n\n    // multiply each element in 'x' by 'a'\n    EXPORT void scalar_multiply(double a, double* xin, int n, double* xout);\n\n    // reverse a string\n    EXPORT void reverse_string_v1(const char* original, int n, char* reversed);\n\n    // reverse a string and return it\n    EXPORT char* reverse_string_v2(char* original, int n);\n\n    // calculate the total distance connecting 4 Points\n    EXPORT double distance_4_points(FourPoints p);\n\n    // calculate the total distance connecting N Points\n    EXPORT double distance_n_points(NPoints p);\n\n}\n</code></pre>"},{"location":"usage/direct/dotnet/","title":".NET","text":"<p>Load a 64-bit C# library (a .NET Framework) in 64-bit Python. Include the <code>\"net\"</code> argument to indicate that the <code>.dll</code> file is for the .NET Framework. To load the 32-bit library in 32-bit Python use <code>\"dotnet_lib32.dll\"</code> as the filename.</p>"},{"location":"usage/direct/dotnet/#example","title":"Example","text":"<p>Load the example .NET library</p> <p>Tip</p> <p><code>\"clr\"</code> is an alias for <code>\"net\"</code> and can also be used as the value of <code>libtype</code> when instantiating LoadLibrary.</p> <pre><code>&gt;&gt;&gt; from msl.loadlib import LoadLibrary\n&gt;&gt;&gt; from msl.examples.loadlib import EXAMPLES_DIR\n&gt;&gt;&gt; net = LoadLibrary(EXAMPLES_DIR / \"dotnet_lib64.dll\", \"net\")\n</code></pre> <p>The library contains a reference to the <code>DotNetMSL</code> module (which is a C# namespace), the <code>StaticClass</code> class, the <code>StringManipulation</code> class and the System namespace.</p> <p>Create an instance of the <code>BasicMath</code> class in the <code>DotNetMSL</code> namespace and call the <code>multiply_doubles</code> method</p> <pre><code>&gt;&gt;&gt; bm = net.lib.DotNetMSL.BasicMath()\n&gt;&gt;&gt; bm.multiply_doubles(2.3, 5.6)\n12.879999...\n</code></pre> <p>Create an instance of the <code>ArrayManipulation</code> class in the <code>DotNetMSL</code> namespace and call the <code>scalar_multiply</code> method</p> <pre><code>&gt;&gt;&gt; am = net.lib.DotNetMSL.ArrayManipulation()\n&gt;&gt;&gt; values = am.scalar_multiply(2., [1., 2., 3., 4., 5.])\n&gt;&gt;&gt; values\n&lt;System.Double[] object at ...&gt;\n&gt;&gt;&gt; [val for val in values]\n[2.0, 4.0, 6.0, 8.0, 10.0]\n</code></pre> <p>Call the <code>reverse_string</code> method in the <code>StringManipulation</code> class to reverse a string</p> <pre><code>&gt;&gt;&gt; net.lib.StringManipulation().reverse_string(\"abcdefghijklmnopqrstuvwxyz\")\n'zyxwvutsrqponmlkjihgfedcba'\n</code></pre> <p>Call the static <code>add_multiple</code> method in the <code>StaticClass</code> class to add five integers</p> <pre><code>&gt;&gt;&gt; net.lib.StaticClass.add_multiple(1, 2, 3, 4, 5)\n15\n</code></pre> <p>One can create objects from the System namespace,</p> <pre><code>&gt;&gt;&gt; System = net.lib.System\n</code></pre> <p>for example, to create a 32-bit signed integer,</p> <pre><code>&gt;&gt;&gt; System.Int32(9)\n&lt;System.Int32 object at ...&gt;\n</code></pre> <p>or, a one-dimensional Array of the specified Type</p> <pre><code>&gt;&gt;&gt; array = System.Array[int](list(range(10)))\n&gt;&gt;&gt; array\n&lt;System.Int32[] object at ...&gt;\n&gt;&gt;&gt; list(array)\n[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n&gt;&gt;&gt; array[0] = -1\n&gt;&gt;&gt; list(array)\n[-1, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n</code></pre>"},{"location":"usage/direct/dotnet/#config-runtime","title":"Configure a .NET runtime","text":"<p>To configure <code>pythonnet</code> to use the .NET Core runtime, you must either run</p> <pre><code>from pythonnet import load\nload(\"coreclr\")\n</code></pre> <p>or define a <code>PYTHONNET_RUNTIME=coreclr</code> environment variable, e.g.,</p> <pre><code>import os\nos.environ[\"PYTHONNET_RUNTIME\"] = \"coreclr\"\n</code></pre> <p>before LoadLibrary is called. To use the Mono runtime, replace <code>\"coreclr\"</code> with <code>\"mono\"</code>.</p>"},{"location":"usage/direct/dotnet/#dotnet-lib","title":".NET Source Code","text":"dotnet_lib.cs <pre><code>// dotnet_lib.cs\n// Examples that show how to pass various data types between Python and a C# library.\n//\nusing System;\n\n// The DotNetMSL namespace contains two classes: BasicMath, ArrayManipulation\nnamespace DotNetMSL\n{\n    // A class that is part of the DotNetMSL namespace\n    public class BasicMath\n    {\n\n        public int add_integers(int a, int b)\n        {\n            return a + b;\n        }\n\n        public float divide_floats(float a, float b)\n        {\n            return a / b;\n        }\n\n        public double multiply_doubles(double a, double b)\n        {\n            return a * b;\n        }\n\n        public double add_or_subtract(double a, double b, bool do_addition)\n        {\n            if (do_addition)\n            {\n                return a + b;\n            }\n            else\n            {\n                return a - b;\n            }\n        }\n\n    }\n\n    // A class that is part of the DotNetMSL namespace\n    public class ArrayManipulation\n    {\n\n        public double[] scalar_multiply(double a, double[] xin)\n        {\n            int n = xin.GetLength(0);\n            double[] xout = new double[n];\n            for (int i = 0; i &lt; n; i++)\n            {\n                xout[i] = a * xin[i];\n            }\n            return xout;\n        }\n\n        public double[,] multiply_matrices(double[,] A, double[,] B)\n        {\n            int rA = A.GetLength(0);\n            int cA = A.GetLength(1);\n            int rB = B.GetLength(0);\n            int cB = B.GetLength(1);\n            double temp = 0;\n            double[,] C = new double[rA, cB];\n            if (cA != rB)\n            {\n                Console.WriteLine(\"matrices can't be multiplied!\");\n                return new double[0, 0];\n            }\n            else\n            {\n                for (int i = 0; i &lt; rA; i++)\n                {\n                    for (int j = 0; j &lt; cB; j++)\n                    {\n                        temp = 0;\n                        for (int k = 0; k &lt; cA; k++)\n                        {\n                            temp += A[i, k] * B[k, j];\n                        }\n                        C[i, j] = temp;\n                    }\n                }\n                return C;\n            }\n        }\n\n    }\n}\n\n// A class that is not part of the DotNetMSL namespace\npublic class StringManipulation\n{\n\n    public string reverse_string(string original)\n    {\n        char[] charArray = original.ToCharArray();\n        Array.Reverse(charArray);\n        return new string(charArray);\n    }\n\n}\n\n// A static class\npublic static class StaticClass\n{\n\n    public static int add_multiple(int a, int b, int c, int d, int e)\n    {\n        return a + b + c + d + e;\n    }\n\n    public static string concatenate(string a, string b, string c, bool d, string e)\n    {\n        string res = a + b + c;\n        if (d)\n        {\n            res += e;\n        }\n        return res;\n\n    }\n\n}\n</code></pre>"},{"location":"usage/direct/fortran/","title":"FORTRAN","text":"<p>Load a 64-bit FORTRAN library in 64-bit Python. To load the 32-bit library in 32-bit Python use <code>\"fortran_lib32\"</code> as the filename.</p> <p>Tip</p> <p>If the file extension is not specified, a default extension, <code>.dll</code> (Windows), <code>.so</code> (Linux) or <code>.dylib</code> (macOS) is used.</p>"},{"location":"usage/direct/fortran/#example","title":"Example","text":"<p>Load the example FORTRAN library</p> <pre><code>&gt;&gt;&gt; from msl.loadlib import LoadLibrary\n&gt;&gt;&gt; from msl.examples.loadlib import EXAMPLES_DIR\n&gt;&gt;&gt; fortran = LoadLibrary(EXAMPLES_DIR / \"fortran_lib64\")\n</code></pre> <p>Call the <code>factorial</code> function. With a FORTRAN library you must pass values by reference using byref and since the returned value is not of type c_int the restype must be configured for a value of type c_double to be returned from the library function</p> <pre><code>&gt;&gt;&gt; from ctypes import byref, c_int, c_double\n&gt;&gt;&gt; fortran.lib.factorial.restype = c_double\n&gt;&gt;&gt; fortran.lib.factorial(byref(c_int(37)))\n1.3763753091226343e+43\n</code></pre>"},{"location":"usage/direct/fortran/#fortran-lib","title":"FORTRAN Source Code","text":"fortran_lib.f90 <pre><code>! fortran_lib.f90\n!\n! Basic examples of passing different data types to a FORTRAN function and subroutine.\n!\n! Compiled in Windows using:\n! gfortran -fno-underscoring -fPIC fortran_lib.f90 -static -shared -o fortran_lib64.dll\n!\n\n! return the sum of two 8-bit signed integers\nfunction sum_8bit(a, b) result(value)\n    !DEC$ ATTRIBUTES DLLEXPORT, ALIAS:'sum_8bit' :: sum_8bit\n    implicit none\n    integer(1) :: a, b, value\n    value = a + b\nend function sum_8bit\n\n\n! return the sum of two 16-bit signed integers\nfunction sum_16bit(a, b) result(value)\n    !DEC$ ATTRIBUTES DLLEXPORT, ALIAS:'sum_16bit' :: sum_16bit\n    implicit none\n    integer(2) :: a, b, value\n    value = a + b\nend function sum_16bit\n\n\n! return the sum of two 32-bit signed integers\nfunction sum_32bit(a, b) result(value)\n    !DEC$ ATTRIBUTES DLLEXPORT, ALIAS:'sum_32bit' :: sum_32bit\n    implicit none\n    integer(4) :: a, b, value\n    value = a + b\nend function sum_32bit\n\n\n! return the sum of two 64-bit signed integers\nfunction sum_64bit(a, b) result(value)\n    !DEC$ ATTRIBUTES DLLEXPORT, ALIAS:'sum_64bit' :: sum_64bit\n    implicit none\n    integer(8) :: a, b, value\n    value = a + b\nend function sum_64bit\n\n\n! return the product of two 32-bit floating point numbers\nfunction multiply_float32(a, b) result(value)\n    !DEC$ ATTRIBUTES DLLEXPORT, ALIAS:'multiply_float32' :: multiply_float32\n    implicit none\n    real(4) :: a, b, value\n    value = a * b\nend function multiply_float32\n\n\n! return the product of two 64-bit floating point numbers\nfunction multiply_float64(a, b) result(value)\n    !DEC$ ATTRIBUTES DLLEXPORT, ALIAS:'multiply_float64' :: multiply_float64\n    implicit none\n    real(8) :: a, b, value\n    value = a * b\nend function multiply_float64\n\n\n! return True if 'a' &gt; 0 else False \nfunction is_positive(a) result(value)\n    !DEC$ ATTRIBUTES DLLEXPORT, ALIAS:'is_positive' :: is_positive\n    implicit none\n    logical :: value\n    real(8) :: a\n    value = a &gt; 0.d0\nend function is_positive\n\n\n! if do_addition is True return a+b otherwise return a-b\nfunction add_or_subtract(a, b, do_addition) result(value)\n    !DEC$ ATTRIBUTES DLLEXPORT, ALIAS:'add_or_subtract' :: add_or_subtract\n    implicit none\n    logical :: do_addition\n    integer(4) :: a, b, value\n    if (do_addition) then\n        value = a + b\n    else\n        value = a - b\n    endif\nend function add_or_subtract\n\n\n! compute the n'th factorial of a 8-bit signed integer, return a double-precision number\nfunction factorial(n) result(value)\n    !DEC$ ATTRIBUTES DLLEXPORT, ALIAS:'factorial' :: factorial\n    implicit none\n    integer(1) :: n\n    integer(4) :: i\n    double precision value\n    if (n &lt; 0) then\n        value = 0.d0\n        print *, \"Cannot compute the factorial of a negative number\", n\n    else\n        value = 1.d0\n        do i = 2, n\n            value = value * i\n        enddo\n    endif\nend function factorial\n\n\n! calculate the standard deviation of an array.\nfunction standard_deviation(a, n) result(var)\n    !DEC$ ATTRIBUTES DLLEXPORT, ALIAS:'standard_deviation' :: standard_deviation\n    integer :: n ! the length of the array\n    double precision :: var, a(n)\n    var = SUM(a)/SIZE(a) ! SUM is a built-in fortran function\n    var = SQRT(SUM((a-var)**2)/(SIZE(a)-1.0))\nend function standard_deviation\n\n\n! compute the Bessel function of the first kind of order 0 of x\nfunction besselj0(x) result(val)\n    !DEC$ ATTRIBUTES DLLEXPORT, ALIAS:'besselj0' :: besselj0\n    double precision :: x, val\n    val = BESSEL_J0(x)\nend function besselJ0\n\n\n! reverse a string, 'n' is the length of the original string\nsubroutine reverse_string(original, n, reversed)\n    !DEC$ ATTRIBUTES DLLEXPORT, ALIAS:'reverse_string' :: reverse_string\n    !DEC$ ATTRIBUTES REFERENCE :: original, reversed\n    implicit none\n    integer :: i, n\n    character(len=n) :: original, reversed\n    do i = 1, n\n        reversed(i:i) = original(n-i+1:n-i+1)\n    end do\nend subroutine reverse_string\n\n\n! element-wise addition of two 1D double-precision arrays\nsubroutine add_1d_arrays(a, in1, in2, n)\n    !DEC$ ATTRIBUTES DLLEXPORT, ALIAS:'add_1d_arrays' :: add_1d_arrays\n    implicit none\n    integer(4) :: n ! the length of the input arrays\n    double precision :: in1(n), in2(n) ! the arrays to add (element-wise)\n    double precision :: a(n) ! the array that will contain the element-wise sum\n    a(:) = in1(:) + in2(:)\n    end subroutine add_1d_arrays\n\n\n! multiply two 2D, double-precision arrays. \n! NOTE: multi-dimensional arrays are column-major order in FORTRAN, \n!       whereas C (Python) is row-major order.\nsubroutine matrix_multiply(a, a1, r1, c1, a2, r2, c2)\n    !DEC$ ATTRIBUTES DLLEXPORT, ALIAS:'matrix_multiply' :: matrix_multiply\n    implicit none\n    integer(4) :: r1, c1, r2, c2 ! the dimensions of the input arrays\n    double precision :: a1(r1,c1), a2(r2,c2) ! the arrays to multiply\n    double precision :: a(r1,c2) ! resultant array\n    a = MATMUL(a1, a2)\nend subroutine matrix_multiply\n</code></pre>"},{"location":"usage/direct/java/","title":"Java","text":"<p>Since Java byte code is executed in a JVM it doesn't matter whether it was built with a 32- or 64-bit Java Development Kit. The Python interpreter does not load the Java byte code but communicates with the JVM through a local network socket that is managed by Py4J.</p>"},{"location":"usage/direct/java/#example-jar","title":"Example (.jar)","text":"<p>Load the example Java archive, <code>java_lib.jar</code></p> <pre><code>&gt;&gt;&gt; from msl.loadlib import LoadLibrary\n&gt;&gt;&gt; from msl.examples.loadlib import EXAMPLES_DIR\n&gt;&gt;&gt; jar = LoadLibrary(EXAMPLES_DIR / \"java_lib.jar\")\n&gt;&gt;&gt; jar\n&lt;LoadLibrary libtype=JVMView path=...java_lib.jar&gt;\n&gt;&gt;&gt; jar.gateway\n&lt;py4j.java_gateway.JavaGateway object at ...&gt;\n</code></pre> <p>The Java archive contains a <code>nz.msl.examples</code> package with two classes, <code>MathUtils</code> and <code>Matrix</code></p> <pre><code>&gt;&gt;&gt; MathUtils = jar.lib.nz.msl.examples.MathUtils\n&gt;&gt;&gt; Matrix = jar.lib.nz.msl.examples.Matrix\n</code></pre> <p>Calculate the square root of a number using the <code>MathUtils</code> class</p> <pre><code>&gt;&gt;&gt; MathUtils.sqrt(32.4)\n5.692099788303...\n</code></pre> <p>Solve a linear system of equations, <code>Ax=b</code>, using the <code>Matrix</code> library class and the <code>gateway</code> object to allocate memory for the <code>A</code> and <code>b</code> arrays</p> <pre><code>&gt;&gt;&gt; A = jar.gateway.new_array(jar.lib.Double, 3, 3)\n&gt;&gt;&gt; coefficients = [[3, 2, -1], [7, -2, 4], [-1, 5, 1]]\n&gt;&gt;&gt; for i in range(3):\n...     for j in range(3):\n...         A[i][j] = float(coefficients[i][j])\n...\n&gt;&gt;&gt; b = jar.gateway.new_array(jar.lib.Double, 3)\n&gt;&gt;&gt; b[0] = 4.0\n&gt;&gt;&gt; b[1] = 15.0\n&gt;&gt;&gt; b[2] = 12.0\n&gt;&gt;&gt; x = Matrix.solve(Matrix(A), Matrix(b))\n&gt;&gt;&gt; print(x.toString())\n+1.000000e+00\n+2.000000e+00\n+3.000000e+00\n</code></pre> <p>Verify that <code>x</code> is the solution</p> <pre><code>&gt;&gt;&gt; for i in range(3):\n...     x_i = 0.0\n...     for j in range(3):\n...         x_i += coefficients[i][j] * x.getValue(j,0)\n...     assert abs(x_i - b[i]) &lt; 1e-12\n...\n</code></pre> <p>Shutdown the connection to the JVM when finished</p> <pre><code>&gt;&gt;&gt; jar.gateway.shutdown()\n</code></pre>"},{"location":"usage/direct/java/#example-class","title":"Example (.class)","text":"<p>Load the example Java byte code, <code>Trig.class</code></p> <pre><code>&gt;&gt;&gt; cls = LoadLibrary(EXAMPLES_DIR / \"Trig.class\")\n&gt;&gt;&gt; cls\n&lt;LoadLibrary libtype=JVMView path=...Trig.class&gt;\n&gt;&gt;&gt; cls.lib\n&lt;py4j.java_gateway.JVMView object at ...&gt;\n</code></pre> <p>The Java library contains a <code>Trig</code> class, which calculates various trigonometric quantities</p> <pre><code>&gt;&gt;&gt; Trig = cls.lib.Trig\n&gt;&gt;&gt; Trig\n&lt;py4j.java_gateway.JavaClass object at ...&gt;\n&gt;&gt;&gt; Trig.cos(1.2)\n0.3623577544766...\n&gt;&gt;&gt; Trig.asin(0.6)\n0.6435011087932...\n&gt;&gt;&gt; Trig.tanh(1.3)\n0.8617231593133...\n</code></pre> <p>Shutdown the connection to the JVM when finished</p> <pre><code>&gt;&gt;&gt; cls.gateway.shutdown()\n</code></pre>"},{"location":"usage/direct/java/#java-lib","title":"Java Source Code","text":"java_lib.jar MathUtils.javaMatrix.java <pre><code>package nz.msl.examples;\n\npublic class MathUtils {\n\n  /** Generate a random number between [0, 1) */\n  static public double random() {\n    return Math.random();\n  }\n\n  /** Calculate the square root of {@code x} */\n  static public double sqrt(double x) {\n    return Math.sqrt(x);\n  }\n\n}\n</code></pre> <pre><code>package nz.msl.examples;\n\nimport java.util.Random;\n\n\npublic class Matrix {\n\n  /** The matrix, M */\n  private double[][] m;\n\n  /** Lower-triangular matrix representation, M=LU, in LU Decomposition */\n  private Matrix L;\n\n  /** Upper-triangular matrix representation, M=LU, in LU Decomposition */\n  private Matrix U;\n\n  /** A NxM orthogonal matrix representation, M=QR, in QR Decomposition */\n  private Matrix Q;\n\n  /** Upper-triangular matrix representation, M=QR, in QR Decomposition */\n  private Matrix R;\n\n  /** When calculating the inverse we calculate the LU matrices once */\n  static private boolean calculatingInverse = false;\n\n  /*\n   * \n   * Define the constructors.\n   * \n   *    \n   */\n\n  /** Create a Matrix that is a copy of another Matrix. */\n  public Matrix(Matrix m) {\n    this.m = new double[m.getNumberOfRows()][m.getNumberOfColumns()];\n    for (int i=0; i&lt;m.getNumberOfRows(); i++)\n      for (int j=0; j&lt;m.getNumberOfColumns(); j++)\n        this.m[i][j] = m.getValue(i,j);\n  }\n\n  /** Create a {@code n} x {@code n} identity Matrix */\n  public Matrix(int n) {\n    m = new double[n][n];\n    for (int i=0; i&lt;n; i++) \n      m[i][i] = 1.0;\n  }\n\n  /** Create a {@code rows} x {@code cols} Matrix filled with zeros. */\n  public Matrix(int rows, int cols) {\n    m = new double[rows][cols];\n  }\n\n  /** Create a {@code rows} x {@code cols} Matrix filled with a value. */\n  public Matrix(int rows, int cols, double value) {\n    m = new double[rows][cols];\n    for (int i=0; i&lt;rows; i++)\n      for (int j=0; j&lt;cols; j++)\n        m[i][j] = value;\n  }\n\n  /**\n   * Create a {@code rows} x {@code cols} Matrix that is filled with \n   * uniformly-distributed random values that are within the range \n   * {@code min} to {@code max}.\n   */\n  public Matrix(int rows, int cols, double min, double max) {\n    Random rand = new Random();\n    m = new double[rows][cols];    \n    for (int i=0; i&lt;rows; i++)\n      for (int j=0; j&lt;cols; j++)        \n        m[i][j] = (max-min)*rand.nextDouble()+min;\n  }\n\n  /** Create a Matrix from {@code m}. */\n  public Matrix(Double[][] m) {    \n    this.m = new double[m.length][m[0].length];\n    for (int i=0; i&lt;m.length; i++)\n      for (int j=0; j&lt;m[0].length; j++)        \n        this.m[i][j] = m[i][j];\n  }\n\n  /** Create a Matrix from a vector. */\n  public Matrix(Double[] vector) {\n    m = new double[1][vector.length];\n    for (int i=0; i&lt;vector.length; i++)\n      m[0][i] = vector[i];    \n  }  \n\n  /*\n   * \n   * The public static methods.\n   *\n   * \n   */\n\n  /** Returns the product of two Matrices as a new Matrix, C=AB. */\n  public static Matrix multiply(Matrix a, Matrix b) {    \n    if (a.getNumberOfColumns() != b.getNumberOfRows()) {\n      throw new IllegalArgumentException(\n          String.format(\"ERROR! Cannot multiply a %dx%d matrix \"\n            + \"with a %dx%d matrix\",\n            a.getNumberOfRows(), a.getNumberOfColumns(),\n            b.getNumberOfRows(), b.getNumberOfColumns()));\n    } else {\n      Matrix c = new Matrix(a.getNumberOfRows(), b.getNumberOfColumns());\n      double sum = 0.0;\n      for (int i = 0; i &lt; a.getNumberOfRows() ; i++) {\n        for (int j = 0; j &lt; b.getNumberOfColumns(); j++) {\n                 for (int k = 0 ; k &lt; b.getNumberOfRows() ; k++) {\n                    sum += a.getValue(i,k)*b.getValue(k,j);\n                 }\n                 c.setValue(i, j, sum);\n                 sum = 0.0;\n              }\n           }\n      return c;\n    }\n  }\n\n  /** \n   * Solves {@code b = Ax} for {@code x}.\n   * \n   * @param A - the coefficient matrix\n   * @param b - the expected values\n   * @return x - the solution to the system of equations\n   */\n  public static Matrix solve(Matrix A, Matrix b) {\n\n    // ensure that 'b' is a column vector\n    if (b.getNumberOfColumns() &gt; 1)  b = b.transpose();\n\n    // ensure that 'A' and 'b' have the correct dimensions\n    if (b.getNumberOfRows() != A.getNumberOfRows()) {\n      throw new IllegalArgumentException(\n        String.format(\"ERROR! Dimension mismatch when solving the \"\n          + \"system of equations using b=Ax, b has dimension \"\n          + \" %dx%d and A is %dx%d.\", b.getNumberOfRows(), \n          b.getNumberOfColumns(), A.getNumberOfRows(),\n          A.getNumberOfColumns()));\n    }\n\n    // if A is an under-determined system of equations then use the \n    // matrix-multiplication expression to solve for x\n    if (A.getNumberOfRows() &lt; A.getNumberOfColumns()) {\n      Matrix At = A.transpose();\n      return Matrix.multiply(Matrix.multiply(At, \n          Matrix.multiply(A, At).getInverse() ), b);\n    }\n\n    // If A is a square matrix then use LU Decomposition, if it is an \n    // over-determined system of equations then use QR Decomposition\n    Double[] x = new Double[A.getNumberOfColumns()];\n    if (A.isSquare()) {\n\n      // when using 'solve' to calculate the inverse of a matrix we\n      // only need to generate the LU Decomposition matrices once\n      if (!calculatingInverse) A.makeLU();\n\n      // solve Ly=b for y using forward substitution\n      double[] y = new double[b.getNumberOfRows()];\n      y[0] = b.getValue(0,0);\n      for (int i=1; i&lt;y.length; i++) {\n        y[i] = b.getValue(i,0);\n        for (int j=0; j&lt;i; j++)\n          y[i] -= A.getL().getValue(i,j)*y[j];\n      }\n\n      // solve Ux=y for x using backward substitution\n      for (int i=x.length-1; i&gt;-1; i--) {\n        x[i] = y[i];\n        for (int j=i+1; j&lt;x.length; j++)\n          x[i] -= A.getU().getValue(i,j)*x[j];\n        x[i] /= A.getU().getValue(i,i);\n      }\n\n    } else {\n\n      A.makeQR();\n      Matrix d = Matrix.multiply(A.getQ().transpose(), b);\n\n      // solve Rx=d for x using backward substitution\n      for (int i=x.length-1; i&gt;-1; i--) {\n        x[i] = d.getValue(i, 0);\n        for (int j=i+1; j&lt;x.length; j++)\n          x[i] -= A.getR().getValue(i,j)*x[j];\n        x[i] /= A.getR().getValue(i,i);\n      }      \n    }    \n\n    return new Matrix(x).transpose();\n  }\n\n  /*\n   * \n   * The public methods.\n   *\n   * \n   */\n\n  /** Returns the primitive data of the Matrix. */\n  public double[][] primitive() {\n    return m;\n  }\n\n  /** Convert the Matrix to a string. */\n  @Override\n  public String toString() {\n    StringBuffer sb = new StringBuffer();\n    for (int i=0; i&lt;m.length; i++) {\n      for (int j=0; j&lt;m[0].length; j++) {\n        sb.append(String.format(\"%+.6e\\t\", m[i][j]));\n      }\n      sb.append(\"\\n\");\n    }\n    return sb.toString();\n  }\n\n  /** Returns the number of rows in the Matrix. */\n  public int getNumberOfRows() {\n    return m.length;\n  }\n\n  /** Returns the number of columns in the Matrix. */\n  public int getNumberOfColumns() {\n    try {\n      return m[0].length; \n    } catch (ArrayIndexOutOfBoundsException e) {\n      return 0;\n    }\n  }\n\n  /** Returns the value at {@code row} and {@code col}. */\n  public double getValue(int row, int col) {\n    return m[row][col];\n  }\n\n  /** Sets the value at {@code row} and {@code col} to be {@code value}. */\n  public void setValue(int row, int col, double value) {\n    m[row][col] = value;\n  }  \n\n  /** Returns the transpose of the Matrix. */\n  public Matrix transpose() {\n    Matrix mt = new Matrix(m[0].length, m.length);\n    for (int i=0; i&lt;m.length; i++)\n      for (int j=0; j&lt;m[0].length; j++)\n        mt.setValue(j, i, m[i][j]);\n    return mt;\n  }\n\n  /** Returns whether the Matrix is a square Matrix. */\n  public boolean isSquare() {\n    return m.length == m[0].length;\n  }\n\n  /** Returns the determinant of the Matrix. */\n  public double getDeterminant() {\n    if (isSquare()) {\n      makeLU();\n      double det = 1.0;\n      for (int i=0; i&lt;m.length; i++)\n        det *= U.getValue(i,i);\n      // 's' is the number of row and column exchanges in LU Decomposition\n      // but we are currently not using pivoting\n      int s = 0;\n      return Math.pow(-1.0, s)*det;\n    } else {\n      return Double.NaN;\n    }\n  }\n\n  /** Returns the lower-triangular Matrix, L, from a LU Decomposition */\n  public Matrix getL() {\n    if (L==null) makeLU();\n    return L;\n  }\n\n  /** Returns the upper-triangular Matrix, U, from a LU Decomposition */\n  public Matrix getU() {\n    if (U==null) makeLU();\n    return U;\n  }\n\n  /** Returns the orthogonal Matrix, Q, from a QR Decomposition */\n  public Matrix getQ() {\n    if (Q==null) makeQR();\n    return Q;\n  }\n\n  /** Returns the upper-triangular Matrix, R, from a QR Decomposition */\n  public Matrix getR() {\n    if (R==null) makeQR();\n    return R;\n  }\n\n  /** Returns the inverse of the Matrix, if it exists. */\n  public Matrix getInverse() {\n    if (isSquare()) {\n      Matrix inv = new Matrix(m.length);\n      Matrix bb = new Matrix(m.length);\n      for (int i=0; i&lt;m.length; i++) {\n        inv.setColumn(i, Matrix.solve(this, bb.getColumn(i)));\n        calculatingInverse = true;\n      }\n      calculatingInverse = false;\n      return inv;\n    } else {\n      throw new IllegalArgumentException(\n        String.format(\"ERROR! Cannot calculate the inverse of a \"\n          + \"%dx%d matrix, it must be a square Matrix\", \n          m.length, m[0].length));\n    }\n  }\n\n\n  /*\n   * \n   * Private methods.\n   * \n   * \n   */\n\n  /** \n   * Create the Lower, L, and Upper, U, triangular matrices, such that M=LU.\n   * Does not use pivoting. \n   */\n  private void makeLU() {\n    L = new Matrix(m.length); // create an identity matrix\n    U = new Matrix(this); // copy the values of this matrix\n    double val;\n    for (int k=0; k&lt;m[0].length; k++) {\n      for (int i=k+1; i&lt;m.length; i++) {\n        val = U.getValue(i,k)/U.getValue(k,k);\n        L.setValue(i, k, val);\n        for (int j=k; j&lt;m[0].length; j++)\n          U.setValue(i, j, U.getValue(i,j)-val*U.getValue(k,j));\n      }\n    }    \n  }\n\n  /** \n   * Computes the QR Factorization matrices using a modified \n   * Gram\u2013Schmidt process.&lt;p&gt;\n   * \n   * @see https://people.inf.ethz.ch/gander/papers/qrneu.pdf\n   */\n  private void makeQR() {\n\n    Q = new Matrix(m.length, m[0].length);\n    R = new Matrix(m[0].length, m[0].length);\n    Matrix A = new Matrix(this);\n\n    double s;\n    for (int k=0; k&lt;m[0].length; k++) {\n      s = 0.0;\n      for (int j=0; j&lt;m.length; j++)\n        s += Math.pow(A.getValue(j, k), 2);\n      s = Math.sqrt(s);\n      R.setValue(k, k, s);\n      for (int j=0; j&lt;m.length; j++)\n        Q.setValue(j, k, A.getValue(j, k)/s);\n      for (int i=k+1; i&lt;m[0].length; i++) {\n        s = 0.0;\n        for (int j=0; j&lt;m.length; j++)\n          s += A.getValue(j, i)*Q.getValue(j, k);\n        R.setValue(k, i, s);\n        for (int j=0; j&lt;m.length; j++)\n          A.setValue(j, i, A.getValue(j,i)-R.getValue(k,i)*Q.getValue(j,k));\n      }\n    }\n  }\n\n  /** Returns a copy of the specified column. */\n  private Matrix getColumn(int column) {\n    if (column &lt; m[0].length) {\n      Matrix c = new Matrix(m.length, 1);\n      for (int i=0; i&lt;m.length; i++)\n        c.setValue(i, 0, m[i][column]);\n      return c;\n    } else {\n      throw new IllegalArgumentException(\n        String.format(\"ERROR! Cannot get column %d in the Matrix \"\n          + \"since it is &gt; the number of columns in the \"\n          + \"Matrix, %d.\", column, m[0].length));\n    }\n  }\n\n  /** \n   * Replace the values in the specified column of the matrix to the values in\n   * {@code vector}.\n   *  \n   * The {@code vector} must be a 1D vector, can have dimension 1xN or Nx1.\n   */\n  private void setColumn(int column, Matrix vector) {\n\n    // make sure that 'vector' is either a 1xN or Nx1 vector and not a NxM Matrix\n    if ( (vector.getNumberOfColumns() != 1) &amp;&amp; (vector.getNumberOfRows() != 1) ) {\n      throw new IllegalArgumentException(\n        String.format(\"ERROR! Require a 1D vector to replace the values \"\n          + \"in a column of a matrix. Got a %dx%d vector.\", \n          vector.getNumberOfRows(), vector.getNumberOfColumns()));\n    }\n\n    // make sure we have a column vector\n    if (vector.getNumberOfColumns() != 1) {\n      vector = vector.transpose();\n    }\n\n    // make sure the 'vector' has the correct length\n    if (vector.getNumberOfRows() != m.length) {\n      throw new IllegalArgumentException(\n        String.format(\"ERROR! Cannot replace a Matrix column of length \"\n          + \"%d, with a column vector of length %d.\",\n          m.length, vector.getNumberOfRows()));\n    }\n\n    // make sure the column is valid\n    if (column &gt;= m[0].length) {\n      throw new IllegalArgumentException(\n        String.format(\"ERROR! Cannot replace column %d in the Matrix \"\n        + \"since it is &gt; the number of columns in the matrix.\", column));\n    }\n\n    for (int i=0; i&lt;m.length; i++)\n      m[i][column] = vector.getValue(i,0);\n  }\n\n}\n</code></pre> Trig.class <pre><code>/*\n * Compile with JDK 6 for maximal compatibility with Py4J\n * \n * javac Trig.java\n *\n */\n\npublic class Trig {\n\n  /** Returns the trigonometric cosine of an angle. */\n  static public double cos(double x) {\n    return Math.cos(x);\n  }\n\n  /** Returns the hyperbolic cosine of a value. */\n  static public double cosh(double x) {\n    return Math.cosh(x);\n  }\n\n  /** Returns the arc cosine of a value, [0.0, pi]. */\n  static public double acos(double x) {\n    return Math.acos(x);\n  }\n\n  /** Returns the trigonometric sine of an angle. */\n  static public double sin(double x) {\n    return Math.sin(x);\n  }\n\n  /** Returns the hyperbolic sine of a value. */\n  static public double sinh(double x) {\n    return Math.sinh(x);\n  }\n\n  /** Returns the arc sine of a value, [-pi/2, pi/2]. */\n  static public double asin(double x) {\n    return Math.asin(x);\n  }\n\n  /** Returns the trigonometric tangent of an angle. */\n  static public double tan(double x) {\n    return Math.tan(x);\n  }\n\n  /** Returns the hyperbolic tangent of a value. */\n  static public double tanh(double x) {\n    return Math.tanh(x);\n  }\n\n  /** Returns the arc tangent of a value; [-pi/2, pi/2]. */\n  static public double atan(double x) {\n    return Math.atan(x);\n  }\n\n  /** \n   * Returns the angle theta from the conversion of rectangular coordinates \n   * (x, y) to polar coordinates (r, theta).\n   */\n  static public double atan2(double y, double x) {\n    return Math.atan2(y, x);\n  }\n\n}\n</code></pre>"},{"location":"usage/direct/labview/","title":"LabVIEW","text":"<p>Load a 64-bit LabVIEW library in 64-bit Python. An appropriate LabVIEW Run-Time Engine must be installed. The LabVIEW example is only valid on Windows. To load the 32-bit library in 32-bit Python use <code>labview_lib32.dll</code> as the filename.</p> <p>Note</p> <p>A LabVIEW library can be built into a DLL using the <code>__cdecl</code> or <code>__stdcall</code> calling convention. Make sure that you specify the appropriate <code>libtype</code> when instantiating the LoadLibrary class for your LabVIEW library. The example library uses <code>__cdecl</code>.</p>"},{"location":"usage/direct/labview/#example","title":"Example","text":"<p>Load the example LabVIEW library</p> <pre><code>&gt;&gt;&gt; from msl.loadlib import LoadLibrary\n&gt;&gt;&gt; from msl.examples.loadlib import EXAMPLES_DIR\n&gt;&gt;&gt; labview = LoadLibrary(EXAMPLES_DIR / \"labview_lib64.dll\")\n&gt;&gt;&gt; labview\n&lt;LoadLibrary libtype=CDLL path=...labview_lib64.dll&gt;\n&gt;&gt;&gt; labview.lib\n&lt;CDLL '...labview_lib64.dll', handle ... at ...&gt;\n</code></pre> <p>Create some data to calculate the mean, variance and standard deviation of</p> <pre><code>&gt;&gt;&gt; data = [1, 2, 3, 4, 5, 6, 7, 8, 9]\n</code></pre> <p>Convert <code>data</code> to a ctypes array and allocate memory for the parameters</p> <pre><code>&gt;&gt;&gt; from ctypes import c_double\n&gt;&gt;&gt; x = (c_double * len(data))(*data)\n&gt;&gt;&gt; mean, variance, std = c_double(), c_double(), c_double()\n</code></pre> <p>Calculate the sample standard deviation (i.e., the third argument is set to 0) and variance. Pass <code>mean</code>, <code>variance</code>, <code>std</code> by reference using byref so that LabVIEW can write to the memory locations</p> <pre><code>&gt;&gt;&gt; from ctypes import byref\n&gt;&gt;&gt; ret = labview.lib.stdev(x, len(data), 0, byref(mean), byref(variance), byref(std))\n&gt;&gt;&gt; mean.value\n5.0\n&gt;&gt;&gt; variance.value\n7.5\n&gt;&gt;&gt; std.value\n2.7386127875258306\n</code></pre> <p>Calculate the population standard deviation (i.e., the third argument is set to 1) and variance</p> <pre><code>&gt;&gt;&gt; ret = labview.lib.stdev(x, len(data), 1, byref(mean), byref(variance), byref(std))\n&gt;&gt;&gt; mean.value\n5.0\n&gt;&gt;&gt; variance.value\n6.666666666666667\n&gt;&gt;&gt; std.value\n2.581988897471611\n</code></pre>"},{"location":"usage/direct/labview/#labview-lib","title":"LabVIEW Source Code","text":"labview_lib labview_lib.vilabview_lib.h <pre><code>#include \"extcode.h\"\n#pragma pack(push)\n#pragma pack(1)\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\ntypedef uint16_t  Enum;\n#define Enum_Sample 0\n#define Enum_Population 1\n\n/*!\n * stdev\n */\nvoid __cdecl stdev(double X[], int32_t lenX, Enum WeightingSample, \n    double *mean, double *variance, double *standardDeviation);\n\nMgErr __cdecl LVDLLStatus(char *errStr, int errStrLen, void *module);\n\n#ifdef __cplusplus\n} // extern \"C\"\n#endif\n\n#pragma pack(pop)\n</code></pre>"},{"location":"usage/direct/stdcall/","title":"Windows __stdcall","text":"<p>Load a 32-bit Windows <code>__stdcall</code> library in 32-bit Python, see kernel32. Include the <code>\"windll\"</code> argument to specify that the calling convention is <code>__stdcall</code>.</p> <pre><code>&gt;&gt;&gt; from msl.loadlib import LoadLibrary\n&gt;&gt;&gt; kernel = LoadLibrary(r\"C:\\Windows\\SysWOW64\\kernel32.dll\", \"windll\")\n&gt;&gt;&gt; kernel\n&lt;LoadLibrary libtype=WinDLL path=C:\\Windows\\SysWOW64\\kernel32.dll&gt;\n&gt;&gt;&gt; kernel.lib\n&lt;WinDLL 'C:\\Windows\\SysWOW64\\kernel32.dll', handle ... at ...&gt;\n</code></pre> <p>Create an instance of the SYSTEMTIME structure</p> <pre><code>&gt;&gt;&gt; from ctypes import byref\n&gt;&gt;&gt; from msl.examples.loadlib.kernel32 import SystemTime\n&gt;&gt;&gt; st = SystemTime()\n&gt;&gt;&gt; time = kernel.lib.GetLocalTime(byref(st))\n</code></pre> <p>Now that we have a SYSTEMTIME structure we can access its attributes and compare the values to the builtin datetime.datetime module</p> <pre><code>&gt;&gt;&gt; from datetime import datetime\n&gt;&gt;&gt; today = datetime.today()\n&gt;&gt;&gt; st.wYear == today.year\nTrue\n&gt;&gt;&gt; st.wMonth == today.month\nTrue\n&gt;&gt;&gt; st.wDay == today.day\nTrue\n</code></pre> <p>See here for an example on how to communicate with kernel32 from 64-bit Python.</p>"},{"location":"usage/ipc/","title":"Client-Server","text":"<p>This section of the documentation shows examples for how a module running within a 64-bit Python interpreter can communicate with a 32-bit library by using inter-process communication. The method that is used to allow a 32-bit and a 64-bit process to exchange information is by use of a file. The pickle module is used to (de)serialize Python objects.</p> <p>Attention</p> <p>See Direct if you want to load a 64-bit library in 64-bit Python or a 32-bit library in 32-bit Python.</p>"},{"location":"usage/ipc/#example-server","title":"Example Server","text":"<p>Suppose you want to call functions in a 32-bit C library, <code>my_lib.dll</code>, from a 64-bit Python interpreter. This C library is loaded by the following <code>MyServer</code> class, which is running within a 32-bit process. <code>MyServer</code> hosts the C library at a specified host address and port number. Any class that is a subclass of Server32 must provide two arguments in its constructor: <code>host</code> and <code>port</code>. Including keyword arguments in the constructor is optional.</p> <p>my_server.py</p> <pre><code>from __future__ import annotations\n\nfrom msl.loadlib import Server32\n\nclass MyServer(Server32):\n    \"\"\"Load a 32-bit C library 'my_lib.dll' that has an 'add' and a 'version' function.\"\"\"\n\n    def __init__(self, host: str, port: int, **kwargs: str) -&gt; None:\n        # The `host` and `port` arguments are mandatory.\n        # All values in `kwargs` are of type string.\n        # Calling super() loads the 'my_lib.dll' library using `ctypes.CDLL`.\n        super().__init__(\"my_lib.dll\", \"cdll\", host, port)\n\n        # The Server32 class has a `lib` attribute that is a reference\n        # to the ctypes.CDLL object.\n\n        # The 'version' function in the library returns an int32_t.\n        # Store the result as an attribute of 'MyServer'.\n        self.version: int = self.lib.version()\n\n    def add(self, a: int, b: int) -&gt; int:\n        # The 'add' function in the library takes two int32_t parameters\n        # and returns the sum.\n        return self.lib.add(a, b)\n</code></pre>"},{"location":"usage/ipc/#example-client","title":"Example Client","text":"<p>The following <code>MyClient</code> is a subclass of Client64 and it will communicate with <code>MyServer</code> to call functions in the C library. When an instance of <code>MyClient</code> is created, the server starts automatically so that <code>MyClient</code> can send requests to <code>MyServer</code> to call the <code>add</code> function in the C library and to get the value of the <code>version</code> attribute of <code>MyServer</code>. <code>MyServer</code> processes the request and sends the response back to <code>MyClient</code>.</p> <p>my_client.py</p> <pre><code>from __future__ import annotations\n\nfrom msl.loadlib import Client64\n\nclass MyClient(Client64):\n    \"\"\"Call a function in 'my_lib.dll' via the 'MyServer' wrapper.\"\"\"\n\n    def __init__(self, **kwargs) -&gt; None:\n        # Specify the name of the Python module to run on the 32-bit server (i.e., \"my_server\").\n        # All user-defined keyword arguments will appear as `kwargs` in `MyServer.__init__`.\n        super().__init__(\"my_server\", **kwargs)\n\n    def add(self, a: int, b: int) -&gt; int:\n        # The `Client64` class has a `request32` method to send a request to the 32-bit server.\n        # Send the `a` and `b` arguments to the `MyServer.add` method.\n        return self.request32(\"add\", a, b)\n\n    def version(self) -&gt; int:\n        # Get the 'version' attribute.\n        return self.request32(\"version\")\n</code></pre> <p>The <code>MyClient</code> class could then be used as follows</p> <pre><code>from my_client import MyClient\n\nc = MyClient()\nx = c.add(1, 2)\nv = c.version()\nc.shutdown_server32()\n\n# or as a context manager\nwith MyClient() as c:\n    x = c.add(1, 2)\n    v = c.version()\n</code></pre> <p>Keyword arguments, <code>kwargs</code>, that the Server32 subclass requires can be passed to the server from the Client64; however, the data types for the values of the <code>kwargs</code> are not preserved (since they are ultimately parsed from the command line). All data types for the values of <code>kwargs</code> will be of type str at the <code>__init__</code> method of the Server32 subclass. These <code>kwargs</code> are the only values where the data type is not preserved for the client-server protocol. See the Echo example which shows that data types are preserved between client-server method calls (provided that the value is pickleable).</p> Simplifying the Client <p>If you find yourself repeatedly implementing each method in your Client64 subclass in the following way (i.e., you are essentially duplicating the code for each method)</p> <pre><code>from msl.loadlib import Client64\n\nclass LinearAlgebra(Client64):\n\n    def __init__(self):\n        super().__init__(\"linear_algebra_32.py\")\n\n    def solve(self, matrix, vector):\n        return self.request32(\"solve\", matrix, vector)\n\n    def eigenvalues(self, matrix):\n        return self.request32(\"eigenvalues\", matrix)\n\n    def stdev(self, data, as_population=True)\n        return self.request32(\"stdev\", data, as_population=as_population)\n\n    def determinant(self, matrix):\n        return self.request32(\"determinant\", matrix)\n\n    def cross_product(self, vector1, vector2):\n        return self.request32(\"cross_product\", vector1, vector2)\n</code></pre> <p>Then you can simplify the implementation by defining your Client64 subclass as</p> <pre><code>from msl.loadlib import Client64\n\nclass LinearAlgebra(Client64):\n\n    def __init__(self):\n        super().__init__(\"linear_algebra_32.py\")\n\n    def __getattr__(self, name):\n        def send(*args, **kwargs):\n            return self.request32(name, *args, **kwargs)\n        return send\n</code></pre> <p>and you will get the same behaviour. If you call a method that does not exist on the Server32 subclass or if you specify the wrong number of arguments or keyword arguments then a Server32Error will be raised.</p> <p>There are situations where you may want to explicitly write some (or all) of the methods in the Client64 subclass in addition to (or instead of) implementing the <code>__getattr__</code> method, e.g.,</p> <ul> <li> <p>you are writing an API for others to use and you want features like autocomplete or docstrings to be available in the IDE that the person using your API is using</p> </li> <li> <p>you want the Client64 subclass to do error checking on the <code>*args</code>, <code>**kwargs</code> and/or on the result from the Server32 subclass (this allows you to have control over the type of Exception that is raised because if the Server32 subclass raises an exception then it is a Server32Error)</p> </li> <li> <p>you want to modify the returned object from a particular Server32 method, for example, a list is returned but you want the corresponding Client64 method to return a numpy.ndarray</p> </li> </ul>"},{"location":"usage/ipc/#runnable-examples","title":"Runnable Examples","text":"<p>The following examples are included with <code>msl-loadlib</code> to demonstrate how to communicate with libraries that were compiled in different programming languages or using different calling conventions.</p> <ul> <li>Echo</li> <li>C++</li> <li>FORTRAN</li> <li>.NET</li> <li>Windows __stdcall</li> <li>LabVIEW</li> </ul>"},{"location":"usage/ipc/cpp/","title":"C++","text":"<p>This example shows how to access a 32-bit C++ library from 64-bit Python. Cpp32 is the 32-bit server and Cpp64 is the 64-bit client.</p> <p>The source code of the C++ program is available here.</p> <p>Attention</p> <p>If you have issues running the example make sure that you have the prerequisites installed.</p> <p>Important</p> <p>By default, ctypes treats all input argument types and the return type of a library function to be a c_int. Therefore, the argtypes and the restype should be defined for each function in the library. The Cpp32 class shows various examples of defining the argtypes and the restype value.</p> <p>Create a Cpp64 client to communicate with the 32-bit library from 64-bit Python</p> <pre><code>&gt;&gt;&gt; from msl.examples.loadlib import Cpp64\n&gt;&gt;&gt; cpp = Cpp64()\n</code></pre>"},{"location":"usage/ipc/cpp/#ipc-cpp-numerics","title":"Numeric types","text":"<p>Add two integers, see Cpp64.add</p> <pre><code>&gt;&gt;&gt; cpp.add(3, 14)\n17\n</code></pre> <p>Subtract two C++ floating-point numbers, see Cpp64.subtract</p> <pre><code>&gt;&gt;&gt; cpp.subtract(43.2, 3.2)\n40.0\n</code></pre> <p>Add or subtract two C++ double-precision numbers, see Cpp64.add_or_subtract</p> <pre><code>&gt;&gt;&gt; cpp.add_or_subtract(1.0, 2.0, do_addition=True)\n3.0\n&gt;&gt;&gt; cpp.add_or_subtract(1.0, 2.0, do_addition=False)\n-1.0\n</code></pre>"},{"location":"usage/ipc/cpp/#ipc-cpp-arrays","title":"Arrays","text":"<p>Multiply a 1D array by a number, see Cpp64.scalar_multiply</p> <p>Attention</p> <p>The Cpp64.scalar_multiply function takes a pointer to an array as an input argument, see the source code. One cannot pass pointers from Client64 to Server32 because a 64-bit process cannot share the same memory space as a 32-bit process. All 32-bit pointers must be created (using ctypes) in the class that is a subclass of Server32 and only the value that is stored at that address can be returned to Client64 for use in the 64-bit program.</p> <pre><code>&gt;&gt;&gt; a = [float(val) for val in range(10)]\n&gt;&gt;&gt; cpp.scalar_multiply(2.0, a)\n[0.0, 2.0, 4.0, 6.0, 8.0, 10.0, 12.0, 14.0, 16.0, 18.0]\n</code></pre> <p>If you have a numpy.ndarray in 64-bit Python then you cannot pass the <code>ndarray</code> object to Server32 because the 32-bit server would need to load the <code>ndarray</code> in a 32-bit version of numpy (which is not included by default in the 32-bit server, but could be \u2013 see refreeze for more details). To simplify the procedure you could convert the <code>ndarray</code> to a list using the numpy.ndarray.tolist method</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; a = np.arange(9.)\n&gt;&gt;&gt; cpp.scalar_multiply(3.1, a.tolist())\n[0.0, 3.1, 6.2, 9.3, 12.4, 15.5, 18.6, 21.7, 24.8]\n</code></pre> <p>or you could use the builtin array.array class</p> <pre><code>&gt;&gt;&gt; from array import array\n&gt;&gt;&gt; b = array(\"d\", a.tobytes())\n&gt;&gt;&gt; cpp.scalar_multiply(3.1, b)\n[0.0, 3.1, 6.2, 9.3, 12.4, 15.5, 18.6, 21.7, 24.8]\n</code></pre> <p>If you want the returned value from <code>scalar_multiply</code> to be an <code>ndarray</code> use</p> <pre><code>&gt;&gt;&gt; np.array(cpp.scalar_multiply(3.1, b))\narray([ 0. ,  3.1,  6.2,  9.3, 12.4, 15.5, 18.6, 21.7, 24.8])\n</code></pre>"},{"location":"usage/ipc/cpp/#ipc-cpp-strings","title":"Strings","text":"<p>In this example the memory for the reversed string is allocated in Python, see Cpp64.reverse_string_v1</p> <pre><code>&gt;&gt;&gt; cpp.reverse_string_v1(\"hello world!\")\n'!dlrow olleh'\n</code></pre> <p>In this example the memory for the reversed string is allocated in C++, see Cpp64.reverse_string_v2</p> <pre><code>&gt;&gt;&gt; cpp.reverse_string_v2(\"uncertainty\")\n'ytniatrecnu'\n</code></pre>"},{"location":"usage/ipc/cpp/#ipc-cpp-structs","title":"Structs","text":"<p>It is possible to pickle a ctypes.Structure and pass the struct object between Cpp64 and Cpp32 provided that the struct is a fixed size in memory (i.e., the struct does not contain any pointers). If the struct contains pointers then you must create the struct within Cpp32 and you can only pass the values of the struct back to Cpp64.</p> <p>The source code of the C++ library contains the following structs</p> <pre><code>struct Point {\n    double x;\n    double y;\n};\n\nstruct FourPoints {\n    Point points[4];\n};\n\nstruct NPoints {\n    int n;\n    Point *points;\n};\n</code></pre> <p>The Cpp64.distance_4_points method uses the FourPoints struct to calculate the total distance connecting 4 Point structs. Since the FourPoints struct is a fixed size it can be created in 64-bit Python, pickled and then unpickled in Cpp32</p> <pre><code>&gt;&gt;&gt; from msl.examples.loadlib import FourPoints\n&gt;&gt;&gt; fp = FourPoints((0, 0), (0, 1), (1, 1), (1, 0))\n&gt;&gt;&gt; cpp.distance_4_points(fp)\n4.0\n</code></pre> <p>The Cpp32.circumference method uses the NPoints struct to calculate the circumference of a circle using n Point structs. Since the NPoints struct is not a fixed size it must be created in the Cpp32.circumference method. The Cpp64.circumference method takes the values of the radius and n as input arguments to pass to the Cpp32.circumference method.</p> <pre><code>&gt;&gt;&gt; for i in range(16):\n...     print(cpp.circumference(0.5, 2**i))\n...\n0.0\n2.0\n2.828427124746...\n3.061467458920...\n3.121445152258...\n3.136548490545...\n3.140331156954...\n3.141277250932...\n3.141513801144...\n3.141572940367...\n3.141587725277...\n3.141591421511...\n3.141592345569...\n3.141592576584...\n3.141592634337...\n3.141592648775...\n</code></pre> <p>You have access to the server's <code>stdout</code> and <code>stderr</code> streams when you shut down the server</p> <pre><code>&gt;&gt;&gt; stdout, stderr = cpp.shutdown_server32()\n</code></pre>"},{"location":"usage/ipc/dotnet/","title":".NET","text":"<p>This example shows how to access a 32-bit .NET library from 64-bit Python (Windows only \u2014 Mono can load both 32-bit and 64-bit libraries on 64-bit Linux and therefore a 32-bit .NET library can be loaded directly via LoadLibrary on 64-bit Linux). DotNet32 is the 32-bit server and DotNet64 is the 64-bit client. The source code of the C# program is available here.</p> Decompile a .NET assembly <p>The JetBrains dotPeek program can be used to decompile a .NET assembly. For example, peeking inside the example dotnet_lib32.dll library, that the DotNet32 class is a wrapper around, gives</p> <p></p> Configure a .NET runtime <p>To configure <code>pythonnet</code> to use the .NET Core runtime, you must either run</p> <pre><code>from pythonnet import load\nload(\"coreclr\")\n</code></pre> <p>or define a <code>PYTHONNET_RUNTIME=coreclr</code> environment variable, e.g.,</p> <pre><code>import os\nos.environ[\"PYTHONNET_RUNTIME\"] = \"coreclr\"\n</code></pre> <p>before super() is called in the Server32 subclass. To use the Mono runtime, replace <code>\"coreclr\"</code> with <code>\"mono\"</code>.</p> <p>Create a DotNet64 client to communicate with the 32-bit dotnet_lib32.dll library</p> <pre><code>&gt;&gt;&gt; from msl.examples.loadlib import DotNet64\n&gt;&gt;&gt; dn = DotNet64()\n</code></pre>"},{"location":"usage/ipc/dotnet/#ipc-cpp-numerics","title":"Numeric types","text":"<p>Add two integers, see DotNet64.add_integers</p> <pre><code>&gt;&gt;&gt; dn.add_integers(8, 2)\n10\n</code></pre> <p>Divide two C# floating-point numbers, see DotNet64.divide_floats</p> <pre><code>&gt;&gt;&gt; dn.divide_floats(3., 2.)\n1.5\n</code></pre> <p>Multiple two C# double-precision numbers, see DotNet64.multiply_doubles</p> <pre><code>&gt;&gt;&gt; dn.multiply_doubles(872.24, 525.525)\n458383.926\n</code></pre> <p>Add or subtract two C# double-precision numbers, see DotNet64.add_or_subtract</p> <pre><code>&gt;&gt;&gt; dn.add_or_subtract(99., 9., do_addition=True)\n108.0\n&gt;&gt;&gt; dn.add_or_subtract(99., 9., do_addition=False)\n90.0\n</code></pre>"},{"location":"usage/ipc/dotnet/#ipc-dotnet-arrays","title":"Arrays","text":"<p>Multiply a 1D array by a number, see DotNet64.scalar_multiply</p> <pre><code>&gt;&gt;&gt; a = [float(val) for val in range(10)]\n&gt;&gt;&gt; a\n[0.0, 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0]\n&gt;&gt;&gt; dn.scalar_multiply(2.0, a)\n[0.0, 2.0, 4.0, 6.0, 8.0, 10.0, 12.0, 14.0, 16.0, 18.0]\n</code></pre> <p>Multiply two matrices, see DotNet64.multiply_matrices</p> <pre><code>&gt;&gt;&gt; m1 = [[1., 2., 3.], [4., 5., 6.]]\n&gt;&gt;&gt; m2 = [[1., 2.], [3., 4.], [5., 6.]]\n&gt;&gt;&gt; dn.multiply_matrices(m1, m2)\n[[22.0, 28.0], [49.0, 64.0]]\n</code></pre>"},{"location":"usage/ipc/dotnet/#ipc-dotnet-strings","title":"Strings","text":"<p>Get the names of the classes in the .NET library module, see DotNet64.get_class_names</p> <pre><code>&gt;&gt;&gt; dn.get_class_names()\n['StringManipulation', 'StaticClass', 'DotNetMSL.BasicMath', 'DotNetMSL.ArrayManipulation']\n</code></pre> <p>Reverse a string, see DotNet64.reverse_string</p> <pre><code>&gt;&gt;&gt; dn.reverse_string(\"New Zealand\")\n'dnalaeZ weN'\n</code></pre>"},{"location":"usage/ipc/dotnet/#ipc-dotnet-static","title":"Static Class","text":"<p>Call the static methods in the <code>StaticClass</code> class</p> <pre><code>&gt;&gt;&gt; dn.add_multiple(1, 2, 3, 4, 5)\n15\n&gt;&gt;&gt; dn.concatenate(\"the\", \" experiment\", \" worked\", False, \" temporarily\")\n'the experiment worked'\n&gt;&gt;&gt; dn.concatenate(\"the\", \" experiment\", \" worked\", True, \" temporarily\")\n'the experiment worked temporarily'\n</code></pre> <p>You have access to the server's <code>stdout</code> and <code>stderr</code> streams when you shut down the server</p> <pre><code>&gt;&gt;&gt; stdout, stderr = dn.shutdown_server32()\n</code></pre>"},{"location":"usage/ipc/echo/","title":"Echo","text":"<p>This example illustrates that Python data types are preserved when they are passed from the Echo64 client to the Echo32 server and back. The Echo32.received_data method simply returns a tuple of the <code>(args, kwargs)</code> that it received back to the Echo64.send_data method in the client.</p> <p>Create an Echo64 instance</p> <pre><code>&gt;&gt;&gt; from msl.examples.loadlib import Echo64\n&gt;&gt;&gt; echo = Echo64()\n</code></pre> <p>send a boolean as an argument</p> <pre><code>&gt;&gt;&gt; echo.send_data(True)\n((True,), {})\n</code></pre> <p>send a boolean as a keyword argument</p> <pre><code>&gt;&gt;&gt; echo.send_data(boolean=True)\n((), {'boolean': True})\n</code></pre> <p>send multiple data types as arguments and as keyword arguments</p> <pre><code>&gt;&gt;&gt; echo.send_data(1.2, {\"my_list\":[1, 2, 3]}, 0.2j, range(10), x=True, y=\"hello world!\")\n((1.2, {'my_list': [1, 2, 3]}, 0.2j, range(0, 10)), {'x': True, 'y': 'hello world!'})\n</code></pre> <p>You have access to the server's <code>stdout</code> and <code>stderr</code> streams when you shut down the server</p> <pre><code>&gt;&gt;&gt; stdout, stderr = echo.shutdown_server32()\n</code></pre>"},{"location":"usage/ipc/fortran/","title":"FORTRAN","text":"<p>This example shows how to access a 32-bit FORTRAN library from 64-bit Python. Fortran32 is the 32-bit server and Fortran64 is the 64-bit client. The source code of the FORTRAN program is available here.</p> <p>Attention</p> <p>If you have issues running the example make sure that you have the prerequisites installed.</p> <p>Important</p> <p>By default, ctypes expects that a c_int data type is returned from the library call. If the returned value from the library is not a c_int then you must redefine the ctypes restype value to be the appropriate data type. Also, the input arguments must be passed by reference. The Fortran32 class shows various examples of passing arguments by reference and defining the restype value.</p> <p>Create a Fortran64 client to communicate with the 32-bit fortran_lib32 library</p> <pre><code>&gt;&gt;&gt; from msl.examples.loadlib import Fortran64\n&gt;&gt;&gt; f = Fortran64()\n</code></pre>"},{"location":"usage/ipc/fortran/#ipc-fortran-numerics","title":"Numeric types","text":"<p>Add two <code>int8</code> values, see Fortran64.sum_8bit</p> <pre><code>&gt;&gt;&gt; f.sum_8bit(-50, 110)\n60\n</code></pre> <p>Add two <code>int16</code> values, see Fortran64.sum_16bit</p> <pre><code>&gt;&gt;&gt; f.sum_16bit(2**15-1, -1)\n32766\n</code></pre> <p>Add two <code>int32</code> values, see Fortran64.sum_32bit</p> <pre><code>&gt;&gt;&gt; f.sum_32bit(123456788, 1)\n123456789\n</code></pre> <p>Add two <code>int64</code> values, see Fortran64.sum_64bit</p> <pre><code>&gt;&gt;&gt; f.sum_64bit(2**63, -2**62)\n4611686018427387904\n</code></pre> <p>Multiply two <code>float32</code> values, see Fortran64.multiply_float32</p> <pre><code>&gt;&gt;&gt; f.multiply_float32(2.0, 3.0)\n6.0\n</code></pre> <p>Multiply two <code>float64</code> values, see Fortran64.multiply_float64</p> <pre><code>&gt;&gt;&gt; f.multiply_float64(1e30, 2e3)\n2.00000000000...e+33\n</code></pre> <p>Check if a value is positive, see Fortran64.is_positive</p> <pre><code>&gt;&gt;&gt; f.is_positive(1.0)\nTrue\n&gt;&gt;&gt; f.is_positive(-0.1)\nFalse\n</code></pre> <p>Add or subtract two integers, see Fortran64.add_or_subtract</p> <pre><code>&gt;&gt;&gt; f.add_or_subtract(1000, 2000, do_addition=True)\n3000\n&gt;&gt;&gt; f.add_or_subtract(1000, 2000, do_addition=False)\n-1000\n</code></pre> <p>Calculate the n'th factorial, see Fortran64.factorial</p> <pre><code>&gt;&gt;&gt; f.factorial(0)\n1.0\n&gt;&gt;&gt; f.factorial(127)\n3.012660018457658e+213\n</code></pre> <p>Compute the Bessel function of the first kind of order 0, see Fortran64.besselJ0</p> <pre><code>&gt;&gt;&gt; f.besselJ0(8.6)\n0.0146229912787412...\n</code></pre>"},{"location":"usage/ipc/fortran/#ipc-fortran-arrays","title":"Arrays","text":"<p>Calculate the standard deviation of a list of values, see Fortran64.standard_deviation</p> <pre><code>&gt;&gt;&gt; f.standard_deviation([float(val) for val in range(1,10)])\n2.73861278752583...\n</code></pre> <p>Add two 1D arrays, see Fortran64.add_1d_arrays</p> <pre><code>&gt;&gt;&gt; a = [float(val) for val in range(1, 10)]\n&gt;&gt;&gt; b = [0.5*val for val in range(1, 10)]\n&gt;&gt;&gt; a\n[1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0]\n&gt;&gt;&gt; b\n[0.5, 1.0, 1.5, 2.0, 2.5, 3.0, 3.5, 4.0, 4.5]\n&gt;&gt;&gt; f.add_1d_arrays(a, b)\n[1.5, 3.0, 4.5, 6.0, 7.5, 9.0, 10.5, 12.0, 13.5]\n</code></pre> <p>Multiply two matrices, see Fortran64.matrix_multiply</p> <pre><code>&gt;&gt;&gt; m1 = [[1, 2, 3], [4, 5, 6]]\n&gt;&gt;&gt; m2 = [[1, 2], [3, 4], [5, 6]]\n&gt;&gt;&gt; f.matrix_multiply(m1, m2)\n[[22.0, 28.0], [49.0, 64.0]]\n</code></pre>"},{"location":"usage/ipc/fortran/#ipc-fortran-strings","title":"Strings","text":"<p>Reverse a string, see Fortran64.reverse_string</p> <pre><code>&gt;&gt;&gt; f.reverse_string(\"hello world!\")\n'!dlrow olleh'\n</code></pre> <p>You have access to the server's <code>stdout</code> and <code>stderr</code> streams when you shut down the server</p> <pre><code>&gt;&gt;&gt; stdout, stderr = f.shutdown_server32()\n</code></pre>"},{"location":"usage/ipc/labview/","title":"LabVIEW","text":"<p>This example shows how to access a 32-bit LabVIEW library from 64-bit Python. Labview32 is the 32-bit server and Labview64 is the 64-bit client. The source code of the LabVIEW program is available here.</p> <p>Attention</p> <p>This example requires that a 32-bit LabVIEW Run-Time Engine is installed and that the operating system is Windows.</p> <p>Create a Labview64 client to communicate with the 32-bit labview_lib32 library</p> <pre><code>&gt;&gt;&gt; from msl.examples.loadlib import Labview64\n&gt;&gt;&gt; labview = Labview64()\n</code></pre> <p>Calculate the mean, the sample variance and the standard deviation of some data, see Labview64.stdev</p> <pre><code>&gt;&gt;&gt; data = [1, 2, 3, 4, 5, 6, 7, 8, 9]\n&gt;&gt;&gt; labview.stdev(data)\n(5.0, 7.5, 2.7386127875258306)\n</code></pre> <p>Calculate the mean, the population variance and the standard deviation of <code>data</code></p> <pre><code>&gt;&gt;&gt; labview.stdev(data, weighting=1)\n(5.0, 6.666666666666667, 2.581988897471611)\n</code></pre> <p>You have access to the server's <code>stdout</code> and <code>stderr</code> streams when you shut down the server</p> <pre><code>&gt;&gt;&gt; stdout, stderr = labview.shutdown_server32()\n</code></pre>"},{"location":"usage/ipc/stdcall/","title":"Windows __stdcall","text":"<p>This example shows how to access the 32-bit Windows kernel32 library from 64-bit Python. Kernel32 is the 32-bit server and Kernel64 is the 64-bit client.</p> <p>Create a Kernel64 client to communicate with the 32-bit kernel32 library</p> <pre><code>&gt;&gt;&gt; from msl.examples.loadlib import Kernel64\n&gt;&gt;&gt; k = Kernel64()\n&gt;&gt;&gt; k.lib32_path\n'C:\\\\Windows\\\\SysWOW64\\\\kernel32.dll'\n</code></pre> <p>Call the library to get the current date and time by populating the SYSTEMTIME structure, see Kernel64.get_local_time</p> <pre><code>&gt;&gt;&gt; now = k.get_local_time()\n</code></pre> <p>You have access to the server's <code>stdout</code> and <code>stderr</code> streams when you shut down the server</p> <pre><code>&gt;&gt;&gt; stdout, stderr = k.shutdown_server32()\n</code></pre>"}]}